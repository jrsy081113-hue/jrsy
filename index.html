<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
    <title>jrsy</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <link rel="apple-touch-icon" href="https://jrsy081113-hue.github.io/jrsy/star-icon.png">
    <link rel="apple-touch-icon-precomposed" href="https://jrsy081113-hue.github.io/jrsy/star-icon.png">
    <style id="customBubblePreviewStyle"></style>
    <style id="customBubbleStyle"></style>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

html {
    height: 100%;
    overflow: hidden;
    position: fixed;
    width: 100%;
}

       body {
    font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
    background: #000;
    touch-action: manipulation;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    transition: all 0.3s ease;
    color: var(--text-color, #000);
    /* 【关键】这里不要有任何padding-top或padding-bottom */
}

        .phone {
    width: 100vw;
    /* 【默认】PWA模式使用vh */
    height: 100vh;
    /* 其他样式保持不变... */
    background: var(--theme-bg, #f7f7f7);
    position: relative;
    overflow: hidden;
    touch-action: manipulation; 
    border-radius: var(--phone-radius, 0px);
    transition: all 0.3s ease;
}

/* 【关键】只在非PWA模式（浏览器模式）下使用dvh */
@media not all and (display-mode: standalone) {
    .phone {
        height: 100dvh;
    }
}

        .screen {
            width: 100%;
            height: 100%;
            background: var(--theme-bg, #f7f7f7);
            position: relative;
            overflow: hidden;
            border-radius: var(--screen-radius, 0px);
            transition: all 0.3s ease;
        }

        /* --- MODIFIED: Status Bar Styles --- */
        /* --- 步骤 3.1: 精确重构状态栏 --- */

.status-bar {
    height: 30px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 15px;
    font-size: var(--font-size, 14px);
    font-weight: 600;
    color: var(--text-color, #000);
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    border-radius: var(--status-radius, 0px);
    transition: background-color 0.3s ease;
    background-color: var(--nav-bg, #f8f8f8); 
}

        
        /* New classes for JS to control transparency */
        .phone.home-screen-active .status-bar,
        .phone.listen-together-active .status-bar {
            background-color: transparent;
        }
        
        .phone.home-screen-active .status-bar {
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        .wechat-dark-mode.home-screen-active .status-bar {
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .phone.listen-together-active .status-bar {
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        /* [NEW] Voice call status bar color */
        .phone.voice-call-active .status-bar {
             color: #fff;
             background-color: transparent;
             text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }


        .status-left {
            display: flex;
            align-items: center;
        }

        .status-right {
            display: flex;
            align-items: center;
            gap: 1px;
        }

        .signal-icon {
            width: 18px;
            height: 12px;
            display: flex;
            align-items: flex-end;
            gap: 2px;
        }

        .signal-bar {
            width: 3px;
            background: var(--text-color, #000);
            border-radius: 1px;
        }
        
        .phone.listen-together-active .signal-bar,
        .phone.voice-call-active .signal-bar {
             background: #fff;
        }

        .signal-bar:nth-child(1) { height: 3px; }
        .signal-bar:nth-child(2) { height: 6px; }
        .signal-bar:nth-child(3) { height: 9px; }
        .signal-bar:nth-child(4) { height: 12px; }

        .network-icon {
            width: 28px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-color, #000);
            margin: 0 2px;
        }
        
        .phone.listen-together-active .network-icon,
        .phone.voice-call-active .network-icon {
            color: #fff;
        }

        .network-icon svg {
            width: 100%;
            height: 100%;
        }

        .battery-icon {
            width: 24px;
            height: 12px;
            border: 1px solid var(--text-color, #000);
            border-radius: var(--small-radius, 2px);
            position: relative;
            background: transparent;
            transition: all 0.3s ease;
        }
        
        .phone.listen-together-active .battery-icon,
        .phone.voice-call-active .battery-icon {
            border-color: #fff;
        }

        .battery-level {
            height: 100%;
            background: var(--text-color, #000);
            width: 80%;
            border-radius: var(--small-radius, 1px);
            transition: all 0.3s ease;
        }
        
        .phone.listen-together-active .battery-level,
        .phone.voice-call-active .battery-level {
             background: #fff;
        }

        .battery-tip {
            position: absolute;
            right: -3px;
            top: 3px;
            width: 2px;
            height: 6px;
            background: var(--text-color, #000);
            border-radius: 0 var(--small-radius, 1px) var(--small-radius, 1px) 0;
            transition: all 0.3s ease;
        }

        .phone.listen-together-active .battery-tip,
        .phone.voice-call-active .battery-tip {
             background: #fff;
        }

        .home-screen {
            height: 100%;
            background-size: cover;
            background-position: center;
            padding: 0;
            display: flex;
            flex-direction: column;
            margin-top: 0;
            position: relative;
            overflow-y: auto; 
            padding-bottom: 120px; /* Space for the bottom dock */
        }
        
        /* --- NEW: Profile Widget Container --- */
        /* --- 【最终版】请替换为这段代码 --- */

.profile-widget-container {
    width: 85%;
    max-width: 340px;
    /* 改为简单固定的边距 */
    margin: 70px auto 20px; 
    background-color: var(--bg-primary, white);
    border-radius: var(--app-radius, 14px);
    padding: 20px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
}

        .profile-widget-container.transparent-bg {
            background-color: transparent;
            box-shadow: none;
        }
        .profile-widget-container .profile-widget {
            margin: 0 auto; /* Override its own margin */
            padding: 0;
            width: 100%;
        }


       

        .profile-avatar-widget {
            width: 80px;
            height: 80px;
            border-radius: var(--avatar-radius, 50%);
            background: linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(240,248,255,0.8) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            color: #4a90e2;
            border: 3px solid rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            background-size: cover;
            background-position: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0 auto 15px;
        }

        .widget-info-section {
            background: transparent;
            padding: 0 20px;
            text-align: center;
        }

        .profile-name-widget {
            font-size: 22px;
            font-weight: 700;
            color: var(--text-color, #333333);
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            margin-bottom: 8px;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .profile-signature-widget {
            font-size: 14px;
            color: var(--text-color, #555555);
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            font-style: italic;
            cursor: pointer;
            transition: color 0.2s ease;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .profile-location {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            color: var(--text-color, #666666);
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .location-icon {
            width: 14px;
            height: 14px;
            margin-right: 4px;
            fill: currentColor;
        }
        
        .home-widgets-container {
            display: flex;
            gap: 15px;
            padding: 0 20px;
            width: 100%;
            max-width: 340px;
            margin: 30px auto 0;
            align-items: flex-start;
        }
        
        .new-widget {
            flex: 1;
            aspect-ratio: 1 / 1;
            background-color: var(--bg-primary, white);
            border-radius: var(--app-radius, 14px);
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        /* --- NEW: Small widget transparent style --- */
        .new-widget.transparent-bg {
            background-color: transparent;
            box-shadow: none;
        }

        .widget-header-text {
            font-size: 12px;
            font-family: monospace;
            cursor: pointer;
            color: var(--text-color, #333);
            min-height: 20px; /* ←←← 在这里添加新代码 */
        }

        .widget-bubble {
            background-color: var(--bg-hover, #f5f5f5);
            border-radius: 20px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 13px;
            font-weight: 500;
             color: var(--text-color, #333);
        }
                .widget-bubble span {
            cursor: pointer;
            flex-grow: 1;
            text-align: center;
            min-height: 20px; /* ←←← 新增：给它一个最小高度！ */
        }
        .widget-bubble img {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            object-fit: cover;
            background-color: #ccc;
        }
        .wechat-dark-mode .widget-bubble {
            background-color: #3a3a3c;
        }


        .app-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            aspect-ratio: 1 / 1;
            justify-items: center;
            align-content: space-between;
        }

        .app {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .app-icon-container {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: var(--app-radius, 14px);
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.8);
            border: 1px solid rgba(0,0,0,0.05);
            transition: all 0.3s ease;
            background-size: cover;
            background-position: center;
        }
        
        .app-icon-container .app-icon {
            width: 45%;
            height: 45%;
        }


        .app-icon {
            width: 32px;
            height: 32px;
            fill: #000;
            filter: none;
        }
        
        .app.wechat .app-icon { 
            fill: #000; 
        }

        .app-label {
    margin-top: 6px;
    color: var(--app-label-color, #333); /* <--- 修改了这里 */
    font-size: 10px;
    font-weight: 600;
}

        /* --- MODIFIED: Bottom Dock Styles --- */
    /* --- 用这个最终版代码替换你原来的 .bottom-dock --- */
.bottom-dock {
    position: absolute;
    /* 
     * 【决定性修复】
     * 删除了 "+ env(safe-area-inset-bottom, 0px)"
     * 因为父容器 .phone 的高度已经通过JS精确计算好了，
     * 我们不再需要在这里重复计算安全距离。
     */
    bottom: 20px; 
    
    left: 50%;
    transform: translateX(-50%);
    width: calc(100% - 30px);
    max-width: 380px;
    height: 95px; 
    background: rgba(240, 240, 240, 0.7); 
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border-radius: 40px; 
    padding: 10px 20px;
    display: flex;
    gap: 15px;
    justify-content: center;
    align-items: center;
    z-index: 50;
}
        .wechat-dark-mode .bottom-dock {
            background: rgba(44, 44, 46, 0.7); /* MODIFIED: Frosted glass effect for dark mode */
        }
        .bottom-dock .app {
            width: 100%;
            flex: 1;
        }
        .bottom-dock .app-icon-container {
            width: 75%; 
            max-width: 55px;
            margin: 0 auto;
        }
        .bottom-dock .app-label {
            margin-top: 5px; 
            font-size: 10px; 
            font-weight: 600;
            color: var(--text-color);
        }

        .page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--theme-bg, #f7f7f7);
            display: none;
            flex-direction: column;
            padding-top: 0;
            transition: transform 0.3s ease-in-out;
            transform: translateX(100%);
        }

        .page.active {
            display: flex;
            transform: translateX(0);
        }

        #homeScreen {
            transform: translateX(0);
        }

        
        #homeScreen.inactive {
            transform: translateX(-100%);
        }
        
        .page:not(.active) {
            transform: translateX(100%);
        }

        /* MODIFIED: Top Navigation Bar for Centering Title */
        /* 替换为下面的新代码 */

/* --- 步骤 3.2: 精确重构导航栏 --- */
.nav-bar {
    height: 44px;
    background: var(--nav-bg, #f8f8f8);
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 8px;
    flex-shrink: 0;
    position: absolute;
    /* 【关键】它的顶部位置，精确地等于状态栏的高度 */
    top: calc(30px + env(safe-area-inset-top, 0px)); 
    left: 0;
    right: 0;
    z-index: 10;
}

        /* 替换为下面的新代码 */
.nav-title {
    position: absolute;   /* 魔法1：让标题"漂浮"起来 */
    left: 50%;            /* 魔法2：把它推到中线位置 */
    top: 50%;
    transform: translate(-50%,-50%); /* 魔法3：再把它往回拉自己的一半，实现完美居中 */
    
    /* 以下是保留的样式 */
    text-align: center;
    font-size: var(--nav-font-size, 17px);
    font-weight: 600;
    color: var(--text-color, #000);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 60%; /* 添加一个最大宽度，防止标题太长和两边按钮重叠 */
}

        
     .page > .wechat-content,
.page > .settings-content,
.page > .discover-content,
.page > .profile-content,
.page > .chat-settings-content,
.page > .diary-content-view,
#phoneApp > .phone-app-container {
    padding-top: 74px; /* <--- 修改为 74px */
    height: 100%;
    overflow-y: auto;
}

        /* 修复BUG：为微信主界面的内容容器添加顶部内边距 */
        /* 修复BUG：为微信主界面的内容容器添加顶部内边距 */
#wechatApp > .wechat-content {
    padding-top: 74px; 
}
        /* 修复BUG：移除子元素的无效顶部内边距，防止双重边距 */
        #wechatApp .discover-content, #wechatApp .profile-content {
            padding-top: 0;
        }

        .nav-btn {
            background: none;
            border: none;
            font-size: 20px;
            color: var(--text-color, #000);
            cursor: pointer;
            padding: 4px 12px;
            border-radius: var(--btn-radius, 6px);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        /* --- 步骤 2.4: 替换 .wechat-bottom-nav 样式，正确处理安全区 --- */
.wechat-bottom-nav {
    /* 【决定性修复】让导航栏的总高度动态增加，以填满底部安全区 */
    height: calc(49px + env(safe-area-inset-bottom, 0px));
    
    background: var(--nav-bg, #f7f7f7);
    border-top: 1px solid var(--border-color, #e0e0e0);
    display: flex;
    position: absolute;
    
    /* 【决定性修复】让它紧贴容器的物理底部 */
    bottom: 0;
    
    width: 100%;
    z-index: 100;
    
    /* 【新增】确保内边距不会影响高度计算 */
    box-sizing: border-box;
    /* 【新增】只在底部增加内边距来把 *图标和文字* 推上去，而不是整个元素上移 */
    padding-bottom: env(safe-area-inset-bottom, 0px);
}

        .wechat-tab {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #999;
            font-size: var(--small-font-size, 10px);
        }

        .wechat-tab.active {
            color: #07c160;
        }

        .wechat-tab-icon {
            font-size: 18px;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-chat, .icon-discover, .icon-profile {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        /* --- 步骤 2.5: 替换 .wechat-content 样式，适配新的导航栏高度 --- */
.wechat-content {
    flex: 1;
    overflow-y: auto;
    /* 【决定性修复】使用和导航栏同样的方式动态计算底部间距 */
    padding-bottom: calc(49px + env(safe-area-inset-bottom, 0px));
    
    background: var(--theme-bg, #f7f7f7);
    transition: padding-bottom 0.3s ease;
}

        .friend-list {
            padding: 0;
            background: var(--theme-bg, #f7f7f7);
        }

        .friend-item {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-light, #f0f0f0);
            cursor: pointer;
            background: var(--bg-primary, white);
            position: relative;
        }

        .friend-item:hover {
            background: var(--bg-hover, #f5f5f5);
        }

        .friend-item.pinned {
            background: var(--bg-hover, #f5f5f5);
        }

        .friend-item.pinned + .friend-item:not(.pinned) {
            margin-top: 8px;
        }

        .friend-avatar {
            width: 50px;
            height: 50px;
            border-radius: var(--friend-avatar-radius, 8px);
            background: var(--bg-primary, white);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-color, #333);
            font-weight: bold;
            margin-right: 12px;
            background-size: cover;
            background-position: center;
            border: 1px solid var(--border-color, #e0e0e0);
            transition: all 0.3s ease;
            flex-shrink: 0; 
        }

        .friend-info {
            flex: 1;
            min-width: 0; 
        }

        .friend-name {
            font-size: var(--font-size, 16px);
            color: var(--text-color, #333);
            margin-bottom: 2px;
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .friend-message {
            font-size: var(--small-font-size, 13px);
            color: var(--text-secondary, #999);
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* --- [BUG FIX] White Module Fix START --- */
        #chatScreen .wechat-content {
            padding-top: 74px;
            padding-bottom: 0; /* Remove padding from container */
            background: transparent; /* Make container transparent */
            height: 100%;
            overflow: hidden; /* Prevent double scrollbars */
        }
        
        /* 这是修改后的代码 */
.chat-messages {
    height: 100%;
    padding: 15px 15px 65px 15px; /* 把底部的 50px 增加到了 65px */
    overflow-y: auto;
    background-size: cover;
    background-position: center;
    position: relative;
    transition: padding-bottom 0.3s ease;
}
        /* --- [BUG FIX] White Module Fix END --- */

        .message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start; /* MODIFIED: Set to flex-start for downward growth */
            max-width: 100%;
            position: relative;
        }

        .message.sent {
            justify-content: flex-end;
        }
        
        .message-sender-name {
            font-size: 12px;
            color: var(--text-secondary, #888);
            margin-bottom: 4px;
            padding: 0 4px;
        }

        .message .message-body {
            display: flex;
            flex-direction: column;
            min-width: 0; /* 修复Flexbox压缩问题 */
            flex: 1; /* 新增：确保消息主体占据可用空间 */
            position: relative; /* For blocked icon */
            max-width: calc(100% - 55px); /* [FIX] Prevent content from overlapping avatar */
        }

        .message.received .message-body {
            align-items: flex-start;
        }

        .message.sent .message-body {
            align-items: flex-end;
        }

        .message-content {
            max-width: 70%;
            padding: 10px 14px;
            font-size: var(--font-size, 15px);
            line-height: 1.4;
            word-wrap: break-word;
            word-break: break-word;
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            cursor: pointer;
            position: relative;
            border-radius: var(--message-radius, 18px);
            color: var(--text-color, #000000);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            -webkit-user-select: text; /* Allow text selection */
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }
        
        /* --- Bubble tails DISABLED --- */
        .message-content:not(.has-image):not(.has-emoji)::before {
            display: none;
        }
        .message.received .message-content:not(.has-image):not(.has-emoji)::before {
            display: none;
        }
        .message.sent .message-content:not(.has-image):not(.has-emoji)::before {
            display: none;
        }

        .message-content img {
            max-width: 180px;
            max-height: 180px;
            border-radius: 6px;
            display: block;
            cursor: pointer;
        }

        /* MODIFIED: Don't use bubble for images/emojis */
        .message-content.has-image,
        .message-content.has-emoji,
        .message-content.has-location {
            padding: 0;
            background-color: transparent;
            box-shadow: none;
            max-width: 250px; /* [FIX] Give location card a max-width */
        }
        
        /* MODIFIED: Emoji size adjustment */
        .message-content.has-emoji img {
            max-width: 100px;
            max-height: 100px;
        }

        .message.received .message-content {
            background-color: var(--message-received-bg, #E6F2FF);
        }

        .message.sent .message-content {
            background-color: var(--message-sent-bg, #FFEEF6);
        }
        
        .message.recalled .message-content,
        .message.pat_pat .message-content {
            background: transparent;
            color: var(--text-secondary, #999);
            font-style: italic;
            padding: 6px 0;
            font-size: var(--small-font-size, 13px);
            text-align: center;
            box-shadow: none;
            border-radius: 0;
            margin: 0 auto;
            max-width: 200px;
        }
        
        .message.recalled .message-content::before,
        .message.pat_pat .message-content::before {
            display: none;
        }

        .quoted-message {
            background: rgba(0,0,0,0.05);
            padding: 8px 10px;
            border-left: 3px solid #07c160;
            margin-bottom: 8px;
            border-radius: var(--small-radius, 4px);
            font-size: var(--small-font-size, 13px);
            color: var(--text-secondary, #666);
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .message.sent .quoted-message {
            border-left-color: var(--sent-quote-border-color, #d9b8c7);
        }
        .message.received .quoted-message {
            border-left-color: var(--received-quote-border-color, #c0d9ff);
        }
        .wechat-dark-mode .message.sent .quoted-message {
             border-left-color: var(--sent-quote-border-color, #0056b3);
             background: rgba(255,255,255,0.1);
        }
        .wechat-dark-mode .message.received .quoted-message {
            border-left-color: var(--received-quote-border-color, #555);
            background: rgba(255,255,255,0.1);
        }

        .chat-input-area {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 100;
            display: flex; /* FIX */
            flex-direction: column; /* FIX */
        }
        
        /* 这是修改后的代码 */
.chat-input {
    background: var(--nav-bg, #f7f7f7);
    border-top: 1px solid var(--border-color, #e0e0e0);
    display: flex;
    align-items: flex-end; 
    padding: 15px 8px;      /* 修改了这里：增加了上下留白 */
    gap: 8px;
    position: relative;
    z-index: 100;
    transition: min-height 0.2s ease;
    min-height: 65px;       /* 修改了这里：增加了整体最小高度 */
}

        .chat-input textarea {
            flex: 1;
            min-height: 35px;
            max-height: 120px; /* Limit max height */
            border: 1px solid var(--border-color, #d1d1d6);
            border-radius: var(--input-radius, 17px);
            padding: 8px 15px;
            font-size: var(--font-size, 15px);
            outline: none;
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            transition: all 0.3s ease;
            background: var(--bg-primary, white);
            color: var(--text-color, #000);
            resize: none;
            line-height: 1.4;
            overflow-y: auto;
        }

        .chat-btn {
            width: 35px;
            height: 35px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--font-size, 16px);
            transition: all 0.2s;
            background: transparent;
            color: var(--text-color, #333);
            border-radius: 50%;
            flex-shrink: 0;
            transition: transform 0.2s ease, width 0.2s ease, opacity 0.2s ease;
        }
        
        .send-btn {
            background: transparent;
            border-radius: var(--input-radius, 17px);
            transition: color 0.3s ease, background-color 0.3s ease, transform 0.2s ease, width 0.2s ease, opacity 0.2s ease, padding 0.2s ease;
            transform: scale(0.9);
            opacity: 0;
            width: 0;
            padding: 0;
        }
        
        #voiceBtn {
            transition: transform 0.2s ease, width 0.2s ease, opacity 0.2s ease;
        }


        .send-btn.active {
            transform: scale(1);
            opacity: 1;
            width: 35px;
            padding: 0;
            background-color: #007aff;
            color: white;
        }

        .chat-btn svg {
            width: 24px;
            height: 24px;
        }
        
        .send-btn svg {
            width: 20px;
            height: 20px;
            transform: rotate(-45deg) translate(1px, -1px);
        }
        .send-btn.active svg {
             fill: white;
        }

        .chat-avatar {
            width: 45px;
            height: 45px;
            border-radius: var(--chat-avatar-radius, 8px);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-color, #333);
            font-weight: bold;
            font-size: var(--small-font-size, 14px);
            margin: 0 8px 0 0;
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
            background-color: var(--bg-primary, white);
            border: 1px solid var(--border-color, #e0e0e0);
            transition: all 0.3s ease;
        }

        .message.sent .chat-avatar {
            margin: 0 0 0 8px;
            order: 2; /* [FIX] Ensure avatar is always on the outside */
        }
        .message.sent .message-body {
            order: 1; /* [FIX] Ensure message body is before avatar */
        }
        
        .chat-functions, .emoji-picker {
            background: var(--bg-primary, white);
            border-top: 1px solid var(--border-color, #e0e0e0);
            z-index: 50;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            padding: 0;
        }

        .chat-input-area.functions-open .chat-functions,
        .chat-input-area.emoji-open .emoji-picker {
            max-height: 250px;
        }

        .function-menu {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            padding: 15px;
        }

        .function-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            cursor: pointer;
            border-radius: var(--function-radius, 8px);
            transition: all 0.2s ease;
        }

        .function-icon {
            width: 50px;
            height: 50px;
            border-radius: var(--function-radius, 12px);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            margin-bottom: 5px;
            color: var(--text-secondary, #666);
            transition: all 0.3s ease;
            background-size: cover;
            background-position: center;
            background-color: var(--bg-hover, #f0f0f0);
        }
        
        .wechat-dark-mode .function-icon {
            background-color: #3a3a3c;
        }

        .function-icon svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        .function-label {
            font-size: var(--small-font-size, 12px);
            color: var(--text-color, #333);
            text-align: center;
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
        }
        
        .emoji-picker-header {
            display: flex;
            justify-content: flex-end;
            padding: 5px 15px 0 15px;
            gap: 10px;
        }

        .emoji-picker-btn {
            background: #007aff;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 6px;
            cursor: pointer;
        }
        .emoji-picker-btn.manage {
            background: #8e8e93;
        }

        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .emoji-grid .function-item {
            padding: 5px;
            position: relative;
        }
        
        .emoji-grid .function-icon {
            width: 50px;
            height: 50px;
        }

        .emoji-delete-btn {
            position: absolute;
            top: 0;
            right: 0;
            width: 20px;
            height: 20px;
            background-color: rgba(255, 59, 48, 0.9);
            color: white;
            border-radius: 50%;
            border: 1px solid white;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            line-height: 18px;
            cursor: pointer;
            transform: translate(30%, -30%);
        }
        .emoji-grid.managing .emoji-delete-btn {
            display: flex;
        }

        .message-menu {
            position: fixed;
            background: var(--bg-primary, white);
            border-radius: var(--menu-radius, 12px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 2000;
            display: none;
            padding: 8px;
            transition: all 0.3s ease;
            flex-direction: row;
            gap: 8px;
            opacity: 0;
            transform: scale(0.9);
            transform-origin: top left;
        }

        .message-menu.show {
            display: flex;
            opacity: 1;
            transform: scale(1);
        }

        .message-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: var(--font-size, 14px);
            color: var(--text-color, #333);
            border-radius: var(--btn-radius, 6px);
            transition: all 0.2s ease;
            background: var(--bg-hover, #f5f5f5);
            white-space: nowrap;
        }

        .message-menu-item.danger {
            color: #ff3b30;
        }

        .recall-message, .pat-pat-message {
            display: flex;
            justify-content: center;
            margin: 10px 0;
        }

        .recall-content, .pat-pat-content {
            background: rgba(0,0,0,0.05);
            padding: 6px 12px;
            border-radius: var(--recall-radius, 12px);
            font-size: var(--small-font-size, 13px);
            color: var(--text-secondary, #999);
            text-align: center;
            transition: all 0.3s ease;
        }

        .recall-content {
            cursor: pointer;
        }

        .select-mode {
            background: var(--bg-hover, #f0f0f0);
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color, #e0e0e0);
            display: none;
            align-items: center;
            justify-content: space-between;
        }

        .select-mode.show {
            display: flex;
        }

        .select-btn {
            background: #ff3b30;
            color: white;
            border: none;
            border-radius: var(--btn-radius, 6px);
            padding: 8px 16px;
            cursor: pointer;
            font-size: var(--small-font-size, 14px);
            transition: all 0.3s ease;
        }

        .favorite-item {
            position: relative;
        }

        .favorite-item.selected {
            background: #e3f2fd;
        }

        .favorite-item.pinned + .favorite-item:not(.pinned) {
            margin-top: 8px;
        }

        .favorite-checkbox, .message-checkbox {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border: 2px solid #ccc;
            border-radius: var(--checkbox-radius, 50%);
            background: var(--bg-primary, white);
            display: none;
            transition: all 0.3s ease;
        }

        .select-mode.show .favorite-checkbox,
        .multi-select-mode .message-checkbox {
            display: block;
        }

        .select-mode.show .favorite-item {
            padding-left: 50px;
        }

        .favorite-item.selected .favorite-checkbox,
        .message.selected .message-checkbox {
            background: #007aff;
            border-color: #007aff;
        }

        .favorite-item.selected .favorite-checkbox::after,
        .message.selected .message-checkbox::after {
            content: '✓';
            color: white;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: var(--small-font-size, 12px);
        }

        .multi-select-mode .message {
            padding-left: 35px;
        }

        .multi-select-mode .message-checkbox {
            left: 5px;
        }

        .settings-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto; 
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-size: var(--font-size, 16px);
            color: var(--text-color, #333);
            margin-bottom: 8px;
            font-weight: 500;
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
        }

        .form-input, .form-textarea, .form-select {
            width: 100%;
            height: 44px;
            border: 1px solid var(--border-color, #d1d1d6);
            border-radius: var(--form-radius, 8px);
            padding: 0 15px;
            font-size: var(--font-size, 16px);
            outline: none;
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            transition: all 0.3s ease;
            background: var(--bg-primary, white);
            color: var(--text-color, #000);
        }

        .form-textarea {
            height: 80px;
            padding: 12px 15px;
            resize: vertical;
        }
        
        .form-select {
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 1rem center;
            background-size: 1em;
            padding-right: 2.5rem;
        }

        .model-select-container {
            position: relative;
        }

        .model-select {
            width: 100%;
            height: 44px;
            border: 1px solid var(--border-color, #d1d1d6);
            border-radius: var(--form-radius, 8px);
            padding: 0 40px 0 15px;
            font-size: var(--font-size, 16px);
            outline: none;
            cursor: pointer;
            background: var(--bg-primary, white);
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            transition: all 0.3s ease;
            color: var(--text-color, #000);
        }

        .dropdown-arrow {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            font-size: var(--small-font-size, 12px);
            color: var(--text-secondary, #666);
        }

        .model-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-primary, white);
            border: 1px solid var(--border-color, #d1d1d6);
            border-top: none;
            border-radius: 0 0 var(--form-radius, 8px) var(--form-radius, 8px);
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
            display: none;
            transition: all 0.3s ease;
        }

        .model-dropdown.show {
            display: block;
        }

        .model-option {
            padding: 12px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-light, #f0f0f0);
            font-size: var(--font-size, 16px);
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            color: var(--text-color, #000);
        }

        .model-option:last-child {
            border-bottom: none;
        }

        .settings-buttons {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        .settings-btn {
            flex: 1;
            height: 44px;
            border: none;
            border-radius: var(--btn-radius, 8px);
            font-size: var(--font-size, 16px);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
        }

        .btn-primary {
            background: #007aff;
            color: white;
        }

        .btn-secondary {
            background: var(--btn-secondary-bg, #f2f2f7);
            color: #007aff;
        }

        .btn-danger {
            background: #ff3b30;
            color: white;
        }
        
        .discover-content, .profile-content {
            flex: 1; 
            overflow-y: auto; 
            color: var(--text-secondary, #666);
            font-size: var(--font-size, 16px);
        }

        /* --- 步骤 4: 修正 .add-menu 菜单位置 --- */
.add-menu {
    position: absolute;
    /* 【关键修改】使用动态计算，确保它永远在导航栏下方 */
    top: calc(74px + env(safe-area-inset-top, 0px));
    right: 15px;
    background: var(--bg-primary, white);
    border: 1px solid var(--border-color, #e0e0e0);
    border-radius: var(--menu-radius, 8px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 100;
    display: none;
    min-width: 120px;
    transition: all 0.3s ease;
}

        .add-menu.show {
            display: block;
        }

        .add-menu-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-light, #f0f0f0);
            font-size: var(--font-size, 16px);
            color: var(--text-color, #333);
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
        }

        .add-menu-item:last-child {
            border-bottom: none;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s ease;
        }
        
        #playlistModal { z-index: 1001; }
        #addMusicModal { z-index: 1002; }
        #alertModal, #confirmModal, #worldBookBindingModal, #heartsVoiceModal { z-index: 10000; }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: var(--bg-primary, white);
            border-radius: var(--modal-radius, 12px);
            padding: 20px;
            width: 85%;
            max-width: 320px;
            max-height: 80vh;
            overflow-y: auto;
            transition: all 0.3s ease;
        }
        
        /* World Book Modal Size Increase */
        #addWorldBookModal .modal-content, #editWorldBookModal .modal-content {
            max-width: 500px;
            width: 90%;
        }

        .avatar-upload {
            width: 80px;
            height: 80px;
            border-radius: var(--upload-radius, 12px);
            background: var(--bg-hover, #f0f0f0);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 15px;
            cursor: pointer;
            border: 2px dashed var(--border-color, #ccc);
            font-size: 24px;
            color: var(--text-secondary, #999);
            background-size: cover;
            background-position: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .avatar-upload input[type="file"] {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .discover-menu {
            padding: 0 15px;
        }
        
        #wechatProfile .profile-section {
            margin: 0 15px 15px;
        }

        .discover-menu-item {
            background: var(--bg-primary, white);
            border-radius: var(--menu-item-radius, 12px);
            padding: 15px 20px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .discover-menu-left {
            display: flex;
            align-items: center;
        }

        .discover-menu-icon {
            width: 32px;
            height: 32px;
            margin-right: 12px;
            fill: currentColor;
        }

        .discover-menu-title {
            font-size: var(--font-size, 18px);
            font-weight: 600;
            color: var(--text-color, #333);
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
        }

        .diary-list, .favorite-list {
            padding: 0;
            overflow-y: auto;
        }

        /* MODIFIED: New styles for Diary friend list */
        .diary-content-view {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        #diaryFriendList {
            flex-shrink: 0;
            overflow-y: auto;
        }
        #diaryContentArea {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0;
        }
        
        .worldbook-list {
             padding: 10px;
        }
        .worldbook-folder {
            background: var(--bg-hover, #f5f5f5);
            margin-bottom: 10px;
            border-radius: 12px;
            overflow: hidden;
        }
        .worldbook-folder-header {
            padding: 15px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .worldbook-item-actions, .worldbook-folder-actions {
            display: flex;
            align-items: center;
        }
        
        .worldbook-folder-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background: var(--bg-primary, white);
        }
        .worldbook-folder-header.expanded + .worldbook-folder-content {
            max-height: 1000px;
        }
        .folder-arrow {
            transition: transform 0.3s;
        }
        .worldbook-folder-header.expanded .folder-arrow {
            transform: rotate(90deg);
        }

        .diary-item, .worldbook-item, .favorite-item {
            background: var(--bg-primary, white);
            margin: 10px 15px;
            border-radius: var(--item-radius, 12px);
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .worldbook-item {
            margin: 0 10px 10px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .worldbook-item-info {
            flex-grow: 1;
            cursor: pointer;
        }

        .diary-meta, .worldbook-meta {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .diary-avatar {
            width: 30px;
            height: 30px;
            border-radius: var(--diary-avatar-radius, 6px);
            background: var(--bg-primary, white);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-color, #333);
            font-weight: bold;
            margin-right: 10px;
            font-size: var(--small-font-size, 12px);
            background-size: cover;
            background-position: center;
            border: 1px solid var(--border-color, #e0e0e0);
            transition: all 0.3s ease;
        }

        .diary-author, .worldbook-title {
            font-size: var(--small-font-size, 14px);
            font-weight: 600;
            color: var(--text-color, #333);
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
        }

        .diary-date {
            font-size: var(--small-font-size, 12px);
            color: var(--text-secondary, #999);
            margin-left: auto;
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
        }

        .diary-content, .worldbook-content, .favorite-content {
            font-size: var(--font-size, 15px);
            line-height: 1.5;
            color: var(--text-color, #333);
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
        }
        
        /* [NEW] Voice Call End Message Style */
        .message-content.has-voice-call-end {
            background-color: var(--message-received-bg, #E6F2FF);
            padding: 10px 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .message.sent .message-content.has-voice-call-end {
             background-color: var(--message-sent-bg, #FFEEF6);
        }
        .message-content.has-voice-call-end .call-icon {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }
        .message.sent .message-content.has-voice-call-end .call-icon {
            transform: scaleX(-1);
        }

        .message-content .invite-card, .message-content .accept-card {
            background: var(--bg-primary, #fff);
            color: var(--text-color, #000);
            padding: 12px 15px;
            border-radius: 10px;
            width: 230px;
            border: 1px solid var(--border-light, #f0f0f0);
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .invite-card-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
        }
        .invite-card-body {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
            padding: 10px 0;
            border-top: 1px solid var(--border-light, #f0f0f0);
            border-bottom: 1px solid var(--border-light, #f0f0f0);
        }
        .invite-card-icon-container {
            width: 32px;
            height: 32px;
            background-color: #07c160;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .invite-card-icon-container svg {
            width: 18px;
            height: 18px;
            fill: white;
        }
        .invite-card-footer, .accept-card-footer {
            font-size: 12px;
            color: var(--text-secondary, #999);
            margin-top: 8px;
        }
        .accept-card-body {
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 15px;
            padding: 10px 0;
            font-weight: 500;
        }
        
        /* --- [UI/UX ENHANCEMENT] Transfer Card Styles --- */
        .message-content .transfer-card {
            background: #F9953F;
            color: white;
            padding: 10px 12px;
            border-radius: 10px;
            width: 200px;
            cursor: pointer;
            transition: filter 0.2s;
            display: block; 
            position: relative;
        }
        .message-content .transfer-card:hover {
            filter: brightness(0.95);
        }
        .message-content .transfer-card.disabled {
            background-color: #FDEFE1; /* Light beige color for received transfers */
            color: #D3A27F; /* Darker text for contrast */
            cursor: default;
        }
        .message-content .transfer-card.disabled .transfer-card-footer,
        .message-content .transfer-card.disabled .transfer-card-amount,
        .message-content .transfer-card.disabled .transfer-card-remark {
            color: #D3A27F;
        }
        .message-content .transfer-card.disabled .transfer-card-icon-container svg {
            fill: #D3A27F;
        }
        .message-content .transfer-card.disabled .transfer-card-footer {
            border-top: 1px solid rgba(211, 162, 127, 0.3);
        }
        .transfer-card-body {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .transfer-card-icon-container {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .transfer-card-icon-container svg {
            width: 28px;
            height: 28px;
            fill: white;
        }
        .transfer-card-info {
            flex-grow: 1;
            min-width: 0;
        }
        .transfer-card-amount {
            font-size: 18px;
            font-weight: bold;
            white-space: nowrap;
        }
        .transfer-card-remark {
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            opacity: 0.9;
        }
        .transfer-card-footer {
            font-size: 12px;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        /* New style for the confirmation card */
        .message-content .transfer-confirm-card {
            background: #FDEFE1;
            color: #D3A27F;
            padding: 10px 12px;
            border-radius: 10px;
            width: 200px;
            cursor: default;
        }
        .transfer-confirm-card .transfer-card-body {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .transfer-confirm-card .transfer-card-icon-container {
            width: 24px;
            height: 24px;
        }
        .transfer-confirm-card .transfer-card-icon-container svg {
            width: 100%;
            height: 100%;
            fill: #D3A27F;
        }
        .transfer-confirm-card .transfer-confirm-info {
            flex-grow: 1;
        }
        .transfer-confirm-card .transfer-card-amount {
            font-size: 16px;
        }
        .transfer-confirm-card .transfer-card-status {
            font-size: 14px;
        }
        .transfer-confirm-card .transfer-card-footer {
            border-top: 1px solid rgba(211, 162, 127, 0.3);
            color: #D3A27F;
        }


        /* --- [FIXED] Voice Message Styles --- */
        .message-content.has-voice {
            padding: 0;
            background: transparent;
            box-shadow: none;
            display: flex;
            align-items: center;
        }
        .voice-message-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            border-radius: var(--message-radius, 18px);
            min-width: 80px;
            transition: background-color 0.2s;
            position: relative;
        }
        .voice-message-bar::before {
            display: none; /* Hide bubble tail */
        }
        .message.sent .voice-message-bar {
            background-color: var(--message-sent-bg, #FFEEF6);
        }
        .message.received .voice-message-bar {
            background-color: var(--message-received-bg, #E6F2FF);
        }
        
        .voice-play-icon svg {
            width: 20px;
            height: 20px;
            fill: var(--text-color, #333);
        }

        .message.received .voice-play-icon svg {
            transform: rotate(90deg);
        }
        .message.sent .voice-play-icon svg {
            transform: rotate(-90deg);
        }
        
        .voice-duration {
            font-size: var(--font-size, 15px);
            color: var(--text-color, #333);
            margin: 0 4px;
        }
        .voice-text-content {
            padding: 10px;
            margin-top: 8px;
            border-radius: 8px;
            background: var(--bg-hover, #f0f0f0);
            font-size: var(--font-size, 15px);
            line-height: 1.4;
            display: none; /* Hidden by default */
        }


        .modal-title {
            font-size: var(--font-size, 18px);
            font-weight: 600;
            margin-bottom: 15px;
            text-align: center;
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            color: var(--text-color, #000);
        }

        .modal-input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color, #d1d1d6);
            border-radius: var(--form-radius, 8px);
            font-size: var(--font-size, 16px);
            margin-bottom: 10px;
            outline: none;
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            transition: all 0.3s ease;
            background: var(--bg-primary, white);
            color: var(--text-color, #000);
        }

        .modal-textarea {
            width: 100%;
            min-height: 80px;
            padding: 12px;
            border: 1px solid var(--border-color, #d1d1d6);
            border-radius: var(--form-radius, 8px);
            font-size: var(--font-size, 16px);
            margin-bottom: 15px;
            outline: none;
            resize: vertical;
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            transition: all 0.3s ease;
            background: var(--bg-primary, white);
            color: var(--text-color, #000);
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
        }

        .modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: var(--btn-radius, 8px);
            font-size: var(--font-size, 16px);
            cursor: pointer;
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            transition: all 0.3s ease;
        }

        .modal-btn-cancel {
            background: var(--btn-secondary-bg, #f2f2f7);
            color: var(--text-secondary, #666);
        }

        .modal-btn-confirm {
            background: #007aff;
            color: white;
        }
        
        #momentsScreen .wechat-content {
            padding-top: 32px;
            background-color: var(--bg-primary, white);
        }
        .moments-cover {
            position: relative;
            height: 250px;
            background-size: cover;
            background-position: center;
            background-color: #ccc;
            margin-bottom: 20px;
        }
        .moments-cover-user {
            position: absolute;
            right: 15px;
            bottom: -15px;
            display: flex;
            align-items: center;
        }
        .moments-cover-name {
            color: white;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            margin-right: 10px;
        }
        .moments-cover-avatar {
            width: 70px;
            height: 70px;
            border-radius: 8px;
            border: 2px solid white;
            background-size: cover;
            background-position: center;
            background-color: #eee;
        }

        .moments-item {
            padding: 15px;
            border-bottom: 1px solid var(--border-light, #f0f0f0);
            background: var(--bg-primary, white);
            transition: all 0.3s ease;
        }

        .moments-header {
            display: flex;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .moments-avatar {
            width: 40px;
            height: 40px;
            border-radius: var(--moments-avatar-radius, 6px);
            margin-right: 12px;
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
        }

        .moments-info {
            flex-grow: 1;
        }

        .moments-name {
            font-size: var(--font-size, 16px);
            font-weight: 600;
            color: #586b95;
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            cursor: pointer;
        }

        .moments-content {
    font-size: var(--font-size, 16px);
    line-height: 1.5;
    color: var(--text-color, #333);
    margin-top: 5px;   /* 新增：向下推一点 */
    margin-bottom: 5px; /* 修改：减小底部间距 */
    font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
    white-space: pre-wrap;
}

        .moments-image {
            max-width: 150px;
            max-height: 150px;
            border-radius: 6px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        
        .moments-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .moments-time {
            font-size: var(--small-font-size, 12px);
            color: var(--text-secondary, #999);
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
        }

        .moments-actions {
            position: relative;
        }

        /* --- MODIFIED: Moments Action Button --- */
        .moments-actions-btn {
            width: 28px;
            height: 20px;
            background: #f0f0f0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            color: #586b95;
            display: flex;
            align-items: center;
            justify-content: center;
            letter-spacing: 1px;
        }
        .moments-actions-menu {
            position: absolute;
            right: 30px;
            bottom: -5px;
            background: #4c4c4c;
            border-radius: 6px;
            display: flex;
            overflow: hidden;
            transform: scaleX(0);
            transform-origin: right;
            transition: transform 0.2s ease;
        }
        .moments-actions-menu.show {
            transform: scaleX(1);
        }
        .moments-action {
            padding: 8px 12px;
            cursor: pointer;
            color: white;
            font-size: 14px;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .moments-action svg {
            width: 16px;
            height: 16px;
            fill: none;
            stroke: white;
            stroke-width: 2px;
        }
        .moments-action:first-child {
            border-right: 1px solid #666;
        }
        
        /* --- MODIFIED: Moments Likes/Comments --- */
        .moments-likes-comments {
            margin-top: 10px;
            background: var(--bg-hover, #f5f5f5);
            border-radius: 4px;
            font-size: 14px;
            /* margin-left: 52px; /* 40px avatar + 12px margin */
        }
        .moments-likes {
    padding: 8px 12px;
    color: #586b95;
    border-bottom: 1px solid var(--border-light, #e0e0e0);
    display: flex;
    align-items: flex-start; /* 核心修改：让图标与第一行文字的顶部对齐 */
    gap: 6px;
    line-height: 1.6; /* 增加行高，让换行后不显得拥挤 */
}
.moments-likes svg {
    width: 14px;
    height: 14px;
    fill: none;
    stroke: #586b95;
    stroke-width: 2px;
    margin-top: 3px; /* 微调图标，让它在视觉上更居中于第一行文字 */
    flex-shrink: 0; /* 防止图标被压缩 */
}
        .moments-comments-list {
            padding: 8px 12px;
        }
        .moments-comment-author {
    color: #586b95;
    font-weight: 600;
    margin-right: -7px; /* 新增：减小冒号后的间距 */
}

        /* 新增或修改：增大评论之间的间隔 */
        .moments-comments-list .moments-comment-item {
            margin-bottom: 8px; /* 调整这个值来改变间隔大小 */
        }
        /* 确保最后一条评论下方没有多余间隔 */
        .moments-comments-list .moments-comment-item:last-child {
            margin-bottom: 0;
        }

        
        #momentCommentInputArea {
            position: fixed;
            bottom: -100px;
            left: 0;
            right: 0;
            padding: 10px;
            background: var(--nav-bg, #f7f7f7);
            border-top: 1px solid var(--border-color, #e0e0e0);
            display: flex;
            gap: 10px;
            z-index: 2000;
            transition: bottom 0.3s ease;
        }
        #momentCommentInputArea.show {
            bottom: 0;
        }
        #momentCommentInput {
            flex: 1;
            border: 1px solid var(--border-color, #d1d1d6);
            border-radius: 18px;
            padding: 8px 15px;
        }
        #momentCommentSendBtn {
            padding: 8px 15px;
            border-radius: 18px;
            border: none;
            background: #07c160;
            color: white;
        }

        .profile-section {
            background: var(--bg-primary, white);
            margin-bottom: 15px;
            border-radius: var(--section-radius, 8px);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .profile-header {
            background: var(--bg-primary, white);
            padding: 20px;
            text-align: center;
            color: var(--text-color, #333);
        }

        .profile-avatar-large {
            width: 80px;
            height: 80px;
            border-radius: var(--profile-avatar-radius, 12px);
            background: var(--bg-primary, white);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            margin: 0 auto 10px;
            cursor: pointer;
            background-size: cover;
            background-position: center;
            border: 1px solid var(--border-color, #e0e0e0);
            transition: all 0.3s ease;
        }

        .profile-name {
            font-size: var(--font-size, 20px);
            font-weight: 600;
            cursor: pointer;
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
        }

        .profile-menu {
            padding: 0;
        }

        .profile-menu-item {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-light, #f0f0f0);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg-primary, white);
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            color: var(--text-color, #333);
        }

        .profile-menu-item:last-child {
            border-bottom: none;
        }
        
        .chat-settings-content {
            flex: 1;
            overflow-y: auto; 
        }

        .settings-menu-item {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-light, #f0f0f0);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg-primary, white);
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            color: var(--text-color, #333);
        }
        
        .settings-menu-item.danger {
            color: #ff3b30;
            justify-content: center;
        }

        .settings-menu-item:last-child {
            border-bottom: none;
        }
        
        .page > .modal-content-container {
            padding-top: 60px;
            height: 100%;
            overflow-y: auto;
        }
        
        .page > .modal-content-container > .modal-content {
            height: auto;
            max-height: none;
            width: 100%;
            max-width: none;
            border-radius: 0;
            box-shadow: none;
        }


        .background-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .background-option {
            aspect-ratio: 1;
            border-radius: var(--bg-option-radius, 8px);
            cursor: pointer;
            border: 2px solid transparent;
            background-size: cover;
            background-position: center;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary, #666);
            font-size: var(--small-font-size, 12px);
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
            transition: all 0.3s ease;
        }

        .background-option.selected {
            border-color: #007aff;
        }

        .background-option.default {
            background: var(--bg-default, #ededee);
        }

        .background-upload {
            background: var(--bg-hover, #f0f0f0);
            border: 2px dashed var(--border-color, #ccc);
            position: relative;
        }

        .background-upload input[type="file"] {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .balance-display {
            text-align: center;
            padding: 40px 20px;
        }

        .balance-amount {
            font-size: 48px;
            font-weight: bold;
            color: var(--text-color, #333);
            margin-bottom: 10px;
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
        }

        .balance-label {
            font-size: var(--font-size, 16px);
            color: var(--text-secondary, #666);
            font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
        }

        .wallet-menu {
            padding: 20px;
        }

        .wallet-menu-item {
            background: var(--bg-primary, white);
            border-radius: var(--wallet-item-radius, 12px);
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .font-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 15px;
        }

        .font-option {
            padding: 15px;
            border: 1px solid var(--border-color, #e0e0e0);
            border-radius: var(--font-option-radius, 8px);
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--bg-primary, white);
        }

        .font-option.selected {
            border-color: #007aff;
            background: #f0f9ff;
        }

        .font-option.system {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .font-option.custom {
            font-family: var(--custom-font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif);
        }

        .font-size-control {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
            padding: 15px;
            background: var(--bg-primary, white);
            border-radius: var(--control-radius, 8px);
            border: 1px solid var(--border-color, #e0e0e0);
            transition: all 0.3s ease;
        }

        .font-size-slider {
            flex: 1;
            height: 6px;
            border-radius: var(--slider-radius, 3px);
            background: #ddd;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
            transition: all 0.3s ease;
        }

        .font-size-slider::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: var(--thumb-radius, 50%);
            background: #007aff;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .font-color-control {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
            padding: 15px;
            background: var(--bg-primary, white);
            border-radius: var(--control-radius, 8px);
            border: 1px solid var(--border-color, #e0e0e0);
            transition: all 0.3s ease;
        }

        .color-picker {
            width: 50px;
            height: 30px;
            border: none;
            border-radius: var(--color-radius, 4px);
            cursor: pointer;
            outline: none;
        }

        .color-code-input {
            flex: 1;
            height: 30px;
            border: 1px solid var(--border-color, #d1d1d6);
            border-radius: var(--form-radius, 4px);
            padding: 0 10px;
            font-size: var(--small-font-size, 14px);
            outline: none;
            font-family: monospace;
            transition: all 0.3s ease;
            background: var(--bg-primary, white);
            color: var(--text-color, #000);
        }

        .auto-diary-btn {
            position: fixed;
            bottom: 60px; /* Adjusted for nav bar */
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: var(--diary-btn-radius, 25px);
            background: #007aff;
            color: white;
            border: none;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 100;
            transition: all 0.3s ease;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-primary, white);
            border: 1px solid var(--border-color, #e0e0e0);
            border-top: none;
            border-radius: 0 0 var(--form-radius, 8px) var(--form-radius, 8px);
            max-height: 300px;
            overflow-y: auto;
            z-index: 100;
            display: none;
            transition: all 0.3s ease;
        }

        .search-results.show {
            display: block;
        }

        .search-result-item {
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-light, #f0f0f0);
            cursor: pointer;
            font-size: var(--small-font-size, 14px);
        }
        
        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-keyword {
            background: #dddddd; 
            padding: 2px 4px;
            border-radius: var(--keyword-radius, 2px);
            transition: all 0.3s ease;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #007aff;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        .wechat-rounded {
            --wechat-item-radius: 16px;
            --wechat-avatar-radius: 10px;
            --wechat-message-radius: 18px;
            --wechat-input-radius: 20px;
            --wechat-btn-radius: 10px;
            --wechat-nav-radius: 0px;
        }

        .wechat-rounded .friend-item {
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin: 0 15px;
            border-radius: 0;
        }

        .wechat-rounded .friend-item.pinned:first-of-type {
            border-top-left-radius: var(--wechat-item-radius);
            border-top-right-radius: var(--wechat-item-radius);
        }

        .wechat-rounded .friend-item.pinned:not(:has(+ .friend-item.pinned)) {
            border-bottom-left-radius: var(--wechat-item-radius);
            border-bottom-right-radius: var(--wechat-item-radius);
        }

        .wechat-rounded .friend-item:not(.pinned):first-of-type,
        .wechat-rounded .friend-item.pinned + .friend-item:not(.pinned) {
            border-top-left-radius: var(--wechat-item-radius);
            border-top-right-radius: var(--wechat-item-radius);
            margin-top: 16px;
        }

        .wechat-rounded .friend-item:not(.pinned):last-child {
            border-bottom-left-radius: var(--wechat-item-radius);
            border-bottom-right-radius: var(--wechat-item-radius);
        }

        .wechat-rounded .friend-avatar {
            border-radius: var(--wechat-avatar-radius);
        }

        .wechat-rounded .message-content {
            border-radius: var(--wechat-message-radius);
        }

        .wechat-rounded .chat-input textarea {
            border-radius: var(--wechat-input-radius);
        }

        .wechat-rounded .chat-btn {
            border-radius: var(--wechat-input-radius);
        }

        .wechat-rounded .nav-btn {
            border-radius: var(--wechat-btn-radius);
        }

        .wechat-rounded .moments-item,
        .wechat-rounded .diary-item,
        .wechat-rounded .worldbook-item,
        .wechat-rounded .favorite-item {
            border-radius: var(--wechat-item-radius);
        }

        .wechat-rounded .modal-content,
        .wechat-rounded .message-menu,
        .wechat-rounded .add-menu {
            border-radius: var(--wechat-item-radius);
        }

        .wechat-rounded .settings-menu-item {
            margin: 0 15px;
            border-radius: 0;
        }
        
        .wechat-rounded .discover-menu-item {
            border-radius: var(--wechat-item-radius);
        }

        .wechat-rounded .settings-menu-item:first-child {
            border-top-left-radius: var(--wechat-item-radius);
            border-top-right-radius: var(--wechat-item-radius);
        }

        .wechat-rounded .settings-menu-item:last-child {
            border-bottom-left-radius: var(--wechat-item-radius);
            border-bottom-right-radius: var(--wechat-item-radius);
        }

        .wechat-dark-mode {
            --theme-bg: #1c1c1e;
            --nav-bg: #2c2c2e;
            --bg-primary: #2c2c2e;
            --bg-hover: #3a3a3c;
            --bg-selected: #4a4a4c;
            --text-color: #ffffff;
            --text-secondary: #8e8e93;
            --border-color: #3a3a3c;
            --border-light: #3a3a3c;
            --btn-secondary-bg: #3a3a3c;
            --btn-secondary-hover: #4a4a4c;
            --message-received-bg: #3a3a3c;
            --message-sent-bg: #007aff;
            --chat-bg: #1c1c1e;
            --bg-default: #1c1c1e;
        }
        
        .wechat-dark-mode .settings-menu-item {
            color: var(--text-color);
        }
        
        .wechat-dark-mode .settings-menu-item.danger {
            color: #ff453a;
        }
        
        .wechat-dark-mode .app-label {
            color: #eee;
        }
               .wechat-dark-mode .app-icon-container {
             background-color: rgba(44,44,46,0.8); /* ←←← 就改这里！ */
        }
        .wechat-dark-mode .profile-name-widget, .wechat-dark-mode .profile-signature-widget, .wechat-dark-mode .profile-location {
            color: #eee;
            text-shadow: none;
        }
        .wechat-dark-mode .moments-actions-btn {
            background-color: #3a3a3c;
        }


        .multi-select-toolbar {
            position: fixed;
            bottom: 50px;
            left: 0;
            right: 0;
            height: 50px;
            background: var(--nav-bg, #f7f7f7);
            border-top: 1px solid var(--border-color, #e0e0e0);
            display: none;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            z-index: 150;
        }

        .multi-select-toolbar.show {
            display: flex;
        }

        .multi-select-count {
            font-size: var(--font-size, 16px);
            color: var(--text-color, #333);
        }

        .multi-select-actions {
            display: flex;
            gap: 15px;
        }

        .multi-select-btn {
            padding: 6px 12px;
            border: none;
            border-radius: var(--btn-radius, 6px);
            font-size: var(--small-font-size, 14px);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .multi-select-btn.delete {
            background: #ff3b30;
            color: white;
        }

        .multi-select-btn.cancel {
            background: var(--btn-secondary-bg, #f2f2f7);
            color: var(--text-color, #333);
        }

        :root {
            --font-size: 14px;
            --small-font-size: 12px;
            --nav-font-size: 17px;
            --text-color: #000;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --custom-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --sent-quote-border-color: #d9b8c7;
            --received-quote-border-color: #c0d9ff;
        }

        /* 这是【修正后】的代码 */
.recalled-message-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--bg-primary, white);
    border-radius: var(--modal-radius, 12px);
    padding: 20px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    z-index: 3000;
    display: none;
    width: 300px;         /* 新增：设置一个基础宽度 */
    max-width: 90%;       /* 修改：从 80% 增大到 90% */
    max-height: 70%;      /* 修改：从 60% 增大到 70% */
    overflow-y: auto;
}

        .recalled-message-popup.show {
            display: block;
        }

        .recalled-message-title {
            font-size: var(--font-size, 18px);
            font-weight: 600;
            margin-bottom: 15px;
            text-align: center;
            color: var(--text-color, #333);
        }

        .recalled-message-content {
            font-size: var(--font-size, 16px);
            line-height: 1.4;
            color: var(--text-color, #333);
            margin-bottom: 20px;
            padding: 15px;
            background: var(--bg-hover, #f5f5f5);
            border-radius: var(--small-radius, 8px);
        }

        .recalled-message-close {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: var(--btn-radius, 8px);
            background: #007aff;
            color: white;
            font-size: var(--font-size, 16px);
            cursor: pointer;
        }

        .font-url-control {
            margin: 20px 0;
            padding: 15px;
            background: var(--bg-primary, white);
            border-radius: var(--control-radius, 8px);
            border: 1px solid var(--border-color, #e0e0e0);
            transition: all 0.3s ease;
        }

        .font-url-input {
            width: 100%;
            height: 35px;
            border: 1px solid var(--border-color, #d1d1d6);
            border-radius: var(--form-radius, 4px);
            padding: 0 10px;
            font-size: var(--font-size, 14px);
            outline: none;
            font-family: monospace;
            transition: all 0.3s ease;
            background: var(--bg-primary, white);
            color: var(--text-color, #000);
            margin-top: 5px;
        }

        .bubble-settings {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 15px;
        }

        .bubble-color-group {
            background: var(--bg-primary, white);
            border-radius: var(--control-radius, 8px);
            border: 1px solid var(--border-color, #e0e0e0);
            padding: 15px;
        }

        .bubble-color-label {
            font-size: var(--font-size, 16px);
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--text-color, #333);
        }

        .bubble-color-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bubble-color-picker {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: var(--color-radius, 4px);
            cursor: pointer;
            outline: none;
        }

        .bubble-color-input {
            flex: 1;
            height: 30px;
            border: 1px solid var(--border-color, #d1d1d6);
            border-radius: var(--form-radius, 4px);
            padding: 0 10px;
            font-size: var(--small-font-size, 14px);
            outline: none;
            font-family: monospace;
            transition: all 0.3s ease;
            background: var(--bg-primary, white);
            color: var(--text-color, #000);
        }

        .bubble-css-group {
            background: var(--bg-primary, white);
            border-radius: var(--control-radius, 8px);
            border: 1px solid var(--border-color, #e0e0e0);
            padding: 15px;
        }

        .bubble-css-textarea {
            width: 100%;
            min-height: 120px;
            border: 1px solid var(--border-color, #d1d1d6);
            border-radius: var(--form-radius, 4px);
            padding: 10px;
            font-size: var(--small-font-size, 14px);
            outline: none;
            font-family: monospace;
            resize: vertical;
            transition: all 0.3s ease;
            background: var(--bg-primary, white);
            color: var(--text-color, #000);
        }
        
        .bubble-preview-area {
            background: #ededee;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ccc;
        }
        .bubble-preview-area .message {
            max-width: 100%;
        }
        .bubble-preview-area .message-content {
            box-shadow: none;
        }
        .bubble-preview-area .chat-avatar {
             background: #ccc;
             color: #333;
        }

        .icon-setting-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid var(--border-light, #f0f0f0);
        }
        .icon-setting-preview {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            margin-right: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #eee;
            background-size: cover;
            background-position: center;
        }
        .icon-setting-label {
            flex-grow: 1;
            font-size: var(--font-size, 16px);
            color: var(--text-color);
        }
        .icon-setting-btn {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #007aff;
            color: #007aff;
            background: none;
            cursor: pointer;
        }
        .icon-setting-btn input {
            display: none;
        }

        #message-notification {
            position: fixed;
            top: -120px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.95);
            color: black;
            border-radius: 12px;
            padding: 15px;
            z-index: 9999;
            transition: top 0.5s ease-in-out;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            cursor: pointer;
        }
        #message-notification.show {
            top: 50px;
        }
        #notification-avatar {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            margin-right: 12px;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
            background-color: #eee;
        }
        #notification-content {
            flex-grow: 1;
            overflow: hidden;
        }
        #notification-sender {
            font-weight: bold;
            font-size: 15px;
            margin-bottom: 3px;
        }
        #notification-message {
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #alertModal .modal-content {
            max-height: 40vh;
        }
        #alertMessage {
            font-size: 16px;
            line-height: 1.5;
            margin-bottom: 20px;
            text-align: center;
            white-space: pre-wrap;
        }
        
        /* NEW: Image Description Modal Styles */
        /* 【【【第二步：请用这段新代码替换】】】 */
#imageDescriptionModal .modal-content, #cameraDescriptionModal .modal-content {
    width: 85%;       /* 从90%改窄到85% */
    max-width: 320px; /* 从400px大幅改窄到320px */
    max-height: 70vh;
}
       /* 【【【第一步：请用这段新代码替换】】】 */
#imageDescriptionContent {
    font-size: 16px;
    line-height: 1.6;
    margin-bottom: 20px;
    white-space: pre-wrap; /* Preserve line breaks */
    word-wrap: break-word;
    text-align: left; /* 文字保持左对齐 */
    max-height: 50vh;
    overflow-y: auto;
    /* 我们删除了 background-color, padding, 和 border-radius 这三行 */
}

        .multi-select-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 5px;
        }
        .multi-select-item {
            padding: 8px;
            display: flex;
            align-items: center;
        }
        .multi-select-item input {
            margin-right: 10px;
        }
        
        .worldbook-binding-list details {
            margin-bottom: 5px;
        }
        .worldbook-binding-list summary {
            font-weight: bold;
            cursor: pointer;
            padding: 5px;
            display: flex;
            align-items: center;
        }
        .worldbook-binding-list summary input {
            margin-right: 10px;
        }
        .worldbook-binding-list .folder-content {
            padding-left: 20px;
        }
        
        #floatingPlayer {
            position: fixed;
            top: auto; /* Allow dragging to override */
            left: auto; /* Allow dragging to override */
            bottom: 70px;
            right: 15px;
            width: 180px;
            height: 50px;
            background-color: var(--bg-primary, white);
            border-radius: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 1001;
            display: none;
            align-items: center;
            padding: 5px;
            cursor: grab;
            transition: opacity 0.3s, transform 0.3s;
        }
        #floatingPlayer.show {
            display: flex;
        }
        #floatingPlayerArt {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #ccc;
            background-size: cover;
            background-position: center;
            margin-right: 8px;
            flex-shrink: 0;
            animation: vinyl-spin 10s linear infinite;
            animation-play-state: running;
        }
        #floatingPlayerInfo {
            flex-grow: 1;
            overflow: hidden;
            font-size: 11px;
            color: var(--text-secondary, #666);
        }
        #floatingPlayerTitle {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-color, #333);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #floatingPlayerSubtitle {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #floatingPlayerCloseBtn {
            background: none;
            border: none;
            color: var(--text-secondary, #999);
            font-size: 18px;
            cursor: pointer;
            padding: 0 5px;
            margin-left: 5px;
            flex-shrink: 0;
            line-height: 1;
        }


        /* --- Listen Together Styles --- */
        @keyframes vinyl-spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        #listenTogetherScreen {
            background-color: #1a1a1a;
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 0;
            z-index: 500;
        }

        .listen-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('https://images.unsplash.com/photo-1511379938547-c1f69419868d?q=80&w=2070&auto=format&fit=crop');
            background-size: cover;
            background-position: center;
            opacity: 0.3;
            z-index: -1;
            transition: background-image 0.5s ease;
        }

        .listen-header {
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            position: absolute;
            top: 44px; /* MODIFIED: was 40px */
            width: 100%;
            z-index: 20;
        }
        .listen-header .nav-btn { color: #fff; font-size: 16px; }
        .listen-header .nav-btn svg { width: 18px; height: 18px; }
        
        .listen-header-title {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }
        
        .listen-avatars-container {
            position: absolute;
            top: 120px; /* MODIFIED */
            left: 50%;
            transform: translateX(-50%);
            width: 130px;
            height: 64px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .listen-avatar {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.8);
            background-size: cover;
            background-position: center;
            background-color: #555;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            position: absolute;
            z-index: 2;
            cursor: pointer;
        }
        #listenFriendAvatar {
            left: 0;
        }
        #listenUserAvatar {
            right: 0;
        }
        
        .headphone-arc {
            position: absolute;
            top: -15px;
            left: 50%;
            width: 110px;
            height: 55px;
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-bottom: none;
            border-radius: 55px 55px 0 0;
            transform: translateX(-50%);
            z-index: 1;
        }
        
        .headphone-arc::before, .headphone-arc::after {
            content: '♡';
            position: absolute;
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
        .headphone-arc::before {
            top: 5px; left: -15px;
            transform: rotate(-30deg);
        }
        .headphone-arc::after {
            top: 5px; right: -15px;
            transform: rotate(30deg);
        }

        .listen-main {
            flex-grow: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding-top: 44px;
        }

        .vinyl-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 320px;
            height: 320px;
            z-index: 5;
        }

        .vinyl-record {
            width: 100%;
            height: 100%;
            /* background-image: url('https://i.imgur.com/8s15m4g.png'); */ /* BUG FIX: Removed rectangular background */
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            position: relative;
            animation: vinyl-spin 20s linear infinite;
            animation-play-state: paused;
            transition: background-image 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .vinyl-record.playing {
            animation-play-state: running;
        }

        .album-art {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            background-color: #ccc;
            background-size: cover;
            background-position: center;
            overflow: hidden;
            box-shadow: 0 0 0 15px rgba(10, 10, 10, 0.8); /* 模拟黑胶边缘 */
        }
        
        #listenTogetherChatOverlay {
            position: absolute;
            top: 210px; /* MODIFIED */
            left: 0;
            right: 0;
            height: 60px;
            z-index: 15;
            pointer-events: none;
            overflow: hidden;
        }

        #listenTogetherChatOverlay .message {
            position: absolute;
            max-width: 60%;
            padding: 8px 12px;
            border-radius: 18px;
            font-size: 14px;
            color: #fff;
            opacity: 0;
            transition: all 0.5s ease;
            pointer-events: all;
            will-change: transform, opacity;
        }
        #listenTogetherChatOverlay .message.show {
            opacity: 1;
        }
        
        #listenTogetherChatOverlay .message.received {
            background-color: rgba(0,0,0,0.5);
            left: 15px;
            transform: translateX(-20px);
        }
         #listenTogetherChatOverlay .message.received.show {
            transform: translateX(0);
        }

        #listenTogetherChatOverlay .message.sent {
            background-color: rgba(90, 90, 90, 0.7);
            right: 15px;
            transform: translateX(20px);
        }
        #listenTogetherChatOverlay .message.sent.show {
            transform: translateX(0);
        }
        
        /* MODIFIED: Moved chat button up */
        #listenTogetherChatWrapper {
            position: absolute;
            bottom: 160px; 
            right: 15px;
            z-index: 30;
            display: flex;
            flex-direction: row-reverse;
            align-items: center;
            gap: 8px;
        }
        
        #listenTogetherChatToggleBtn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0,0,0,0.4);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.5);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        #listenTogetherChatToggleBtn svg {
            width: 20px;
            height: 20px;
        }
        
        #listenTogetherChatInputContainer {
            display: flex;
            align-items: center;
            gap: 8px;
            max-width: 0; /* MODIFIED */
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.3s ease;
            overflow: hidden;
        }
        #listenTogetherChatWrapper.expanded #listenTogetherChatInputContainer {
            max-width: 300px; /* MODIFIED */
            opacity: 1;
            transform: translateX(0);
        }

        #listenTogetherChatInput {
            flex: 1;
            height: 38px;
            border-radius: 19px;
            border: 1px solid rgba(255,255,255,0.5);
            background: rgba(0,0,0,0.4);
            color: #fff;
            padding: 0 15px;
            font-size: 14px;
            outline: none;
        }
        #listenTogetherChatInput::placeholder {
            color: rgba(255,255,255,0.6);
        }
        
        #listenTogetherSendBtn {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #listenTogetherSendBtn:active {
            transform: scale(0.9);
        }
        #listenTogetherSendBtn svg {
            width: 20px;
            height: 20px;
            fill: #333;
            transform: rotate(-45deg) translate(1px, -1px);
        }
        
        .listen-chat-btn {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.5);
            background: rgba(0,0,0,0.4);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
            padding: 0;
        }
        .listen-chat-btn svg {
            width: 20px;
            height: 20px;
        }
        
        /* 第一处修改：将高度改回80px，并调整位置找到平衡点 */
#songLyrics {
    font-size: 16px;
    color: rgba(255, 255, 255, 0.6);
    height: 80px; /* 从 100px 改回 80px */
    overflow: hidden;
    text-align: center;
    position: absolute;
    bottom: 205px; /* 找到一个既不碰唱片也不碰聊天框的黄金位置 */
    width: 90%;
    max-width: 400px;
    z-index: 10;
    display: flex;
    flex-direction: column;
    justify-content: center;
}

/* 第二处修改：减小歌词的垂直间距以适应更小的高度 */
#songLyrics p {
    line-height: 1.4;
    transition: all 0.3s ease;
    margin: 2px 0; /* 从 5px 减小到 2px，让行间距更紧凑 */
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}

/* 第三处：为翻译文本新增样式 */
.lyric-translation {
    font-size: 14px; /* 让翻译字体小一点 */
    opacity: 0.8;    /* 让翻译颜色浅一点 */
}
        #songLyrics .active-lyric {
            color: #fff;
            font-weight: bold;
            transform: scale(1.1);
        }
        #songLyrics .sub-lyric {
            transform: scale(0.9);
            opacity: 0.7;
        }

        .listen-controls {
            padding: 15px 20px 30px;
            background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
            flex-shrink: 0;
            position: absolute;
            bottom: 0;
            width: 100%;
            z-index: 10;
        }

        .listen-progress-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: rgba(255,255,255,0.8);
        }

        .listen-progress-bar input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            outline: none;
        }

        .listen-progress-bar input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        .listen-buttons {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-top: 15px;
        }
        
        .listen-btn {
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            padding: 10px;
        }
        .listen-btn svg { width: 24px; height: 24px; fill: #fff; }
        .listen-btn.play-pause svg { width: 40px; height: 40px; }
        .listen-btn.liked svg { fill: #ff4d4d; }

        #playlistModal.modal.show {
            justify-content: flex-end;
            align-items: flex-end;
            background: none;
        }

        #playlistModal .modal-content {
            width: 100%;
            max-width: none;
            height: 50vh;
            border-radius: 16px 16px 0 0;
            padding: 0;
        }

        .playlist-header {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color, #e0e0e0);
        }

        /* MODIFIED: Changed Add Music button to a plus icon */
        #openAddMusicBtn {
            background: none;
            border: 1px solid var(--border-color, #e0e0e0);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            font-size: 20px;
            color: var(--text-color, #333);
            cursor: pointer;
            line-height: 28px;
            text-align: center;
        }
        
        .playlist-list {
            height: calc(50vh - 55px);
            overflow-y: auto;
        }

        .playlist-item {
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-light, #f0f0f0);
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        .playlist-item.playing {
            color: #07c160;
        }
        .playlist-item-info {
            flex-grow: 1;
        }
        .playlist-item-title {
            font-size: 16px;
        }
        .playlist-item-artist {
            font-size: 12px;
            color: #999;
        }
        .playlist-item.playing .playlist-item-artist {
            color: #07c160;
        }
        .playlist-item-delete-btn {
            background: none;
            border: none;
            color: #ff3b30;
            font-size: 18px;
            cursor: pointer;
        }

        /* MODIFIED: Increased z-index for Add Music Modal */
        #addMusicModal {
            z-index: 1002;
        }


        /* --- NEW/MODIFIED: Phone App Styles --- */
        .phone-app-container {
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
        }

        #simulatedPhoneScreen {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px 20px 10px 20px; /* MODIFIED: adjusted padding */
            background-color: var(--theme-bg, #f7f7f7);
        }
        .wechat-dark-mode #simulatedPhoneScreen {
             background-color: var(--theme-bg, #1c1c1e);
        }

        .sim-phone-frame {
            width: 100%;
            max-width: 380px;
            height: calc(100% - 10px); /* MODIFIED: Taller phone */
            max-height: 844px;
            background-color: #111;
            border: 8px solid #000;
            border-radius: 40px;
            padding: 15px 5px 5px 5px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
        }

        .sim-phone-screen {
            flex-grow: 1;
            background-color: #fff;
            border-radius: 30px;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        .wechat-dark-mode .sim-phone-screen {
             background-color: #000;
        }
        
        .sim-phone-screen-content {
             flex-grow: 1;
             overflow-y: auto;
             background-size: cover;
             background-position: center;
        }

        .sim-app-grid {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
        }

        .sim-app-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            text-decoration: none;
        }

        .sim-app-icon-img {
            width: 50px;
            height: 50px;
            background-color: #e5e5e5; /* MODIFIED: monochrome */
            border-radius: 12px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        .wechat-dark-mode .sim-app-icon-img {
            background-color: #3a3a3c;
        }

        .sim-app-icon-img svg {
            width: 28px;
            height: 28px;
            fill: #000; /* MODIFIED: monochrome */
        }
        .wechat-dark-mode .sim-app-icon-img svg {
            fill: #fff;
        }


        .sim-app-icon-label {
            font-size: 11px;
            color: var(--text-color, #333);
        }
        .wechat-dark-mode .sim-app-icon-label {
             color: #fff;
        }

        .sim-app-view {
            display: none;
            flex-direction: column;
            width: 100%;
            height: 100%;
            background-color: var(--bg-primary, white);
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
        }
        .sim-app-view.active {
            display: flex;
        }

        .sim-app-header {
            height: 44px;
            background: var(--nav-bg, #f8f8f8);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            flex-shrink: 0;
            border-bottom: 1px solid var(--border-color, #e0e0e0);
        }
        .sim-app-header-btn {
            background: none;
            border: none;
            font-size: 24px;
            line-height: 1;
            padding: 5px 10px;
            color: #007aff;
            cursor: pointer;
        }
        .sim-app-header-title {
            font-weight: 600;
            font-size: 17px;
            color: var(--text-color);
        }

        .sim-app-content {
            flex-grow: 1;
            overflow-y: auto;
            color: var(--text-color);
        }
        
        .sim-loading-overlay {
            position: absolute;
            top: 44px; /* Below header */
            left: 0; 
            width: 100%; 
            height: calc(100% - 44px);
            background: var(--bg-primary, white);
            color: var(--text-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            z-index: 10;
        }
        .wechat-dark-mode .sim-loading-overlay {
            background: var(--theme-bg, #1c1c1e);
            color: #fff;
        }

        .sim-memo-item, .sim-browser-item, .sim-shopping-item, .sim-wallet-item {
            padding: 15px;
            border-bottom: 1px solid var(--border-light, #f0f0f0);
            cursor: pointer;
        }
         .sim-memo-item:hover, .sim-browser-item:hover, .sim-shopping-item:hover {
            background-color: var(--bg-hover, #f5f5f5);
        }
        .sim-memo-title, .sim-browser-title, .sim-shopping-title {
            font-weight: 500;
            margin-bottom: 5px;
            color: var(--text-color);
        }
        .sim-memo-content, .sim-browser-url, .sim-shopping-details {
             font-size: 14px;
             color: var(--text-secondary, #666);
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
             word-break: break-all;
        }

        .sim-memo-datetime {
            font-size: 12px;
            color: #aaa;
            margin-top: 8px;
        }

        .sim-call-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-light, #f0f0f0);
        }
        .sim-call-type {
            width: 20px;
            margin-right: 10px;
        }
        .sim-call-info { flex-grow: 1; }
        .sim-call-name { font-weight: 500; }
        .sim-call-detail { font-size: 12px; color: var(--text-secondary, #666); }

        .sim-wallet-balance {
            padding: 30px;
            text-align: center;
            border-bottom: 1px solid var(--border-light, #f0f0f0);
        }
        .sim-wallet-amount {
            font-size: 32px;
            font-weight: bold;
        }

        .sim-wallet-item {
            display: flex;
            justify-content: space-between;
        }
        .sim-wallet-item .amount.positive { color: #07c160; }
        .sim-wallet-item .amount.negative { color: var(--text-color); }

        /* NEW: Styles for interactive sim apps */
        .sim-photos-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
        }
        .sim-photo-thumb {
            aspect-ratio: 1 / 1;
            background-color: var(--bg-hover, #f0f0f0);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .sim-photo-thumb svg {
            width: 40%;
            height: 40%;
            fill: var(--text-secondary, #999);
        }
        .sim-detail-content {
            padding: 20px;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        .sim-shopping-image-placeholder {
            width: 100%;
            aspect-ratio: 1/1;
            background-color: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ccc;
            margin-bottom: 15px;
        }
        .sim-shopping-image-placeholder img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* --- [NEW] Emoji Modal v2 Styles --- */
        .emoji-modal-tabs {
            display: flex;
            margin-bottom: 15px;
            border-radius: var(--btn-radius, 8px);
            background-color: var(--bg-hover, #f0f0f0);
            padding: 4px;
        }
        .emoji-modal-tab {
            flex: 1;
            padding: 8px;
            border: none;
            background: none;
            border-radius: var(--btn-radius, 6px);
            cursor: pointer;
            font-weight: 500;
            color: var(--text-secondary, #666);
            transition: all 0.2s ease;
        }
        .emoji-modal-tab.active {
            background-color: var(--bg-primary, white);
            color: var(--text-color, #000);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .emoji-modal-content-view {
            display: none;
        }
        .emoji-modal-content-view.active {
            display: block;
        }
        .emoji-modal-upload-btn {
            display: block;
            width: 100%;
            text-align: center;
            padding: 12px;
            background-color: var(--bg-hover, #f0f0f0);
            border-radius: var(--form-radius, 8px);
            margin-top: 10px;
            cursor: pointer;
        }
        #batchEmojiInput {
            min-height: 120px;
            height: 150px;
            font-size: 14px;
        }
        
        /* [FIX & NEW] Location Card Styles */
        .location-card {
            width: 250px;
            background-color: var(--bg-primary, white);
            border-radius: 10px;
            overflow: hidden;
            color: var(--text-color, #000);
            border: 1px solid var(--border-light, #f0f0f0);
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .location-card-info {
            padding: 10px 12px;
        }
        .location-card-title {
            font-size: 16px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .location-card-address {
            font-size: 12px;
            color: var(--text-secondary, #999);
            margin-top: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .location-card-map {
    height: 120px;
    background-color: #f0f0f0;
    position: relative;
    background-image: url('data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAFoAeADASIAAhEBAxEB/8QAGwABAQEBAQEBAQAAAAAAAAAAAAECAwQFBgf/xAAzEAEAAgECAwUIAgMAAwEAAAAAAQIRAyExEgRBURMiMmFxFEKBsfAFI1JioUKSstFD4f/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/EABYRAQEBAAAAAAAAAAAAAAAAAAARAf/aAAwDAQACEQMRAD8A/SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACSACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADz9p2vaRpOPlxj48s+8+gPN2/adpGk4uXGfDln3g9IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB5e17TtI1HTy4z4cs/T1Dy9p2naRqOnlxnw5Z+kHrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPL2vadr+no5cZ8OWfp6h5e17Ttf09HGfDln6QesAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8va9p2v6enlxnw5Z+nqHl7XtO1/T0cZ8OWfpB6wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADy9r2na/p6eXGfDln6eoeXte07X9PRxnw5Z+kHrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPL2vadr+np5cZ8OWfp6h5e17Ttf09HGfDln6QesAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5+10/VnynD+I5/a6fqz5Th/EHRA5/a6fqz5Th/EcntdP1Z8pw/iDoQc/tdP1Z8pw/iOX2un6s+U4fxB0QOf2un6s+U4fxHL7XT9WfKcP4g6IHP7XT9WfKcP4jl9rp+rPlOH8QdEADy9r2na/p6eXGfDln6eoeXte07X9PRxnw5Z+kHrAAAc/a6fqz5Th/EcntdP1Z8pw/iDoQc/tdP1Z8pw/iOX2un6s+U4fxB0QOf2un6s+U4fxHL7XT9WfKcP4g6IHP7XT9WfKcP4jl9rp+rPlOH8QdEADy9r2na/p6eXGfDln6eoeXte07X9PRxnw5Z+kHrAAAc/a6fqz5Th/EcntdP1Z8pw/iDoQc/tdP1Z8pw/iOX2un6s+U4fxB0QOf2un6s+U4fxHL7XT9WfKcP4g6IHP7XT9WfKcP4jl9rp+rPlOH8QdEADy9r2na/p6eXGfDln6eoeXte07X9PRxnw5Z+kHrAAAc/a6fqz5Th/EcntdP1Z8pw/iDoQc/tdP1Z8pw/iOX2un6s+U4fxB0QOf2un6s+U4fxHL7XT9WfKcP4g6IHP7XT9WfKcP4jl9rp+rPlOH8QdEADy9r2na/p6eXGfDln6eoeXte07X9PRxnw5Z+kHrAAAc/a6fqz5Th/EcntdP1Z8pw/iDoQc/tdP1Z8pw/iOX2un6s+U4fxB0QOf2un6s+U4fxHL7XT9WfKcP4g6IHP7XT9WfKcP4jl9rp+rPlOH8QdEADy9r2na/p6eXGfDln6eoeXte07X9PRxnw5Z+kHrAAAAAAAAAAAAAAAAPL2vadr+np5cZ8OWfp6h5e17Ttf09HGfDln6QesAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8va9p2v6enlxnw5Z+nqHl7XtO1/T0cZ8OWfpB6wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADy9r2na/p6eXGfDln6eoeXte07X9PRxnw5Z+kHrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPJ/1K3L2UaXp6U/F5/7j1jzdt/X/AKvRw/Dln38PVB6QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADy9r2na/p6eXGfDln6eoeXte07X9PRxnw5Z+kHrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPb9IAD//2Q==');
    background-size: cover;
    background-position: center;
    border-top: 1px solid var(--border-light, #f0f0f0);
    border-bottom: 1px solid var(--border-light, #f0f0f0);
}
        .location-card-pin {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -100%);
        }
        .wechat-dark-mode .location-card-map {
            filter: invert(1) hue-rotate(180deg);
        }
        .location-card-footer {
            display: flex;
            align-items: center;
            font-size: 10px;
            color: #c7c7c7;
            padding: 4px 12px;
        }
        .location-card-footer img {
            width: 12px;
            height: 12px;
            margin-right: 4px;
        }

        /* NEW: Chat Timestamp */
        .chat-timestamp {
            text-align: center;
            margin: 10px 0;
            font-size: var(--small-font-size, 12px);
            color: var(--text-secondary, #999);
        }
        
        /* [NEW] Voice Call Styles */
        #voiceCallScreen, #incomingCallScreen {
            background-color: rgba(0,0,0,0.5);
            z-index: 2000;
            color: #fff;
            display: none; /* Initially hidden */
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 80px 20px 40px;
        }
        #voiceCallScreen.active, #incomingCallScreen.active {
            display: flex;
        }
        .voice-call-bg {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-size: cover;
            background-position: center;
            filter: blur(10px);
            z-index: -1;
        }
        .voice-call-header {
            text-align: center;
        }
        .voice-call-avatar {
            width: 90px;
            height: 90px;
            border-radius: 12px;
            background-size: cover;
            background-position: center;
            margin: 0 auto 15px;
            border: 2px solid rgba(255,255,255,0.5);
        }
        .voice-call-name {
            font-size: 24px;
            font-weight: 600;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        .voice-call-status {
            font-size: 16px;
            color: rgba(255,255,255,0.8);
            margin-top: 5px;
        }

        .voice-call-log {
            flex-grow: 1;
            width: 100%;
            overflow-y: auto;
            margin: 20px 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }
        .voice-call-log .log-item {
            margin-bottom: 15px;
            max-width: 80%;
        }
        .voice-call-log .log-item.user { align-self: flex-end; }
        .voice-call-log .log-item.ai { align-self: flex-start; }
        .voice-call-log .dialogue-bubble {
            background: rgba(255,255,255,0.2);
            padding: 10px 14px;
            border-radius: 18px;
            line-height: 1.5;
        }
        .voice-call-log .log-item.user .dialogue-bubble { background: #007aff; }
        .voice-call-log .narration-text {
            font-size: 13px;
            font-style: italic;
            color: rgba(255,255,255,0.7);
            text-align: center;
            margin-top: 8px;
            padding: 0 10px;
        }

        .voice-call-input-area {
            display: flex;
            width: 100%;
            gap: 10px;
            align-items: center;
            margin-top: 20px;
        }
        .voice-call-input-area input {
            flex-grow: 1;
            height: 40px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.4);
            background: rgba(0,0,0,0.3);
            color: #fff;
            padding: 0 15px;
        }
        .voice-call-input-area button {
            width: 40px; height: 40px; border-radius: 50%;
            border: none;
            background: #007aff;
            color: #fff;
            flex-shrink: 0;
            display: flex; align-items: center; justify-content: center;
        }

        .voice-call-controls {
            display: flex;
            justify-content: space-around;
            width: 100%;
        }
        .voice-call-btn {
            background: none; border: none;
            color: #fff; text-align: center; cursor: pointer;
        }
        .voice-call-btn-icon {
            width: 60px; height: 60px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
        }
        .voice-call-btn.hangup .voice-call-btn-icon { background: #ff3b30; }
        .voice-call-btn-icon svg { width: 30px; height: 30px; fill: #fff; }

        #incomingCallScreen {
            z-index: 9000;
            background-color: #333;
        }
        .incoming-call-actions {
            width: 100%;
            display: flex;
            justify-content: space-around;
        }
        .incoming-call-btn.accept .voice-call-btn-icon { background: #34c759; }

        /* [MODIFIED] Heart's Voice Modal Styles */
        #heartsVoiceModal .modal-content {
            text-align: center;
            padding-bottom: 25px;
        }
        #heartsVoiceHeader {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px; /* MODIFIED: Reduced gap */
            margin-bottom: 10px;
        }
        #heartsVoiceAvatar {
            width: 40px;
            height: 40px;
            border-radius: 6px;
        }
        #heartsVoiceName {
            font-size: 16px;
            font-weight: bold;
        }
        #heartsVoiceEmoji {
            font-size: 48px;
            margin: 10px 0;
            line-height: 1.2;
        }
        #heartsVoiceThought {
            background-color: var(--bg-hover, #f5f5f5);
            padding: 15px;
            border-radius: 8px;
            font-size: 15px;
            line-height: 1.8;
            color: var(--text-secondary, #666);
            min-height: 140px;
            text-align: left;
            margin-top: 15px;
        }
        #heartsVoiceThought div {
            margin-bottom: 8px;
        }
        #heartsVoiceThought div:last-child {
            margin-bottom: 0;
        }
        #heartsVoiceThought strong {
            color: var(--text-color, #333);
            font-weight: 600;
        }

        /* 新增：朋友圈删除图标样式 */
        .moments-delete-icon {
            cursor: pointer;
            fill: #586b95; /* 使用与名字相同的蓝色 */
            width: 16px;
            height: 16px;
            transition: fill 0.2s ease;
        }
        .moments-delete-icon:hover {
            fill: #ff3b30; /* 鼠标悬停时变为红色 */
        }

/* 新增：朋友圈时间与删除图标的包裹容器样式 */
.moments-time-group {
    display: flex;         /* 让时间与图标在同一行 */
    align-items: center;   /* 让它们垂直居中对齐 */
    gap: 10px;              /* 控制时间与图标之间的间距，你可以调整这个值 */
}

/* 【【【第二步：请将这两段CSS代码粘贴到 <style> 区域】】】 */

/* 用于隐藏和显示主动发消息的时间间隔设置 */

/* 【【【第一步：请用这个修正后的完整CSS代码块，替换原来的 .proactive-interval-setting 样式】】】 */

/* 用于隐藏和显示主动发消息的时间间隔设置 */
.proactive-interval-setting {
    /* 这些是原有样式，保持不变 */
    display: none;
    align-items: center;
    justify-content: space-between;

    /* 【新增】让它拥有和其他设置项一样的“卡片”外观 */
    background: var(--bg-primary, white);
    padding: 15px 20px;
    border-radius: var(--menu-item-radius, 12px);

    /* 【核心修复】用正确的边距来推开下方的元素 */
    /* 上边距为负，让它和上面的开关看起来像一组；下边距为正，把它下面的“导入数据”推开 */
    margin: -10px 15px 15px 15px; 
}

.proactive-interval-setting.show {
    display: flex;
}
.proactive-interval-setting label {
    color: var(--text-color);
}
.proactive-interval-setting input {
    width: 60px;
    padding: 5px;
    border-radius: 6px;
    border: 1px solid var(--border-color, #ccc);
    text-align: center;
    background: var(--bg-hover);
    color: var(--text-color);
}

    /* [新增] 优化论坛评论区样式 */
    .sim-detail-content .comment-floor {
        border-top: 1px solid #f0f0f0; /* 用更浅的颜色做分割线 */
        padding: 15px 0; /* 【修复】设置一个合理的上下内边距 */
        margin: 0; /* 移除外边距 */
    }
    
    .sim-detail-content .comment-user-info {
        font-size: 13px; /* 稍稍增大字号 */
        color: #888; /* 柔和的灰色 */
        /* 【核心修复】移除负边距，改成一个稳定的、小的底部间距 */
        margin-bottom: 5px; 
    }
    
    .sim-detail-content .comment-text {
        margin-top: 0; /* 保持内容顶部没有多余间距 */
        line-height: 1.6; /* 舒适的行高 */
    }

/* 【【【第二步：请将这段CSS代码粘贴到 <style> 区域的末尾】】】 */

/* 加载动画的样式 */
.loading-spinner {
    width: 40px;
    height: 40px;
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-top-color: #fff;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

        /* --- 新增：日记封面和全文页面的样式 --- */
        .diary-cover-item {
            background: var(--bg-primary, white);
            margin: 15px;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .diary-cover-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .diary-cover-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        .diary-cover-avatar {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            margin-right: 10px;
            background-size: cover;
            background-position: center;
        }
        .diary-cover-info {
            font-size: 12px;
            color: var(--text-secondary, #888);
        }
        .diary-cover-author {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-color, #333);
            margin-bottom: 2px;
        }
        .diary-cover-date {
             color: var(--text-secondary, #999);
        }
        .diary-cover-thought {
            font-size: 16px;
            color: var(--text-color, #333);
            text-align: center;
            line-height: 1.6;
            padding: 10px 0;
            font-style: italic;
        }

        /* --- 这是【修正后】的代码 --- */
#diaryViewScreen .wechat-content {
    padding: 74px 20px 20px 20px; /* 核心修改在这里 */
    font-size: 16px;
    line-height: 1.8;
    white-space: pre-wrap; 
}

        /* --- 新增：日记好友选择界面的网格样式 --- */
        .diary-friend-grid {
            display: grid; /* 使用网格布局 */
            grid-template-columns: repeat(2, 1fr); /* 创建两列，每列宽度平分 */
            gap: 20px; /* 设置网格项之间的间距 */
            padding: 20px; /* 设置整个网格容器的内边距 */
        }

        .diary-book-item {
            display: flex; /* 使用Flex布局来轻松实现居中 */
            flex-direction: column; /* 让头像和名字垂直排列 */
            align-items: center; /* 水平居中 */
            justify-content: center; /* 垂直居中 */
            padding: 20px;
            background: var(--bg-primary, white);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            cursor: pointer;
            transition: all 0.2s ease;
            aspect-ratio: 1 / 1; /* 关键！让每个格子都是正方形 */
        }
        
        .diary-book-item:hover {
             transform: translateY(-3px); /* 鼠标悬停时轻微上浮 */
             box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }

        .diary-book-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%; /* 圆形头像 */
            margin-bottom: 10px; /* 头像和名字之间的距离 */
            background-size: cover;
            background-position: center;
            background-color: #eee;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: var(--text-color, #333);
        }

        .diary-book-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-color, #333);
            text-align: center;
        }
        
                /* --- 新增：手动生成日记按钮的样式 --- */
        .generate-diary-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%; /* 确保是圆形 */
            background-color: var(--bg-hover, #f0f0f0);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .generate-diary-btn:hover {
            background-color: #e0e0e0;
        }

        .generate-diary-btn svg {
            width: 18px;
            height: 18px;
            fill: var(--text-color, #333);
        }

        /* 按钮在加载时的旋转动画 */
        .generate-diary-btn.loading svg {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

/* --- 新增：记忆页面样式 (V2版) --- */
#memoryList {
    padding: 15px;
    box-sizing: border-box;
}

.memory-item {
    background: var(--bg-primary, white);
    border-radius: 12px;
    padding: 15px;
    margin-bottom: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    position: relative; /* 为了日期定位 */
}

.memory-date {
    font-size: 12px;
    color: var(--text-secondary, #999);
    position: absolute;
    top: 15px;
    right: 15px;
}

.memory-content {
    font-size: 15px;
    line-height: 1.7;
    color: var(--text-color, #333);
    white-space: pre-wrap; /* 保留换行 */
    padding-top: 30px; /* 给日期留出空间 */
}

/* --- [新增] 记忆生成设置输入框样式 --- */
.settings-input-number {
    width: 80px;
    padding: 5px 8px;
    border-radius: 6px;
    border: 1px solid var(--border-color, #ccc);
    text-align: right;
    background: var(--bg-hover, #f0f0f0);
    color: var(--text-color, #000);
    font-size: 14px;
}

/* ↓↓↓ 第2步：从这里开始复制 ↓↓↓ */

/* 红包卡片在聊天界面的样式 */
.message-content.has-red-envelope {
    padding: 0;
    background-color: transparent;
    box-shadow: none;
    max-width: 250px; 
}

/* ↓↓↓ 第1步：用这个替换你原来的 .red-envelope-card 样式 ↓↓↓ */
.red-envelope-card {
    width: 200px; /* --- 核心修改：宽度从240px改为200px，与转账卡片一致 --- */
    background-color: #F9953F;
    color: white;
    border-radius: 10px;
    overflow: hidden;
    cursor: pointer;
    transition: filter 0.2s;
}

.red-envelope-card:hover {
    filter: brightness(0.95);
}
.red-envelope-card.opened {
    background-color: #FDEFE1;
    color: #D3A27F;
}
.red-envelope-card-body {
    padding: 12px 15px;
    display: flex;
    align-items: center;
    gap: 12px;
}
.red-envelope-icon {
    width: 32px;
    height: 32px;
    flex-shrink: 0;
}
.red-envelope-info {
    flex-grow: 1;
    min-width: 0;
}
.red-envelope-remark {
    font-size: 16px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.red-envelope-status-text {
    font-size: 13px;
    opacity: 0.9;
}
.red-envelope-card.opened .red-envelope-status-text {
    color: #D3A27F;
}
.red-envelope-footer {
    font-size: 10px;
    background-color: #FFFFFF;
    color: #B2B2B2;
    padding: 4px 15px;
    border-top: 1px solid rgba(0,0,0,0.05);
}

/* 红包系统提示消息的样式 */
.system-message-tip {
    text-align: center;
    margin: 10px 0;
    font-size: 12px;
    color: #999;
}

/* 红包领取详情列表的样式 */
.claim-list-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    background-color: white;
    border-bottom: 1px solid #f0f0f0;
}
.claim-list-item:last-child {
    border-bottom: none;
}
.claim-avatar {
    width: 40px;
    height: 40px;
    border-radius: 6px;
    margin-right: 12px;
    background-size: cover;
    background-position: center;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    background-color: #eee;
}
.claim-info {
    flex-grow: 1;
}
.claim-name {
    font-size: 16px;
    color: #333;
}
.claim-time {
    font-size: 12px;
    color: #aaa;
}
.claim-amount {
    font-size: 16px;
    font-weight: 500;
    color: #333;
}
.claim-best-luck {
    background-color: #FFC107;
    color: #fff;
    font-size: 10px;
    padding: 2px 5px;
    border-radius: 4px;
    margin-left: 8px;
}

/* ↑↑↑ 第2步：在这里结束复制 ↑↑↑ */

/* --- 新增：优化红包详情列表中“手气最佳”的显示 --- */
.claim-list-item .claim-name {
    display: flex;
    align-items: center;
    gap: 8px; /* 名字和“手气最佳”标签之间的间距 */
}

#redEnvelopeOpenCard {
    /* 这就是红包卡片本身 */
    width: 280px; /* 红包宽度 */
    height: 380px; /* 红包高度 */
    background-color: #D85847; /* 微信红包的经典红色 */
    border-radius: 12px; /* 让卡片有圆角，更好看 */
    box-shadow: 0 8px 30px rgba(0,0,0,0.2); /* 添加一点立体阴影 */
    position: relative; /* 使得内部的按钮可以相对于它定位 */
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden; /* 隐藏超出边界的装饰 */
}

#redEnvelopeOpenCard::before {
    /* 用伪元素给红包顶部加一个好看的金色装饰 */
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 100px;
    background: linear-gradient(to bottom, rgba(255, 220, 150, 0.4), transparent);
}

#openRedEnvelopeButton {
    /* 这才是那个“开”字按钮 */
    width: 90px;
    height: 90px;
    background-color: #FAD04E; /* 经典的金色 */
    border-radius: 50%;
    color: #A36B28; /* 暗金色字体 */
    font-size: 48px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* 更有弹性的动画效果 */
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    z-index: 1; /* 确保按钮在金色装饰之上 */
}

/* ↓↓↓ 第二步：将这些CSS代码粘贴到 <style> 标签的末尾 ↓↓↓ */

/* 聊天界面中的投票卡片样式 */
.message-content.has-poll {
    padding: 0;
    background-color: transparent;
    box-shadow: none;
    max-width: 280px; /* 卡片最大宽度 */
}

.poll-card {
    width: 250px; /* 卡片固定宽度 */
    background-color: var(--bg-primary, white);
    border-radius: 12px;
    border: 1px solid var(--border-light, #f0f0f0);
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    overflow: hidden;
    color: var(--text-color, #000);
}

.poll-card-header {
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-light, #f0f0f0);
}

.poll-card-title {
    font-size: 16px;
    font-weight: 600;
    white-space: pre-wrap; /* 允许标题换行 */
    word-break: break-word;
}

.poll-card-subtitle {
    font-size: 12px;
    color: var(--text-secondary, #999);
    margin-top: 4px;
}

.poll-card-options {
    padding: 10px 15px;
}

.poll-option-item {
    margin-bottom: 10px;
}
.poll-option-item:last-child {
    margin-bottom: 0;
}

.poll-option-text {
    font-size: 14px;
    margin-bottom: 8px;
    display: block; /* 让文字单独占一行 */
}

.poll-voters-line {
    display: flex;
    align-items: center;
    gap: 4px; /* 头像之间的间距 */
    min-height: 24px; /* 即使没人投票也保持高度 */
    border-left: 3px solid var(--bg-hover, #f0f0f0); /* 左侧的指示条 */
    padding-left: 8px;
}

.poll-voter-avatar {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background-size: cover;
    background-position: center;
    background-color: #ccc;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    color: white;
    font-weight: bold;
    flex-shrink: 0; /* 防止头像被压缩 */
}

/* 投票创建弹窗的选项输入框样式 */
.poll-option-input {
    flex-grow: 1; /* 让输入框占据大部分空间 */
}

.remove-option-btn {
    width: 30px;
    height: 30px;
    border: none;
    background-color: #ff3b30;
    color: white;
    border-radius: 50%;
    cursor: pointer;
    font-size: 18px;
    line-height: 30px;
    flex-shrink: 0;
}

/* ↑↑↑ 第二步：代码粘贴到此结束 ↑↑↑ */

/* ↓↓↓ 第3步：从这里开始复制所有新增的CSS代码 ↓↓↓ */

/* 人设列表项的激活状态（被选中时） */
.friend-item.persona-active {
    background-color: #e3f2fd; /* 淡蓝色背景 */
    border-left: 4px solid #007aff; /* 左侧蓝色高亮条 */
    padding-left: 11px; /* 调整内边距以适应边框 */
}

/* ↑↑↑ CSS代码复制到这里结束 ↑↑↑ */

/* --- 新增：群聊选择弹窗的样式优化 (修正版) --- */
#groupChatFriendList .multi-select-item {
    padding: 8px 0;
    display: flex;
    align-items: center;
}

#groupChatFriendList .friend-avatar {
    width: 40px;
    height: 40px;
    border-radius: 6px;
    margin-left: 12px;  /* 这是选择框和头像之间的距离 */
    margin-right: 12px; /* 这是头像和名字之间的距离 */
    flex-shrink: 0;
    font-size: 16px;
    /* 新增：确保图片头像能正确显示 */
    background-size: cover;
    background-position: center;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: var(--bg-hover, #f0f0f0);
    color: var(--text-color, #333);
}

#groupChatFriendList label {
    font-size: 16px;
}

#groupChatFriendList input[type="checkbox"] {
    /* 我们不再需要给选择框设置右边距了 */
}

    </style>
</head>
<body>

<!-- 【【【第一步：请将这行代码粘贴到 <body> 标签下面】】】 -->

<!-- 【【【这是修改后的正确代码】】】 -->
<div id="loadingOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 10000; align-items: center; justify-content: center; color: white; flex-direction: column; gap: 20px; text-align: center;"></div>

    <audio id="audioPlayer"></audio>
    <input type="file" id="photoInput" accept="image/*" style="display: none;" onchange="handlePhotoUpload(event)">
    <input type="file" id="widgetImageInput" accept="image/*" style="display: none;" onchange="handleWidgetImageUpload(event)">
    <input type="file" id="listenBgInput" accept="image/*" style="display: none;" onchange="handleListenBgUpload(event)">
    <input type="file" id="vinylImageInput" accept="image/*" style="display: none;" onchange="handleVinylImageUpload(event)">
    <input type="file" id="songFileInput" accept="audio/mp3,audio/*" style="display:none;" onchange="handleSongFileSelect(event)">
    <input type="file" id="lrcFileInput" accept=".lrc" style="display:none;" onchange="handleLrcFileSelect(event)">
    
    <!-- Inputs for new emoji modal -->
    <input type="file" id="singleEmojiUploadInput" accept="image/*" style="display: none;" onchange="handleSingleEmojiUpload(event)">
    <input type="file" id="batchEmojiUploadInput" accept="image/*" style="display: none;" onchange="handleBatchEmojiUpload(event)" multiple>

    <div id="message-notification">
        <div id="notification-avatar"></div>
        <div id="notification-content">
            <div id="notification-sender"></div>
            <div id="notification-message"></div>
        </div>
    </div>

    <div class="phone">
        <div id="floatingPlayer">
            <div id="floatingPlayerArt"></div>
            <div id="floatingPlayerInfo">
                <span id="floatingPlayerTitle">歌曲名称</span>
                <span id="floatingPlayerSubtitle">正在一起听...</span>
            </div>
            <button id="floatingPlayerCloseBtn" onclick="terminateListenTogether(event)">&times;</button>
        </div>

        <div class="status-bar">
            <div class="status-left">
                <span id="currentTime"></span>
            </div>
            <div class="status-right">
                <div class="signal-icon">
                    <div class="signal-bar"></div>
                    <div class="signal-bar"></div>
                    <div class="signal-bar"></div>
                    <div class="signal-bar"></div>
                </div>
                <div class="network-icon">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M1 9l2 2c4.97-4.97 13.03-4.97 18 0l2-2C16.93 2.93 7.08 2.93 1 9zm8 8l3 3 3-3c-1.65-1.66-4.34-1.66-6 0zm-4-4l2 2c2.76-2.76 7.24-2.76 10 0l2-2C15.14 9.14 8.87 9.14 5 13z"/>
                    </svg>
                </div>
                <div class="battery-icon">
                    <div class="battery-level"></div>
                    <div class="battery-tip"></div>
                </div>
            </div>
        </div>

        <div class="screen">
            <div id="homeScreen" class="page active">
                <div class="home-screen">
                    <div class="profile-widget-container" id="profileWidgetContainer">
                        <div class="profile-widget">
                            <div class="profile-avatar-widget" id="widgetAvatar" onclick="changeAvatar()"></div>
                            <div class="widget-info-section">
                                <div class="profile-name-widget" id="widgetName" onclick="changeName()">可点击编辑</div>
                                <div class="profile-signature-widget" id="widgetSignature" onclick="changeSignature()">可点击编辑</div>
                                <div class="profile-location" onclick="changeLocation()">
                                    <svg class="location-icon" viewBox="0 0 24 24">
                                        <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                                    </svg>
                                    <span id="widgetLocation">可点击编辑</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="home-widgets-container">
                        <div class="new-widget" id="homeScreenWidget">
                            <div class="widget-header-text" id="widgetHeaderText" onclick="editWidgetText('widgetHeaderText', this)">(:::[♡]:::)..?</div>
                            <div class="widget-bubble">
                                <img id="widgetImage1" src="https://i.imgur.com/example-avatar-1.png" onclick="editWidgetImage('widgetImage1')">
                                <span id="widgetText1" onclick="editWidgetText('widgetText1', this)">have a nice day 🌟</span>
                            </div>
                            <div class="widget-bubble">
                                <span id="widgetText2" onclick="editWidgetText('widgetText2', this)">.o. HAPPY EVERYDAY ☻</span>
                                <img id="widgetImage2" src="https://i.imgur.com/example-avatar-2.png" onclick="editWidgetImage('widgetImage2')">
                            </div>
                        </div>
                        <div class="app-grid">
                            <div class="app wechat" onclick="openApp('wechat')">
                                <div class="app-icon-container" id="icon-wechat">
                                    <svg class="app-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M12 2C6.477 2 2 6.477 2 12c0 3.978 2.32 7.439 5.698 9.062L7 22l3.41-2.131A10.12 10.12 0 0 0 12 20c5.523 0 10-4.477 10-10S17.523 2 12 2zM8.5 13.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3zm7 0a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z"/>
                                    </svg>
                                </div>
                                <div class="app-label">微信</div>
                            </div>
                            <div class="app settings" onclick="openApp('settings')">
                                <div class="app-icon-container" id="icon-settings">
                                    <svg class="app-icon" viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M12 15.5A3.5 3.5 0 0 1 8.5 12A3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5m7.43-2.53c.04-.32.07-.64.07-.97c0-.33-.03-.66-.07-1l2.11-1.63c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.31-.61-.22l-2.49 1c-.52-.39-1.06-.73-1.69-.98l-.37-2.65A.506.506 0 0 0 14 2h-4c-.25 0-.46.18-.5.42l-.37 2.65c-.63.25-1.17.59-1.69-.98l-2.49-1c-.22-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64L4.57 11c-.04.34-.07.67-.07 1c0 .33.03.65.07.97l-2.11 1.66c-.19.15-.25.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1.01c.52.4 1.06.74 1.69.99l.37 2.65c.04.24.25.42.5.42h4c.25 0 .46-.18.5.42l.37-2.65c.63-.26 1.17-.59 1.69-.99l2.49 1.01c.22.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.66Z"/>
                                    </svg>
                                </div>
                                <div class="app-label">设置</div>
                            </div>
                            <div class="app worldbook" onclick="openApp('worldbook')">
                                <div class="app-icon-container" id="icon-worldbook">
                                    <svg class="app-icon" viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/>
                                    </svg>
                                </div>
                                <div class="app-label">世界书</div>
                            </div>
                            <div class="app theme" onclick="openApp('theme')">
                                <div class="app-icon-container" id="icon-theme">
                                    <svg class="app-icon" viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M12,18C8.69,18 6,15.31 6,12C6,8.69 8.69,6 12,6C15.31,6 18,8.69 18,12C18,15.31 15.31,18 12,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,7A5,5 0 0,0 7,12A5,5 0 0,0 12,17A5,5 0 0,0 17,12A5,5 0 0,0 12,7Z"/><circle cx="12" cy="12" r="3" fill="currentColor"/></svg>
                                </div>
                                <div class="app-label">主题</div>
                            </div>
                        </div>
                    </div>
                     <div class="bottom-dock">
                        <div class="app" onclick="openApp('phone')">
                            <div class="app-icon-container" id="icon-phone">
                                <svg class="app-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M6.62,10.79C8.06,13.62 10.38,15.94 13.21,17.38L15.41,15.18C15.69,14.9 16.08,14.82 16.43,14.93C17.55,15.3 18.75,15.5 20,15.5A1,1 0 0,1 21,16.5V20A1,1 0 0,1 20,21A17,17 0 0,1 3,4A1,1 0 0,1 4,3H7.5A1,1 0 0,1 8.5,4C8.5,5.25 8.7,6.45 9.07,7.57C9.18,7.92 9.1,8.31 8.82,8.59L6.62,10.79Z"/></svg>
                            </div>
                            <div class="app-label">手机</div>
                        </div>
                        <div class="app" onclick="showAlert('此功能暂未开放')">
                            <div class="app-icon-container" id="icon-placeholder1">
                                <svg class="app-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M20,18H4V8H20M20,6H12L10,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V8C22,6.89 21.1,6 20,6Z" /></svg>
                            </div>
                            <div class="app-label">闲置1</div>
                        </div>
                        <div class="app" onclick="showAlert('此功能暂未开放')">
                            <div class="app-icon-container" id="icon-placeholder2">
                                <svg class="app-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M14.5,12A2.5,2.5 0 0,0 12,9.5A2.5,2.5 0 0,0 9.5,12A2.5,2.5 0 0,0 12,14.5A2.5,2.5 0 0,0 14.5,12M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4Z" /></svg>
                            </div>
                            <div class="app-label">闲置2</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="wechatApp" class="page">
                 <div class="nav-bar">
    <button class="nav-btn" onclick="goHome()">←</button>
    <div class="nav-title">消息</div>
    <!-- ↓↓↓ 修改从这里开始 ↓↓↓ -->
    <div id="navRightButtons">
        <button class="nav-btn" id="addMenuBtn" onclick="toggleAddMenu()">+</button>
    </div>
    <!-- ↑↑↑ 修改到这里结束 ↑↑↑ -->
</div>
                <div class="add-menu" id="addMenu">
                    <div class="add-menu-item" onclick="openGroupChatModal()">发起群聊</div>
                    <div class="add-menu-item" onclick="openAddFriend()">添加好友</div>
                </div>
                <div class="wechat-content">
                    <div id="wechatMessages" class="friend-list"></div>
                    <div id="wechatDiscover" class="discover-content" style="display: none;">
                        <div class="discover-menu">
                            <div class="discover-menu-item" onclick="openMoments()">
                                <div class="discover-menu-left">
                                    <svg class="discover-menu-icon" viewBox="0 0 24 24"><path d="M12,12A6,6 0 1,0 18,18A6,6 0 0,0 12,12M12,20A8,8 0 1,1 20,12A8,8 0 0,1 12,20M2,4H8V6H2V4M2,8H6V10H2V8M2,12H8V14H2V12M2,16H6V18H2V16M18,4H22V6H18V4M18,8H22V10H18V8M18,12H22V14H18V12M18,16H22V18H18V16Z" /></svg>
                                    <div class="discover-menu-title">朋友圈</div>
                                </div>
                                <span>></span>
                            </div>
                            <div class="discover-menu-item" onclick="openDiary()">
                                <div class="discover-menu-left">
                                    <svg class="discover-menu-icon" viewBox="0 0 24 24"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/></svg>
                                    <div class="discover-menu-title">日记</div>
                                </div>
                                <span>></span>
                            </div>
                        </div>
                    </div>
                    <div id="wechatProfile" class="profile-content" style="display: none;">
                        <div class="profile-section">
                            <div class="profile-header">
                                <div class="profile-avatar-large" onclick="changeAvatar()" id="profileAvatar"></div>
                                <div class="profile-name" onclick="changeName()" id="profileName">可点击编辑</div>
                            </div>
                        </div>
                        <div class="profile-section">
                            <div class="profile-menu">
                                <div class="profile-menu-item" onclick="openPersonaList()">
    <span>我的人设</span>
    <span>></span>
</div>
                                <div class="profile-menu-item" onclick="openWallet()">
                                    <span>钱包</span>
                                    <span>></span>
                                </div>
                                <div class="profile-menu-item" onclick="openFavorites()">
                                    <span>收藏</span>
                                    <span>></span>
                                </div>
                                <div class="profile-menu-item" onclick="openMySettings()">
                                    <span>设置</span>
                                    <span>></span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="wechat-bottom-nav">
                    <div class="wechat-tab active" onclick="switchWechatTab('messages')">
                        <div class="wechat-tab-icon">
                            <svg class="icon-chat" viewBox="0 0 24 24"><path d="M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4A2,2 0 0,0 20,2M20,16H5.17L4,17.17V4H20V16Z" /></svg>
                        </div>
                        <div>消息</div>
                    </div>
                    <div class="wechat-tab" onclick="switchWechatTab('discover')">
                        <div class="wechat-tab-icon">
                            <svg class="icon-discover" viewBox="0 0 24 24"><path d="M12,2A10,10 0 1,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 1,1 4,12A8,8 0 0,1 12,4M12,10.5L13.9,13.4L11.1,14.9L12,17L12.9,14.9L10.1,13.4L12,10.5Z" /></svg>
                        </div>
                        <div>发现</div>
                    </div>
                    <div class="wechat-tab" onclick="switchWechatTab('profile')">
                        <div class="wechat-tab-icon">
                           <svg class="icon-profile" viewBox="0 0 24 24"><path d="M12,4A4,4 0 0,1 16,8A4,4 0 0,1 12,12A4,4 0 0,1 8,8A4,4 0 0,1 12,4M12,14C16.42,14 20,15.79 20,18V20H4V18C4,15.79 7.58,14 12,14Z" /></svg>
                        </div>
                        <div>我</div>
                    </div>
                </div>
            </div>

            <div id="chatScreen" class="page">
                <div class="nav-bar">
                    <button class="nav-btn" onclick="backToWechat()">←</button>
                    <div class="nav-title" id="chatTitle">聊天</div>
                    <div style="display: flex; align-items: center;">
                        <button class="nav-btn" id="heartsVoiceBtn" onclick="openHeartsVoiceModal()" title="心声">
                            <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg>
                        </button>
                        <button class="nav-btn" onclick="openChatSettings()">⋯</button>
                    </div>
                </div>
                <div class="wechat-content">
                    <div class="chat-messages" id="chatMessages"></div>
                </div>
                <div class="multi-select-toolbar" id="multiSelectToolbar">
                    <span class="multi-select-count" id="multiSelectCount">已选择 0 条消息</span>
                    <div class="multi-select-actions">
                        <button class="multi-select-btn delete" onclick="deleteSelectedMessages()">删除</button>
                        <button class="multi-select-btn cancel" onclick="exitMultiSelectMode()">取消</button>
                    </div>
                </div>
                <div class="chat-input-area" id="chatInputArea">
                    <div class="chat-input">
                        <button class="chat-btn" id="receiveBtn" onclick="requestAIResponse()" title="接收消息"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"><path d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.898 20.567L16.5 21.75l-.398-1.183a2.25 2.25 0 00-1.423-1.423L13.5 18.75l1.183-.398a2.25 2.25 0 001.423-1.423L16.5 15.75l.398 1.183a2.25 2.25 0 001.423 1.423L19.5 18.75l-1.183.398a2.25 2.25 0 00-1.423 1.423z" /></svg></button>
                        <button class="chat-btn" id="voiceBtn" onclick="openVoiceModal()" title="语音"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.49 6-3.31 6-6.72h-1.7z"/></svg></button>
                        <textarea id="messageInput" rows="1" placeholder="输入消息..." onkeypress="handleKeyPress(event)" oninput="toggleSendButtonActive(this)" onclick="hideFunctionMenus()"></textarea>
                        <button class="chat-btn" id="emojiBtn" onclick="toggleEmojiPicker()" title="表情"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M12,2C6.47,2 2,6.47 2,12C2,17.53 6.47,22 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2M15.5,8A1.5,1.5 0 0,1 17,9.5A1.5,1.5 0 0,1 15.5,11A1.5,1.5 0 0,1 14,9.5A1.5,1.5 0 0,1 15.5,8M8.5,8A1.5,1.5 0 0,1 10,9.5A1.5,1.5 0 0,1 8.5,11A1.5,1.5 0 0,1 7,9.5A1.5,1.5 0 0,1 8.5,8M12,17.23C10.25,17.23 8.71,16.5 7.81,15.42L9.23,14C9.68,14.72 10.75,15.23 12,15.23C13.25,15.23 14.32,14.72 14.77,14L16.19,15.42C15.29,16.5 13.75,17.23 12,17.23Z"/></svg></button>
                        <button class="chat-btn plus-btn" onclick="toggleChatFunctions()" title="更多"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg></button>
                        <button class="chat-btn send-btn" id="sendBtn" onclick="sendMessage()" title="发送消息"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M3.4 20.4l17.4-8.4c.8-.4.8-1.6 0-2L3.4 1.6c-.8-.4-1.6.4-1.4 1.2l3.6 7.2c.2.4.2 1 0 1.4L2 19.2c-.2.8.6 1.6 1.4 1.2z"/></svg></button>
                    </div>
                    <div class="chat-functions" id="chatFunctions">
                        <div class="function-menu">
                            <div class="function-item" onclick="selectPhoto()"><div class="function-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" /></svg></div><div class="function-label">照片</div></div>
                            <div class="function-item" onclick="openCameraModal()"><div class="function-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.31 2.31 0 015.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 00-1.134-.175 2.31 2.31 0 01-1.64-1.055l-.822-1.316a2.192 2.192 0 00-1.736-1.039 48.776 48.776 0 00-5.232 0 2.192 2.192 0 00-1.736 1.039l-.821 1.316z" /><path stroke-linecap="round" stroke-linejoin="round" d="M16.5 12.75a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM18.75 10.5h.008v.008h-.008V10.5z" /></svg></div><div class="function-label">拍摄</div></div>
                            <div class="function-item" onclick="startVoiceCall()"><div class="function-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M6.62,10.79C8.06,13.62 10.38,15.94 13.21,17.38L15.41,15.18C15.69,14.9 16.08,14.82 16.43,14.93C17.55,15.3 18.75,15.5 20,15.5A1,1 0 0,1 21,16.5V20A1,1 0 0,1 20,21A17,17 0 0,1 3,4A1,1 0 0,1 4,3H7.5A1,1 0 0,1 8.5,4C8.5,5.25 8.7,6.45 9.07,7.57C9.18,7.92 9.1,8.31 8.82,8.59L6.62,10.79Z"/></svg></div><div class="function-label">语音通话</div></div>
                            <div class="function-item" onclick="openTransferModal()"><div class="function-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M17 17H7v-2h10v2zm0-4H7v-2h10v2zm0-4H7V7h10v2zm-2-5H9v2h6V4zM5 21V3h14v18H5zm2-2h10V5H7v14z"/></svg></div><div class="function-label">转账</div></div>
                            <div class="function-item" onclick="openListenTogether()"><div class="function-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 9l10.5-3m0 6.553v3.75a2.25 2.25 0 01-1.632 2.163l-1.32.377a1.803 1.803 0 11-.99-3.467l2.31-.66a2.25 2.25 0 001.632-2.163zm0 0V2.25L9 5.25v10.303m0 0v3.75a2.25 2.25 0 01-1.632 2.163l-1.32.377a1.803 1.803 0 01-.99-3.467l2.31-.66A2.25 2.25 0 009 15.553z" /></svg></div><div class="function-label">一起听</div></div>
                            <div class="function-item" onclick="openLocationModal()"><div class="function-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5S10.62 9 12 9s2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg></div><div class="function-label">位置</div></div>
                            <!-- 新增的记忆功能按钮 -->
<div class="function-item" onclick="openMemoryScreen()">
    <div class="function-icon">
        <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-12h2v2h-2zm0 4h2v6h-2z"/>
        </svg>
    </div>
    <div class="function-label">记忆</div>
</div>
                        </div>
                    </div>
                    <div class="emoji-picker" id="emojiPicker">
                        <div class="emoji-picker-header">
                             <button class="emoji-picker-btn manage" id="manageEmojiBtn" onclick="toggleEmojiManagement()">管理</button>
                        </div>
                        <div class="emoji-grid" id="emojiGrid"></div>
                    </div>
                </div>
            </div>

            <!-- Together Listening Screen -->
            <div id="listenTogetherScreen" class="page">
                <div class="listen-bg" id="listenBg"></div>
                
                <div class="listen-main">
                     <div class="listen-header">
                        <div style="display: flex;">
                             <button class="nav-btn" id="listenBackBtn">
                                <svg fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>
                            </button>
                        </div>
                        <div class="listen-header-title">
                            <div id="listenSongTitle" style="font-weight: bold;">一起听</div>
                            <div id="listenSongArtist" style="font-size: 12px; color: rgba(255,255,255,0.7);">...</div>
                        </div>
                        <div style="display: flex; align-items: center;">
                             <button class="nav-btn" style="font-size: 14px;" onclick="document.getElementById('listenBgInput').click()" title="更换背景">BG</button>
                             <button class="nav-btn" style="font-size: 14px;" onclick="document.getElementById('vinylImageInput').click()" title="更换唱片封面">CD</button>
                             <button class="nav-btn" id="listenCloseBtn" style="color: #ff4d4d;"><svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg></button>
                        </div>
                    </div>

                    <div class="listen-avatars-container" id="listenAvatarsContainer">
                        <div class="headphone-arc"></div>
                        <div id="listenFriendAvatar" class="listen-avatar"></div>
                        <div id="listenUserAvatar" class="listen-avatar"></div>
                    </div>
                    
                    <div id="listenTogetherChatOverlay"></div>

                    <div class="vinyl-container">
                        <div id="vinylRecord" class="vinyl-record">
                            <div id="albumArt" class="album-art"></div>
                        </div>
                    </div>
                    
                    <div id="listenTogetherChatWrapper">
                        <button id="listenTogetherChatToggleBtn" onclick="toggleListenChat()">
                            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/></svg>
                        </button>
                         <div id="listenTogetherChatInputContainer">
                             <button class="listen-chat-btn" onclick="requestAIResponse()"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"><path d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.898 20.567L16.5 21.75l-.398-1.183a2.25 2.25 0 00-1.423-1.423L13.5 18.75l1.183-.398a2.25 2.25 0 001.423-1.423L16.5 15.75l.398 1.183a2.25 2.25 0 001.423 1.423L19.5 18.75l-1.183.398a2.25 2.25 0 00-1.423 1.423z" /></svg></button>
                             <input type="text" id="listenTogetherChatInput" placeholder="聊点什么..." onkeypress="handleListenTogetherKeyPress(event)">
                             <button id="listenTogetherSendBtn" onclick="sendListenTogetherMessage()"><svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg></button>
                         </div>
                    </div>

                    <div id="songLyrics">
                         <p class="sub-lyric"></p>
                         <p class="active-lyric">... 点击右下角列表添加歌曲 ...</p>
                         <p class="sub-lyric"></p>
                    </div>
                </div>
               
                <div class="listen-controls">
                    <div class="listen-progress-bar">
                        <span id="currentTimeLabel">00:00</span>
                        <input type="range" id="songProgressBar" value="0" step="1" oninput="seekSong(this.value)">
                        <span id="durationLabel">00:00</span>
                    </div>
                    <div class="listen-buttons">
                        <button class="listen-btn" id="repeatBtn" onclick="toggleRepeat()"><svg viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg></button>
                        <button class="listen-btn" onclick="prevSong()"><svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg></button>
                        <button class="listen-btn play-pause" onclick="togglePlayPause()" id="playPauseBtn"><svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></button>
                        <button class="listen-btn" onclick="nextSong()"><svg viewBox="0 0 24 24"><path d="M16 6h2v12h-2zm-8.5 6l8.5 6V6z"/></svg></button>
                        <button class="listen-btn" onclick="openPlaylistModal()"><svg viewBox="0 0 24 24"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></button>
                    </div>
                </div>
            </div>
            
                    <!-- [NEW] Diary Full View Screen -->
        <div id="diaryViewScreen" class="page">
            <div class="nav-bar">
                <button class="nav-btn" id="backToDiaryListBtn">←</button>
                <div class="nav-title">日记正文</div>
                <div></div>
            </div>
            <div class="wechat-content" id="fullDiaryContent">
                <!-- 日记的全部内容会显示在这里 -->
            </div>
        </div>

            <!-- [NEW] Voice Call Screen -->
            <div id="voiceCallScreen" class="page">
                <div class="voice-call-bg" id="voiceCallBg"></div>
                <div class="voice-call-header">
                    <div class="voice-call-avatar" id="voiceCallAvatar"></div>
                    <div class="voice-call-name" id="voiceCallName"></div>
                    <div class="voice-call-status" id="voiceCallStatus"></div>
                </div>
            
                <div class="voice-call-log" id="voiceCallLog">
                    <!-- Call dialogue will be appended here -->
                </div>
            
                <div class="voice-call-input-area" id="voiceCallInputArea">
                    <button onclick="requestAICallResponse()"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" width="20" height="20"><path d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.898 20.567L16.5 21.75l-.398-1.183a2.25 2.25 0 00-1.423-1.423L13.5 18.75l1.183-.398a2.25 2.25 0 001.423-1.423L16.5 15.75l.398 1.183a2.25 2.25 0 001.423 1.423L19.5 18.75l-1.183.398a2.25 2.25 0 00-1.423 1.423z" /></svg></button>
                    <input type="text" id="voiceCallUserInput" placeholder="输入你想说的话...">
                    <button onclick="sendUserCallMessage()"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" width="18" height="18"><path d="M3.4 20.4l17.4-8.4c.8-.4.8-1.6 0-2L3.4 1.6c-.8-.4-1.6.4-1.4 1.2l3.6 7.2c.2.4.2 1 0 1.4L2 19.2c-.2.8.6 1.6 1.4 1.2z"/></svg></button>
                </div>
            
                <div class="voice-call-controls" id="voiceCallControls">
                    <button class="voice-call-btn" onclick="showAlert('功能暂未开放')">
                        <div class="voice-call-btn-icon"><svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1.2-9.1c0-1.03.83-1.9 1.9-1.9 1.02 0 1.8.84 1.8 1.9l-.01 6.2c0 1.03-.83 1.9-1.9 1.9s-1.8-.84-1.8-1.9L10.8 4.9zM17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg></div>
                        <span>静音</span>
                    </button>
                    <button class="voice-call-btn hangup" onclick="endVoiceCall()">
                        <div class="voice-call-btn-icon"><svg viewBox="0 0 24 24"><path d="M12 9c-1.6 0-3.15.25-4.62.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.36 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.7l-2.47 2.47c-.18.18-.43.29-.71.29-.27 0-.52-.1-.7-.28-.79-.74-1.69-1.36-2.67-1.85-.33-.16-.56-.5-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z"/></svg></div>
                        <span>挂断</span>
                    </button>
                    <button class="voice-call-btn" onclick="showAlert('功能暂未开放')">
                        <div class="voice-call-btn-icon"><svg viewBox="0 0 24 24"><path d="M3 4l1.41 1.41L12 12.83l7.59-7.59L21 6.64 12 15.64 3.36 7.05 3 7.41V4h.01M3 14v2h18v-2H3z"/></svg></div>
                        <span>免提</span>
                    </button>
                </div>
            </div>

            <!-- [NEW] Incoming Call Screen -->
            <div id="incomingCallScreen" class="page">
                <div class="voice-call-bg" id="incomingCallBg"></div>
                <div class="voice-call-header">
                    <div class="voice-call-avatar" id="incomingCallAvatar"></div>
                    <div class="voice-call-name" id="incomingCallName"></div>
                    <div class="voice-call-status">邀请你进行语音通话</div>
                </div>
                <div class="incoming-call-actions">
                    <button class="voice-call-btn hangup" onclick="declineCall()">
                        <div class="voice-call-btn-icon"><svg viewBox="0 0 24 24"><path d="M12 9c-1.6 0-3.15.25-4.62.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.36 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.7l-2.47 2.47c-.18.18-.43.29-.71.29-.27 0-.52-.1-.7-.28-.79-.74-1.69-1.36-2.67-1.85-.33-.16-.56-.5-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z"/></svg></div>
                        <span>拒绝</span>
                    </button>
                    <button class="voice-call-btn accept incoming-call-btn" onclick="acceptCall()">
                        <div class="voice-call-btn-icon"><svg viewBox="0 0 24 24"><path d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56-.35-.12-.74-.03-1.01.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.59l2.2-2.2c.27-.27.35-.66.24-1.01-.37-1.11-.56-2.3-.56-3.53 0-.54-.45-.99-.99-.99H4.19C3.65 3 3 3.24 3 3.99 3 13.28 10.73 21 20.01 21c.75 0 .99-.65.99-.99v-3.45c0-.54-.45-.98-.99-.98z"/></svg></div>
                        <span>接听</span>
                    </button>
                </div>
            </div>


            <div id="messageMenu" class="message-menu"></div>

            <div id="recalledMessagePopup" class="recalled-message-popup">
                <div class="recalled-message-title">撤回的消息</div>
                <div class="recalled-message-content" id="recalledMessageContent"></div>
                <button class="recalled-message-close" onclick="closeRecalledMessagePopup()">关闭</button>
            </div>

            <div id="chatSettingsScreen" class="page">
                <div class="nav-bar">
                    <button class="nav-btn" onclick="backToChat()">←</button>
                    <div class="nav-title">聊天设置</div>
                    <div></div>
                </div>
                <div class="chat-settings-content">
                    <div class="settings-menu-item" onclick="openFriendOrGroupSettings()"><span>好友与群聊设置</span><span>></span></div>
                    <div class="settings-menu-item" onclick="togglePinChat()"><span id="pinChatText">置顶聊天</span></div>
                    <div class="settings-menu-item" onclick="openBackgroundSettings()"><span>聊天背景</span><span>></span></div>
                    <div class="settings-menu-item" onclick="openChatSearch()"><span>查找聊天记录</span><span>></span></div>
                    <div class="settings-menu-item" onclick="clearChatHistory()"><span>清空聊天记录</span></div>
                    <div style="margin-top: 20px;">
                        <div class="settings-menu-item danger" onclick="deleteFriend()"><span>删除并退出</span></div>
                    </div>
                </div>
            </div>

            <div id="chatSearchScreen" class="page">
                <div class="nav-bar">
                    <button class="nav-btn" onclick="backToChatSettings()">←</button>
                    <div class="nav-title">查找聊天记录</div>
                    <div></div>
                </div>
                <div class="settings-content" style="position: relative; height: 100%;">
                    <div class="form-group" style="position: relative;">
                        <input type="text" class="form-input" id="searchInput" placeholder="输入关键词搜索..." oninput="searchChatHistory()">
                        <div class="search-results" id="searchResults"></div>
                    </div>
                </div>
            </div>

            <div id="friendSettingsScreen" class="page">
                <div class="nav-bar">
                    <button class="nav-btn" onclick="backToChatSettings()">←</button>
                    <div class="nav-title">好友设置</div>
                    <div></div>
                </div>
                <div class="settings-content">
                     <div class="form-group" id="editFriendAvatarGroup">
                        <label class="form-label">好友头像</label>
                        <div class="avatar-upload" id="editFriendAvatarUpload" style="margin: 0 auto 15px;">
                            <input type="file" accept="image/*" onchange="handleEditFriendAvatarUpload(event)">
                            <span id="editFriendAvatarPreview"></span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" id="editFriendNameLabel">好友昵称</label>
                        <input type="text" class="form-input" id="editFriendName" placeholder="好友/群聊昵称">
                    </div>
                    <div class="form-group" id="editFriendRemarkGroup">
                        <label class="form-label">备注名称</label>
                        <input type="text" class="form-input" id="editFriendRemark" placeholder="备注名称">
                    </div>
                    <div class="form-group" id="editFriendPatGroup">
                        <label class="form-label">拍一拍动作</label>
                        <input type="text" class="form-input" id="editFriendPatAction" placeholder="例如：的头，并说“你好可爱”">

                    </div>
                    <div class="form-group" id="editFriendRoleGroup">
                        <label class="form-label">角色设定</label>
                        <textarea class="form-textarea" id="editFriendRole" placeholder="角色设定..."></textarea>
                    </div>
                    <div class="form-group" id="worldBookBindingGroup">
                        <label class="form-label">绑定世界书</label>
                        <div class="form-input" style="cursor: pointer; line-height: 2.5;" onclick="openWorldBookBindingModal()">点击选择</div>
                    </div>
                    <!-- ↓↓↓ 核心修改：为ID添加后缀 "_Friend" ↓↓↓ -->
<div class="form-group" id="selectPersonaItemGroup_Friend" style="display: none;">
    <label class="form-label">选择我的人设</label>
    <div class="form-input" style="cursor: pointer; line-height: 2.5;" onclick="openPersonaSelectModal()">
        点击选择
    </div>
</div>
<!-- ↑↑↑ 修改结束 ↑↑↑ -->
                    <div class="settings-buttons">
                        <button class="settings-btn btn-primary" onclick="saveFriendSettings()">保存设置</button>
                    </div>
                </div>
            </div>
            
            <!-- ↓↓↓ 请从这里开始复制 ↓↓↓ -->

            <div id="groupSettingsScreen" class="page">
                <div class="nav-bar">
                    <button class="nav-btn" onclick="backToChatSettings()">←</button>
                    <div class="nav-title">群聊设置</div>
                    <div></div>
                </div>
                <div class="settings-content">
                    <!-- 群聊头像设置 -->
                    <div class="form-group">
                        <label class="form-label">群聊头像</label>
                        <div class="avatar-upload" id="editGroupAvatarUpload" style="margin: 0 auto 15px;">
                            <input type="file" accept="image/*" onchange="handleEditGroupAvatarUpload(event)">
                            <span id="editGroupAvatarPreview"></span>
                        </div>
                    </div>
                    <!-- 群聊名称设置 -->
                    <div class="form-group">
                        <label class="form-label">群聊名称</label>
                        <input type="text" class="form-input" id="editGroupName" placeholder="群聊名称">
                    </div>
                    <!-- 群成员列表 -->
                    <div class="form-group">
                        <label class="form-label">群成员</label>
                        <div id="groupMembersList" class="friend-list" style="max-height: 200px; overflow-y: auto; background-color: var(--bg-hover);">
                            <!-- 群成员将在这里动态生成 -->
                        </div>
                    </div>
                    <!-- 绑定世界书 -->
                    <div class="form-group">
                        <label class="form-label">绑定世界书</label>
                        <div class="form-input" style="cursor: pointer; line-height: 2.5;" onclick="openWorldBookBindingModal()">点击选择</div>
                    </div>
                   
                    <!-- ↓↓↓ 核心修改：为ID添加后缀 "_Group" ↓↓↓ -->
<div class="form-group" id="selectPersonaItemGroup_Group" style="display: none;">
    <label class="form-label">选择我的人设</label>
    <div class="form-input" style="cursor: pointer; line-height: 2.5;" onclick="openPersonaSelectModal()">
        点击选择
    </div>
</div>
<!-- ↑↑↑ 修改结束 ↑↑↑ -->

<!-- 保存按钮 -->
                    <div class="settings-buttons">
                        <button class="settings-btn btn-primary" onclick="saveGroupSettings()">保存设置</button>
                    </div>
                </div>
            </div>

<!-- ↑↑↑ 请在这里结束复制 ↑↑↑ -->

            <div id="backgroundSettingsScreen" class="page">
                <div class="nav-bar">
                    <button class="nav-btn" onclick="backToChatSettings()">←</button>
                    <div class="nav-title">聊天背景</div>
                    <div></div>
                </div>
                <div class="modal-content-container">
                    <div class="modal-content">
                        <div class="background-grid" id="individualBgGrid">
                            <div class="background-option default" onclick="selectBackground('default')"><span>默认</span></div>
                            <div class="background-option background-upload"><input type="file" accept="image/*" onchange="handleBackgroundUpload(event)"><span>上传</span></div>
                        </div>
                        <div class="modal-buttons" style="margin-top: 20px;">
                            <button class="modal-btn modal-btn-cancel" onclick="backToChatSettings()">取消</button>
                            <button class="modal-btn modal-btn-confirm" onclick="saveBackground()">保存</button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="personalSettingsScreen" class="page">
                <div class="nav-bar">
                    <button class="nav-btn" onclick="backToProfile()">←</button>
                    <div class="nav-title">人设与背景</div>
                    <div></div>
                </div>
                <div class="settings-content">
                    <div class="form-group"><label class="form-label">我的人设</label><textarea class="form-textarea" id="userPersonality" placeholder="请描述你的个性、特点、喜好等..." style="min-height: 100px;"></textarea></div>
                    <div class="form-group"><label class="form-label">背景设定</label><textarea class="form-textarea" id="userBackground" placeholder="请描述你的背景、经历、职业等..." style="min-height: 100px;"></textarea></div>
                    <div class="form-group"><label class="form-label">我的拍一拍动作</label><input type="text" class="form-input" id="userPatAction" placeholder="例如：拍了拍"></div>
                    <div class="settings-buttons"><button class="settings-btn btn-primary" onclick="savePersonalSettings()">保存设置</button></div>
                </div>
            </div>

            <div id="mySettingsScreen" class="page">
                <div class="nav-bar">
                    <button class="nav-btn" onclick="backToProfile()">←</button>
                    <div class="nav-title">设置</div>
                    <div></div>
                </div>
                <div class="discover-content">
                    <div class="discover-menu">
                        <div class="discover-menu-item" onclick="openGlobalChatBg()"><div class="discover-menu-left"><svg class="discover-menu-icon" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2M12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20A8,8 0 0,0 20,12A8,8 0 0,0 12,4Z"/></svg><div class="discover-menu-title">全局聊天背景</div></div><span>></span></div>
                        <div class="discover-menu-item" onclick="openBubbleSettings()"><div class="discover-menu-left"><svg class="discover-menu-icon" viewBox="0 0 24 24"><path d="M12,2C6.47,2 2,6.47 2,12C2,17.53 6.47,22 12,22C17.53,22 22,17.53 22,12C22,6.47 17.53,2 12,2M15.04,7.5L15.5,8.96L16.96,9.5L15.5,10.04L15.04,11.5L14.5,10.04L13.04,9.5L14.5,8.96L15.04,7.5M12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9M12,17.5C14.33,17.5 16.31,16.04 17.11,14H6.89C7.69,16.04 9.67,17.5 12,17.5Z"/></svg><div class="discover-menu-title">气泡设置</div></div><span>></span></div>
                        <div class="discover-menu-item"><div class="discover-menu-left"><svg class="discover-menu-icon" viewBox="0 0 24 24"><path d="M19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5A2,2 0 0,0 19,3Z" /></svg><div class="discover-menu-title">圆角模式</div></div><label class="toggle-switch"><input type="checkbox" id="roundedToggle" onchange="toggleRoundedCorners()"><span class="toggle-slider"></span></label></div>
                        <div class="discover-menu-item"><div class="discover-menu-left"><svg class="discover-menu-icon" viewBox="0 0 24 24"><path d="M12,18C8.69,18 6,15.31 6,12C6,8.69 8.69,6 12,6C15.31,6 18,8.69 18,12C18,15.31 15.31,18 12,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,7A5,5 0 0,0 7,12A5,5 0 0,0 12,17A5,5 0 0,0 17,12A5,5 0 0,0 12,7Z"/></svg><div class="discover-menu-title">夜间模式</div></div><label class="toggle-switch"><input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode()"><span class="toggle-slider"></span></label></div>
                    </div>
                </div>
            </div>

            <div id="bubbleSettingsScreen" class="page">
                <div class="nav-bar">
                    <button class="nav-btn" onclick="backToMySettings()">←</button>
                    <div class="nav-title">气泡设置</div>
                    <div></div>
                </div>
                <div class="modal-content-container">
                    <div class="modal-content">
                        <div class="bubble-settings">
                            <div class="bubble-color-group"><div class="bubble-color-label">我的气泡颜色</div><div class="bubble-color-row"><input type="color" class="bubble-color-picker" id="sentBubbleColorPicker" value="#FFEEF6" oninput="updateSentBubbleColor(this.value)"><input type="text" class="bubble-color-input" id="sentBubbleColorInput" value="#FFEEF6" placeholder="#FFEEF6" oninput="updateSentBubbleColorFromInput(this.value)"></div></div>
                            <div class="bubble-color-group"><div class="bubble-color-label">对方气泡颜色</div><div class="bubble-color-row"><input type="color" class="bubble-color-picker" id="receivedBubbleColorPicker" value="#E6F2FF" oninput="updateReceivedBubbleColor(this.value)"><input type="text" class="bubble-color-input" id="receivedBubbleColorInput" value="#E6F2FF" placeholder="#E6F2FF" oninput="updateReceivedBubbleColorFromInput(this.value)"></div></div>
                            <div class="bubble-css-group"><div class="bubble-color-label">自定义CSS样式</div> <textarea class="bubble-css-textarea" id="bubbleCustomCSS" 
    placeholder="在此输入CSS，格式如下：

/* “我”的气泡 */
.message.sent .message-content {
  background: #C7F7C7;
  border-radius: 5px;
}

/* “对方”的气泡 */
.message.received .message-content {
  background: #EFEFEF;
}" 
    oninput="applyCustomBubbleCSS(this.value)"></textarea> </div>
                            <div class="bubble-css-group"><div class="bubble-color-label">气泡预览</div><div class="bubble-preview-area" id="bubblePreviewArea"><div class="message received"><div class="chat-avatar">TA</div><div class="message-content">这是对方的气泡样式。</div></div><div class="message sent"><div class="message-content">这是你的气泡样式。</div><div class="chat-avatar">我</div></div></div></div>
                        </div>
                        <div class="modal-buttons" style="margin-top: 20px;"> <button class="modal-btn modal-btn-cancel" onclick="cancelBubbleSettings()">取消</button> <button class="modal-btn modal-btn-confirm" onclick="saveBubbleSettings()">保存</button></div>
                    </div>
                </div>
            </div>

            <div id="globalChatBgScreen" class="page">
                <div class="nav-bar">
                    <button class="nav-btn" onclick="backToMySettings()">←</button>
                    <div class="nav-title">全局聊天背景</div>
                    <div></div>
                </div>
                 <div class="modal-content-container">
                    <div class="modal-content">
                        <div class="background-grid" id="globalBgGrid">
                            <div class="background-option default" onclick="selectGlobalChatBg('default')"><span>默认</span></div>
                            <div class="background-option background-upload"><input type="file" accept="image/*" onchange="handleGlobalChatBgUpload(event)"><span>上传</span></div>
                        </div>
                        <div class="modal-buttons" style="margin-top: 20px;"><button class="modal-btn modal-btn-cancel" onclick="backToMySettings()">取消</button><button class="modal-btn modal-btn-confirm" onclick="saveGlobalChatBg()">保存</button></div>
                    </div>
                </div>
            </div>

            <div id="walletScreen" class="page"><div class="nav-bar"><button class="nav-btn" onclick="backToProfile()">←</button><div class="nav-title">钱包</div><div></div></div><div class="settings-content"><div class="balance-display"><div class="balance-amount" id="balanceAmount">¥ 0.00</div><div class="balance-label">余额</div></div><div class="wallet-menu"><div class="wallet-menu-item" onclick="rechargeWallet()"><span>💳 充值</span><span>></span></div><div class="wallet-menu-item" onclick="withdrawWallet()"><span>💰 提现</span><span>></span></div><div class="wallet-menu-item" onclick="transferWallet()"><span>💸 转账</span><span>></span></div><div class="wallet-menu-item" onclick="walletHistory()"><span>📋 账单</span><span>></span></div></div></div></div>
            <div id="favoritesScreen" class="page"><div class="nav-bar"><button class="nav-btn" onclick="backToProfile()">←</button><div class="nav-title">收藏</div><button class="nav-btn" onclick="toggleSelectMode()">选择</button></div><div class="select-mode" id="selectMode"><span id="selectedCount">已选择 0 项</span><button class="select-btn" onclick="deleteSelectedFavorites()">删除</button></div><div class="wechat-content"><div class="favorite-list" id="favoriteList"></div></div></div>
            <div id="worldBookScreen" class="page"><div class="nav-bar"><button class="nav-btn" onclick="goHome()">←</button><div class="nav-title">世界书</div><div style="display: flex; align-items: center;"><button class="nav-btn" onclick="openAddWorldBookFolderModal()"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg></button><button class="nav-btn" onclick="openAddWorldBook()">+</button></div></div><div class="wechat-content"><div class="worldbook-list" id="worldBookList"></div></div></div>
            <div id="momentsScreen" class="page"><div class="nav-bar"><button class="nav-btn" onclick="backToDiscover()">←</button><div class="nav-title">朋友圈</div><button class="nav-btn" onclick="openAddMoment()">+</button></div><div class="wechat-content"><div id="momentsList"></div></div></div>
            
            <div id="diaryScreen" class="page">
                <div class="nav-bar">
                    <button class="nav-btn" onclick="backToDiscover()">←</button>
                    <div class="nav-title">日记</div>
                    <div id="diaryNavFriendName"></div>
                </div>
                <div class="diary-content-view">
                    <div id="diaryFriendList" class="friend-list"></div>
                    <div id="diaryContentArea" class="diary-list"></div>
                </div>
            </div>

            <div id="themeApp" class="page">
                <div class="nav-bar">
                    <button class="nav-btn" onclick="goHome()">←</button>
                    <div class="nav-title">主题设置</div>
                    <div></div>
                </div>
                <div class="discover-content">
                    <div class="discover-menu">
                        <div class="discover-menu-item" onclick="openFontSettings()"><div class="discover-menu-left"><svg class="discover-menu-icon" viewBox="0 0 24 24"><path d="M2.5,4V6.5H6V20H8.5V6.5H12V4H2.5M13.5,4L12,20H14.5L15.2,14H18.8L19.5,20H22L20.5,4H13.5M15.8,6.5H18.2L18.5,11.5H15.5L15.8,6.5Z"/></svg><div class="discover-menu-title">字体设置</div></div><span>></span></div>
                        <div class="discover-menu-item" onclick="openWallpaperSettings()"><div class="discover-menu-left"><svg class="discover-menu-icon" viewBox="0 0 24 24"><path d="M4,4H7L9,2H15L17,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M12,7A5,5 0 0,0 7,12A5,5 0 0,0 12,17A5,5 0 0,0 17,12A5,5 0 0,0 12,7M12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9Z"/></svg><div class="discover-menu-title">主屏幕壁纸</div></div><span>></span></div>
                        <div class="discover-menu-item" onclick="openIconSettings()"><div class="discover-menu-left"><svg class="discover-menu-icon" viewBox="0 0 24 24"><path d="M17.5,12A1.5,1.5 0 0,1 16 10.5A1.5,1.5 0 0,1 17.5,12M14.5,8A1.5,1.5 0 0,1 13,6.5A1.5,1.5 0 0,1 14.5,5A1.5,1.5 0 0,1 16,6.5A1.5,1.5 0 0,1 9.5,8M6.5,12A1.5,1.5 0 0,1 5,10.5A1.5,1.5 0 0,1 6.5,9A1.5,1.5 0 0,1 8,10.5A1.5,1.5 0 0,1 6.5,12M12,3A9,9 0 0,0 3,12A9,9 0 0,0 12,21A9,9 0 0,0 21,12A9,9 0 0,0 12,3Z"/></svg><div class="discover-menu-title">图标设置</div></div><span>></span></div>
                        <div class="discover-menu-item" onclick="openComponentSettings()"><div class="discover-menu-left"><svg class="discover-menu-icon" viewBox="0 0 24 24"
                        fill="currentColor"><path d="M19 5v2h-4V5h4M9 5v6H5V5h4m10 8v6h-4v-6h4M9 17v2H5v-2h4M21 3h-8v6h8V3M11 3H3v10h8V3m10 8h-8v10h8V11m-10 4H3v6h8v-6Z"/></svg><div class="discover-menu-title">组件设置</div></div><span>></span></div>
                    </div>
                </div>
            </div>

            <div id="fontSettingsScreen" class="page"><div class="nav-bar"><button class="nav-btn" onclick="backToTheme()">←</button><div class="nav-title">字体设置</div><div></div></div> <div class="settings-content"><div class="font-options"><div class="font-option system selected" onclick="selectFont('system')"><div style="font-size: 18px; margin-bottom: 5px;">系统默认字体</div><div style="font-size: 14px; color: #666;">苹方/微软雅黑</div></div><div class="font-option custom" onclick="selectFont('custom')"><div style="font-size: 18px; margin-bottom: 5px;">自定义字体</div><div style="font-size: 14px; color: #666;">使用自定义字体URL</div></div></div><div class="font-url-control"><div class="bubble-color-label">自定义字体URL (TTF, OTF, WOFF)</div><input type="text" class="font-url-input" id="fontUrlInput" placeholder="输入字体文件URL..." oninput="applyCustomFont(this.value)"></div><div class="font-size-control"><span>字体大小:</span><input type="range" class="font-size-slider" id="fontSizeSlider" min="12" max="24" value="14" oninput="adjustFontSize(this.value)"><span id="fontSizeValue">14px</span></div><div class="font-color-control"><span>字体颜色:</span><input type="color" class="color-picker" id="fontColorPicker" value="#000000" onchange="updateFontColor(this.value)"><input type="text" class="color-code-input" id="fontColorInput" value="#000000" placeholder="#000000" oninput="updateFontColorFromInput(this.value)"></div> <!-- 新增：App标签颜色控制器 -->
<div class="font-color-control">
    <span>App字体颜色:</span>
    <input type="color" class="color-picker" id="appLabelColorPicker" value="#333333" onchange="updateAppLabelColor(this.value)">
    <input type="text" class="color-code-input" id="appLabelColorInput" value="#333333" placeholder="#333333" oninput="updateAppLabelColorFromInput(this.value)">
</div> <div class="modal-buttons" style="margin-top: 20px;"><button class="modal-btn modal-btn-cancel" onclick="backToTheme()">取消</button><button class="modal-btn modal-btn-confirm" onclick="saveFont()">保存</button></div></div></div>
            <div id="wallpaperSettingsScreen" class="page"><div class="nav-bar"><button class="nav-btn" onclick="backToTheme()">←</button><div class="nav-title">主屏幕壁纸</div><div></div></div><div class="modal-content-container"><div class="modal-content"><div class="background-grid" id="wallpaperGrid"><div class="background-option default" onclick="selectWallpaper('default')"><span>默认</span></div><div class="background-option background-upload"><input type="file" accept="image/*" onchange="handleWallpaperUpload(event)"><span>上传</span></div></div><div class="modal-buttons" style="margin-top: 20px;"><button class="modal-btn modal-btn-cancel" onclick="backToTheme()">取消</button><button class="modal-btn modal-btn-confirm" onclick="saveWallpaper()">保存</button></div></div></div></div>
            <div id="iconSettingsScreen" class="page"><div class="nav-bar"><button class="nav-btn" onclick="backToTheme()">←</button><div class="nav-title">图标设置</div><div></div></div><div class="settings-content"><div id="iconSettingsList"></div><div class="settings-buttons" style="margin-top: 20px;"><button class="settings-btn btn-danger" onclick="restoreDefaultIcons()">恢复默认</button></div></div></div>
            
            <!-- NEW: Component Settings Page (FIXED) -->
<div id="componentSettingsScreen" class="page">
    <div class="nav-bar">
        <button class="nav-btn" onclick="backToTheme()">←</button>
        <div class="nav-title">组件设置</div>
        <div></div>
    </div>
    <div class="discover-content">
        <div class="discover-menu">
            <!-- 新增：个人信息组件透明开关 -->
            <div class="discover-menu-item">
                <div class="discover-menu-title">个人信息组件背景透明</div>
                <label class="toggle-switch">
                    <input type="checkbox" id="profileWidgetBgToggle" onchange="toggleProfileWidgetBg()">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <!-- 新增：小组件透明开关 -->
            <div class="discover-menu-item">
                <div class="discover-menu-title">小组件背景透明</div>
                <label class="toggle-switch">
                    <input type="checkbox" id="smallWidgetBgToggle" onchange="toggleSmallWidgetBg()">
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>
    </div>
</div>
            
            <div id="settingsApp" class="page">
                <div class="nav-bar">
                    <button class="nav-btn" onclick="goHome()">←</button>
                    <div class="nav-title">设置</div>
                    <div></div>
                </div>
                <div class="discover-content">
                    <!-- 【【【请用这个修正后的完整代码块，替换掉您文件中对应的整个 discover-menu 部分】】】 -->

<div class="discover-menu">
    <!-- 第一个设置项：API 设置 -->
    <div class="discover-menu-item" onclick="openApiSettings()">
        <div class="discover-menu-title">API 设置</div>
        <span>></span>
    </div>   
    
    <!-- 【【【新增代码：记忆生成设置】】】 -->
<div class="discover-menu-item">
    <div class="discover-menu-title">记忆生成轮数</div>
    <!-- 这个输入框让你可以设置每多少轮对话生成一次记忆 -->
    <input type="number" id="memoryGenerationTurnsInput" class="settings-input-number" min="1" placeholder="例如: 20">
</div>
<!-- 【【【新增代码结束】】】 -->

    <!-- 第三个设置项：导入数据 (这是一个独立的项) -->
    <div class="discover-menu-item" onclick="importData()">
        <div class="discover-menu-title">导入数据</div>
        <span>></span>
    </div>

    <!-- 第四个设置项：导出数据 (这是一个独立的项) -->
    <div class="discover-menu-item" onclick="exportData()">
        <div class="discover-menu-title">导出数据</div>
        <span>></span>
    </div>
</div>
                </div>
            </div>
            
            <!-- 新增的记忆查看页面 -->
<div id="memoryScreen" class="page">
    <div class="nav-bar">
        <button class="nav-btn" onclick="backToChat()">←</button>
        <div class="nav-title" id="memoryTitle">角色的记忆</div>
        <div></div> <!-- 右侧占位 -->
    </div>
    <div class="wechat-content">
        <div id="memoryList" class="diary-list">
            <!-- 记忆内容将在这里动态生成 -->
        </div>
    </div>
</div>

            <div id="apiSettingsScreen" class="page"><div class="nav-bar"><button class="nav-btn" onclick="backToSettingsMenu()">←</button>
                    <div class="nav-title">API设置</div>
                    <div></div>
                </div>
                <div class="settings-content">
                    <div class="form-group"><label class="form-label">API反代地址</label><input type="text" class="form-input" id="apiUrl" placeholder="https://api.example.com/v1"></div>
                    <div class="form-group"><label class="form-label">API密钥</label><input type="password" class="form-input" id="apiKey" placeholder="sk-..."></div>
                    <div class="form-group"><label class="form-label">模型名称</label>
                        <div class="model-select-container">
                            <input type="text" class="model-select" id="modelName" placeholder="选择或输入模型名称" readonly onclick="toggleModelDropdown()">
                            <span class="dropdown-arrow">▼</span>
                            <div class="model-dropdown" id="modelDropdown"></div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="memoryTurns">记忆轮数 (0-1000)</label>
                        <input type="number" class="form-input" id="memoryTurns" placeholder="默认 10" min="0" max="1000">
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="apiTemperature">Temperature (0.0 - 2.0)</label>
                        <input type="number" class="form-input" id="apiTemperature" placeholder="默认 0.9" min="0" max="2" step="0.1">
                    </div>
                    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                        <label class="form-label" style="margin-bottom: 0;">开启AI时间感知</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="aiTimePerceptionToggle" onchange="toggleTimePerception()">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="settings-buttons">
                        <button class="settings-btn btn-secondary" onclick="fetchModels()">拉取模型</button>
                        <button class="settings-btn btn-primary" onclick="saveApiSettings()">保存设置</button>
                    </div>
                </div>
            </div>
            
            <!-- MODIFIED: Phone App Page -->
            <!-- 用这段新代码替换 -->
<div id="phoneApp" class="page">
    <div class="nav-bar" id="phoneAppNavBar">
        <button class="nav-btn" onclick="goHome()">←</button>
        <div class="nav-title">手机</div>
        <!-- 新增了一个重新生成按钮，并给予了ID和点击事件 -->
        <div>
            <button class="nav-btn" id="regenerateSimContentBtn" style="display: none;" onclick="handleSimRegenerateClick()">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
                    <path d="M22 4v4h-4"/>
                </svg>
            </button>
        </div>
    </div>
    
                <div class="phone-app-container">
                    <div id="phoneCharacterListScreen" class="friend-list">
                        <!-- Character list will be rendered here -->
                    </div>
                    <div id="simulatedPhoneScreen" style="display: none;">
                        <div class="sim-phone-frame">
                            <div class="sim-phone-screen">
                                <div class="sim-phone-screen-content" id="sim-home-screen-content">
                                    <div class="sim-app-grid">
                                        <!-- Sim App Icons -->
                                        <a class="sim-app-icon" onclick="openSimApp('wechat')">
                                            <div class="sim-app-icon-img">
                                                <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 5.79 2 10.5C2 13.6 3.66 16.34 6.34 17.91L5.5 21.5L9.67 19.33C10.42 19.53 11.2 19.65 12 19.65C17.52 19.65 22 15.86 22 11.15C22 6.44 17.52 2.65 12 2.65M8.5 13.15A1.5 1.5 0 1 1 7 11.65A1.5 1.5 0 0 1 8.5 13.15M15.5 13.15A1.5 1.5 0 1 1 14 11.65A1.5 1.5 0 0 1 15.5 13.15Z"/></svg>
                                            </div>
                                            <span class="sim-app-icon-label">微信</span>
                                        </a>
                                        <a class="sim-app-icon" onclick="openSimApp('memo')">
                                            <div class="sim-app-icon-img">
                                                <svg viewBox="0 0 24 24"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" /></svg>
                                            </div>
                                            <span class="sim-app-icon-label">备忘录</span>
                                        </a>
                                        <a class="sim-app-icon" onclick="openSimApp('phone_call')">
                                            <div class="sim-app-icon-img">
                                                <svg viewBox="0 0 24 24"><path d="M6.62,10.79C8.06,13.62 10.38,15.94 13.21,17.38L15.41,15.18C15.69,14.9 16.08,14.82 16.43,14.93C17.55,15.3 18.75,15.5 20,15.5A1,1 0 0,1 21,16.5V20A1,1 0 0,1 20,21A17,17 0 0,1 3,4A1,1 0 0,1 4,3H7.5A1,1 0 0,1 8.5,4C8.5,5.25 8.7,6.45 9.07,7.57C9.18,7.92 9.1,8.31 8.82,8.59L6.62,10.79Z"/></svg>
                                            </div>
                                            <span class="sim-app-icon-label">电话</span>
                                        </a>
                                        <a class="sim-app-icon" onclick="openSimApp('browser')">
                                            <div class="sim-app-icon-img">
                                                <svg viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M19.1,4.9C19.1,4.9 19.1,4.9 19.1,4.9L17,8H13.6C13.5,7.2 13.2,6.5 12.8,5.8L15.6,3.4C16.9,3.8 18.1,4.3 19.1,4.9M12,10A2,2 0 1,1 14,12A2,2 0 0,1 12,10M4.9,19.1C4.9,19.1 4.9,19.1 4.9,19.1L7,16H10.4C10.5,16.8 10.8,17.5 11.2,18.2L8.4,20.6C7.1,20.2 5.9,19.7 4.9,19.1M4.9,4.9C5.9,4.3 7.1,3.8 8.4,3.4L11.2,5.8C10.8,6.5 10.5,7.2 10.4,8H7L4.9,4.9M15.6,20.6L12.8,18.2C13.2,17.5 13.5,16.8 13.6,16H17L19 .1,19.1C18.1,19.7 16.9,20.2 15.6,20.6Z" /></svg>
                                            </div>
                                            <span class="sim-app-icon-label">浏览器</span>
                                        </a>
                                        <a class="sim-app-icon" onclick="openSimApp('shopping')">
                                            <div class="sim-app-icon-img">
                                                <svg viewBox="0 0 24 24"><path d="M17,18C17,18.55 16.55,19 16,19S-1-.45-1-1 .45-1 1-1 1,.45 1,1M7,18C7,18.55 7.45,19 8,19S9,18.55 9,18 8.55,17 8,17 7,17.45 7,18M1,2V4H3L6.6,11.59L5.25,14.04 C5.09,14.32 5,14.65 5,15A2,2 0 0,0 7,17H19V15H7.42C7.29,15 7.17,14.89 7.17,14.75L7.2,14.63L8.1,13H15.55C16.3,13 16.96,12.59 17.3,11.97L20.88,5.5C20.95,5.34 21,5.17 21,5A1,1 0 0,0 20,4H5.21L4.27,2H1Z"/></svg>
                                            </div>
                                            <span class="sim-app-icon-label">购物</span>
                                        </a>
                                        <a class="sim-app-icon" onclick="openSimApp('wallet')">
                                            <div class="sim-app-icon-img">
                                                <svg viewBox="0 0 24 24"><path d="M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6A2,2 0 0,0 20,4M13,16H11V14H9V12H11V10H13V12H15V14H13V16M18,10H16V8H18V10M6,8H8V10H6V8Z" /></svg>
                                            </div>
                                            <span class="sim-app-icon-label">钱包</span>
                                        </a>
                                         <a class="sim-app-icon" onclick="openSimApp('photos')">
                                            <div class="sim-app-icon-img">
                                               <svg viewBox="0 0 24 24"><path d="M21,19V5C21,3.89 20.1,3 19,3H 5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19M8.5,13.5L11,16.5L14.5,12L19,18H5L8.5,13.5Z" /></svg>
                                            </div>
                                            <span class="sim-app-icon-label">相册</span>
                                        </a>
                                        <!-- [新增] 论坛App图标 -->
<a class="sim-app-icon" onclick="openSimApp('forum')">
    <div class="sim-app-icon-img">
        <svg viewBox="0 0 24 24">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14H9v-2h2v2zm0-4H9V7h2v5zm4 4h-2v-2h2v2zm0-4h-2V7h2v5z"/>
        </svg>
    </div>
    <span class="sim-app-icon-label">论坛</span>
</a>
                                    </div>
                                </div>
                                
                                <!-- Sim App Views -->
                                <div class="sim-app-view" id="sim-wechat-view"></div>
                                <div class="sim-app-view" id="sim-memo-view"></div>
                                <div class="sim-app-view" id="sim-phone_call-view"></div>
                                <div class="sim-app-view" id="sim-browser-view"></div>
                                <div class="sim-app-view" id="sim-shopping-view"></div>
                                <div class="sim-app-view" id="sim-wallet-view"></div>
                                <div class="sim-app-view" id="sim-photos-view"></div>
                                <!-- [新增] 论坛App的视图容器 -->
<div class="sim-app-view" id="sim-forum-view"></div>
<div class="sim-app-view" id="sim-forum-detail-view"></div>
                                <!-- Sim App Detail Views (These will be populated by renderSimApp) -->
                                <div class="sim-app-view" id="sim-wechat-detail-view"></div>
                                <div class="sim-app-view" id="sim-memo-detail-view"></div>
                                <div class="sim-app-view" id="sim-browser-detail-view"></div>
                                <div class="sim-app-view" id="sim-shopping-detail-view"></div>
                                <div class="sim-app-view" id="sim-photos-detail-view"></div>

                            </div>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>
    
    <div id="addGroupChatModal" class="modal"><div class="modal-content"><div class="modal-title">选择联系人</div><div id="groupChatFriendList" class="multi-select-list" style="max-height: 300px;"></div><div class="modal-buttons" style="margin-top: 15px;"><button class="modal-btn modal-btn-cancel" onclick="closeGroupChatModal()">取消</button><button class="modal-btn modal-btn-confirm" onclick="createGroupChat()">确定</button></div></div></div>
    <div id="addFriendModal" class="modal"><div class="modal-content"><div class="modal-title">添加好友</div><div class="avatar-upload" id="friendAvatarUpload"><input type="file" accept="image/*"

onchange="handleFriendAvatarUpload(event)"><span id="friendAvatarPreview">+</span></div><input type="text" class="modal-input" id="friendNameInput" placeholder="好友昵称（必填）"><input type="text" class="modal-input" id="friendRemarkInput" placeholder="备注名称（可选）"><textarea class="modal-textarea" id="friendRoleInput" placeholder="角色设定（可选）...&#10;例如：你是一个可爱的猫娘，性格活泼开朗，喜欢用'喵'结尾说话..."></textarea><div class="modal-buttons"><button class="modal-btn modal-btn-cancel" onclick="closeAddFriendModal()">取消</button><button class="modal-btn modal-btn-confirm" onclick="addNewFriend()">添加</button></div></div></div>
    <div id="nameModal" class="modal"><div class="modal-content"><div class="modal-title">修改昵称</div><input type="text" class="modal-input" id="newNameInput" placeholder="请输入新昵称"><div class="modal-buttons"><button class="modal-btn modal-btn-cancel" onclick="closeNameModal()">取消</button><button class="modal-btn modal-btn-confirm" onclick="confirmChangeName()">确定</button></div></div></div>
    <div id="textEditModal" class="modal"><div class="modal-content"><div class="modal-title" id="textEditTitle">编辑文字</div><input type="text" class="modal-input" id="newTextInput" placeholder="请输入新内容"><div class="modal-buttons"><button class="modal-btn modal-btn-cancel" onclick="closeTextEditModal()">取消</button><button class="modal-btn modal-btn-confirm" onclick="confirmTextEdit()">确定</button></div></div></div>
    <div id="avatarModal" class="modal"><div class="modal-content"><div class="modal-title">更换头像</div><div class="avatar-upload" id="userAvatarUpload"><input type="file" accept="image/*" onchange="handleUserAvatarUpload(event)"><span id="userAvatarPreview">+</span></div><div class="modal-buttons"><button class="modal-btn modal-btn-cancel" onclick="closeAvatarModal()">取消</button><button class="modal-btn modal-btn-confirm" onclick="confirmChangeAvatar()">确定</button></div></div></div>
    <div id="addWorldBookModal" class="modal"><div class="modal-content"><div class="modal-title">添加世界书</div><input type="text" class="modal-input" id="worldBookNameInput" placeholder="世界书昵称"><div class="form-group"><select class="form-select" id="worldBookFolderSelect"></select></div><textarea class="modal-textarea" id="worldBookContentInput" placeholder="世界书内容..." style="min-height: 120px;"></textarea><div class="modal-buttons"><button class="modal-btn modal-btn-cancel" onclick="closeAddWorldBookModal()">取消</button><button class="modal-btn modal-btn-confirm" onclick="addNewWorldBook()">添加</button></div></div></div>
    <div id="editWorldBookModal" class="modal"><div class="modal-content"><div class="modal-title">编辑世界书</div><input type="text" class="modal-input" id="editWorldBookNameInput" placeholder="世界书昵称"><div class="form-group"><select class="form-select" id="editWorldBookFolderSelect"></select></div><textarea class="modal-textarea" id="editWorldBookContentInput" placeholder="世界书内容..." style="min-height: 120px;"></textarea><div class="modal-buttons"><button class="modal-btn modal-btn-cancel" onclick="closeEditWorldBookModal()">取消</button><button class="modal-btn modal-btn-confirm" id="saveWorldBookEditBtn">保存</button></div></div></div>
    <div id="addWorldBookFolderModal" class="modal"><div class="modal-content"><div class="modal-title">新建文件夹</div><input type="text" class="modal-input" id="worldBookFolderNameInput" placeholder="文件夹名称"><div class="modal-buttons"><button class="modal-btn modal-btn-cancel" onclick="closeAddWorldBookFolderModal()">取消</button><button class="modal-btn modal-btn-confirm" onclick="addNewWorldBookFolder()">创建</button></div></div></div>
    <div id="signatureModal" class="modal"><div class="modal-content"><div class="modal-title">修改个性签名</div><input type="text" class="modal-input" id="newSignatureInput" placeholder="请输入新的个性签名"><div class="modal-buttons"><button class="modal-btn modal-btn-cancel" onclick="closeSignatureModal()">取消</button><button class="modal-btn modal-btn-confirm" onclick="confirmChangeSignature()">确定</button></div></div></div>
    <div id="locationModal" class="modal"><div class="modal-content"><div class="modal-title">修改地区</div><input type="text" class="modal-input" id="newLocationInput" placeholder="请输入地区"><div class="modal-buttons"><button class="modal-btn modal-btn-cancel" onclick="closeLocationModal()">取消</button><button class="modal-btn modal-btn-confirm" onclick="confirmChangeLocation()">确定</button></div></div></div>
    <div id="cameraModal" class="modal"><div class="modal-content"><div class="modal-title">AI拍摄</div><textarea class="modal-textarea" id="cameraDescInput" placeholder="请描述你要拍摄的内容...&#10;例如：一只可爱的小猫正在阳台上晒太阳" style="min-height: 100px;"></textarea><div class="modal-buttons"><button class="modal-btn modal-btn-cancel" onclick="closeCameraModal()">取消</button><button class="modal-btn modal-btn-confirm" onclick="confirmCamera()">拍摄</button></div></div></div>
    <div id="addMomentModal" class="modal"><div class="modal-content"><div class="modal-title">发布朋友圈</div><textarea class="modal-textarea" id="momentContentInput" placeholder="这一刻的想法..." style="min-height: 120px;"></textarea><div class="avatar-upload" id="momentImageUpload" style="width: 100px; height: 100px; margin-bottom: 15px;"><input type="file" accept="image/*" onchange="handleMomentImageUpload(event)"><span id="momentImagePreview">+</span></div><div class="modal-buttons"><button class="modal-btn modal-btn-cancel" onclick="closeAddMomentModal()">取消</button><button class="modal-btn modal-btn-confirm" onclick="postNewMoment()">发布</button></div></div></div>
    <div id="alertModal" class="modal"><div class="modal-content"><div class="modal-title">提示</div><div id="alertMessage"></div><div class="modal-buttons"><button class="modal-btn modal-btn-confirm" onclick="closeAlertModal()">确定</button></div></div></div>
    <div id="confirmModal" class="modal"><div class="modal-content"><div class="modal-title">请确认</div><div id="confirmMessage" style="text-align: center; margin-bottom: 20px; line-height: 1.5;"></div><div class="modal-buttons"><button class="modal-btn modal-btn-cancel" id="confirmCancelBtn">取消</button><button class="modal-btn modal-btn-confirm" id="confirmOkBtn">确定</button></div></div></div>
        <div id="momentCommentInputArea"><input type="text" id="momentCommentInput" placeholder="评论..."><button id="momentCommentSendBtn">发送</button></div>
    <div id="transferModal" class="modal"><div class="modal-content"><div class="modal-title">转账</div><input type="number" class="modal-input" id="transferAmountInput" placeholder="¥ 0.00"><input type="text" class="modal-input" id="transferRemarkInput" placeholder="添加备注 (可选)"><div class="modal-buttons"><button class="modal-btn modal-btn-cancel" onclick="closeTransferModal()">取消</button><button class="modal-btn modal-btn-confirm" onclick="sendTransfer()">转账</button></div></div></div>
    <div id="worldBookBindingModal" class="modal"><div class="modal-content"><div class="modal-title">绑定世界书</div><div id="worldBookBindingList" class="multi-select-list" style="max-height: 40vh; text-align: left;"></div><div class="modal-buttons" style="margin-top: 15px;"><button class="modal-btn modal-btn-cancel" onclick="closeWorldBookBindingModal()">取消</button><button class="modal-btn modal-btn-confirm" onclick="confirmWorldBookBinding()">确定</button></div></div></div>
    
    <!-- NEW: Location Input Modal -->
    <div id="sendLocationModal" class="modal">
        <div class="modal-content">
            <div class="modal-title">发送位置</div>
            <input type="text" class="modal-input" id="locationNameInput" placeholder="输入位置名称">
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" onclick="closeLocationModal()">取消</button>
                <button class="modal-btn modal-btn-confirm" onclick="confirmSendLocation()">确定</button>
            </div>
        </div>
    </div>
    
    <!-- NEW: Image Description Modal -->
    <div id="imageDescriptionModal" class="modal">
        <div class="modal-content">
            <div class="modal-title">图片描述</div>
            <div id="imageDescriptionContent"></div>
            <div class="modal-buttons" style="margin-top: 15px;">
                <button class="modal-btn modal-btn-confirm" onclick="closeImageDescriptionModal()">确定</button>
            </div>
        </div>
    </div>
    
    <!-- [MODIFIED] New Emoji Modal -->
    <div id="addEmojiModal" class="modal">
        <div class="modal-content">
            <div class="modal-title"> 添加自定义表情</div>
            <div class="emoji-modal-tabs">
                <button class="emoji-modal-tab active" onclick="switchEmojiAddMode(this, 'single')">单个添加</button>
                <button class="emoji-modal-tab" onclick="switchEmojiAddMode(this, 'batch')">批量添加</button>
            </div>

            <!-- Single Add View -->
            <div id="emojiSingleAddView" class="emoji-modal-content-view active">
                <input type="text" class="modal-input" id="singleEmojiNameInput" placeholder="表情名称 (必填)">
                <input type="text" class="modal-input" id="singleEmojiUrlInput" placeholder="表情URL链接">
                <label for="singleEmojiUploadInput" class="emoji-modal-upload-btn">本地上传</label>
            </div>

            <!-- Batch Add View -->
            <div id="emojiBatchAddView" class="emoji-modal-content-view">
                <textarea id="batchEmojiInput" class="modal-textarea" placeholder="在此处粘贴表情信息，格式为：&#10;表情名1：URL1&#10;表情名2：URL2 (URL可换行)"></textarea>
                <label for="batchEmojiUploadInput" class="emoji-modal-upload-btn">本地上传</label>
            </div>

            <div class="modal-buttons" style="margin-top: 20px;">
                <button class="modal-btn modal-btn-cancel" onclick="closeAddEmojiModal()">取消</button>
                <button class="modal-btn modal-btn-confirm" onclick="confirmAddEmoji()">添加</button>
            </div>
        </div>
    </div>
    

     <div id="addMusicModal" class="modal">
            <div class="modal-content">
                <div class="modal-title">添加新歌曲</div>
                <input type="text" class="modal-input" id="songTitleInput" placeholder="歌曲名 (自动读取或手动填写)">
                <input type="text" class="modal-input" id="songArtistInput" placeholder="歌手 (自动读取或手动填写)">
                <button class="modal-btn" onclick="document.getElementById('songFileInput').click()">添加歌曲文件</button>
                <span id="songFileName" style="font-size: 12px; color: #666; display: block; text-align: center; margin-top: 5px;">未选择文件</span>
                <button class="modal-btn" style="margin-top: 10px;" onclick="document.getElementById('lrcFileInput').click()">添加歌词文件 (.lrc)</button>
                <span id="lrcFileName" style="font-size: 12px; color: #666; display: block; text-align: center; margin-top: 5px;">未选择文件</span>
                 <div class="modal-buttons" style="margin-top: 20px;">
                    <button class="modal-btn modal-btn-cancel" onclick="closeAddMusicModal()">取消</button>
                    <button class="modal-btn modal-btn-confirm" onclick="confirmAddSong()">完成</button>
                </div>
            </div>
        </div>


    <div id="playlistModal" class="modal">
        <div class="modal-content">
            <div class="playlist-header">
                <span id="playlistTitle">播放列表 (0)</span>
                <button id="openAddMusicBtn" onclick="openAddMusicModal()">+</button>
            </div>
            <div class="playlist-list" id="playlistList"></div>
        </div>
    </div>

    <div id="voiceModal" class="modal">
        <div class="modal-content">
            <div class="modal-title">发送语音</div>
            <textarea class="modal-textarea" id="voiceInputText" placeholder="在此输入语音的文字内容..." style="min-height: 120px;"></textarea>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" onclick ="closeVoiceModal()">取消</button>
                <button class="modal-btn modal-btn-confirm" onclick="sendVoiceMessage()">发送</button>
            </div>
        </div>
    </div>
    
    <!-- ↓↓↓ 第1步：从这里开始复制 ↓↓↓ -->

    <!-- 新增：发红包的弹窗 -->
    <div id="redEnvelopeModal" class="modal">
        <div class="modal-content">
            <div class="modal-title">发红包</div>
            <div style="display: flex; align-items: center; margin-bottom: 15px;">
                <label style="width: 80px;">总金额</label>
                <input type="number" class="modal-input" id="redEnvelopeAmount" placeholder="0.00" style="margin-bottom: 0;">
                <span style="margin-left: 10px;">元</span>
            </div>
            <div style="display: flex; align-items: center; margin-bottom: 15px;">
                <label style="width: 80px;">红包个数</label>
                <input type="number" class="modal-input" id="redEnvelopeCount" placeholder="填写个数" style="margin-bottom: 0;">
                <span style="margin-left: 10px;">个</span>
            </div>
             <input type="text" class="modal-input" id="redEnvelopeRemark" placeholder="恭喜发财，大吉大利">
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" onclick="closeRedEnvelopeModal()">取消</button>
                <button class="modal-btn modal-btn-confirm" style="background-color: #E64340;" onclick="sendGroupRedEnvelope()">塞钱进红包</button>
            </div>
        </div>
    </div>
    
       <!-- 新增：开红包的动画弹窗 -->
    <div id="openRedEnvelopeModal" class="modal">
        <div id="redEnvelopeOpenCard"> 
            <div id="openRedEnvelopeButton"> <!-- 看，我们把“Red”加回来了！ -->
                开
            </div>
        </div>
    </div>

<!-- ↑↑↑ 第2步：在这里结束复制 ↑↑↑ -->

    <!-- 新增：查看红包详情的弹窗 -->
    <div id="redEnvelopeDetailsModal" class="modal">
        <div class="modal-content" style="background-color: #F7F7F7; padding: 0;">
            <div style="background-color: #E64340; color: white; padding: 20px; border-radius: 12px 12px 0 0; text-align: center;">
                <div id="redEnvelopeDetailsRemark" style="font-size: 20px; margin-bottom: 5px;"></div>
                <div id="redEnvelopeDetailsFrom"></div>
            </div>
            <div id="redEnvelopeDetailsStatus" style="padding: 10px 15px; font-size: 14px; color: #888; border-bottom: 1px solid #eee;"></div>
            <div id="redEnvelopeClaimList" style="max-height: 50vh; overflow-y: auto;">
                <!-- 领取记录将在这里动态生成 -->
            </div>
             <div class="modal-buttons" style="padding: 15px;">
                <button class="modal-btn modal-btn-confirm" onclick="closeRedEnvelopeDetailsModal()">关闭</button>
            </div>
        </div>
    </div>

<!-- ↑↑↑ 第1步：在这里结束复制 ↑↑↑ -->

<!-- ↓↓↓ 第一步：将这两段代码粘贴到 <body> 标签的末尾 ↓↓↓ -->

<!-- 这是新增的“发起投票”功能的弹窗 -->
<div id="pollModal" class="modal">
    <div class="modal-content">
        <div class="modal-title">发起投票</div>
        <input type="text" class="modal-input" id="pollTitleInput" placeholder="投票标题">
        <div id="pollOptionsContainer">
            <!-- 投票选项会动态添加到这里 -->
            <div class="form-group" style="display: flex; align-items: center; gap: 10px;">
                <input type="text" class="form-input poll-option-input" placeholder="选项 1">
                <!-- 第一个选项不允许删除 -->
            </div>
            <div class="form-group" style="display: flex; align-items: center; gap: 10px;">
                <input type="text" class="form-input poll-option-input" placeholder="选项 2">
                <!-- 第二个选项也不允许删除 -->
            </div>
        </div>
        <button class="modal-btn modal-btn-cancel" onclick="addPollOption()" style="margin-top: 10px; background: var(--bg-hover);">+ 添加选项</button>
        <div class="modal-buttons" style="margin-top: 20px;">
            <button class="modal-btn modal-btn-cancel" onclick="closePollModal()">取消</button>
            <button class="modal-btn modal-btn-confirm" onclick="sendPoll()">发起投票</button>
        </div>
    </div>
</div>

<!-- 这是聊天界面里的“投票”按钮 -->
<!-- 注意：这段代码我们稍后会用JavaScript动态添加到“+”菜单里，你先不用动 -->
<!-- <div class="function-item" onclick="openPollModal()">
    <div class="function-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14H9v-4h2v4zm4 0h-2v-2h2v2zm0-4h-2V7h2v5z"/>
        </svg>
    </div>
    <div class="function-label">投票</div>
</div> -->

<!-- ↑↑↑ 第一步：代码粘贴到此结束 ↑↑↑ -->

    
    <!-- [MODIFIED] Heart's Voice Modal -->
    <div id="heartsVoiceModal" class="modal">
        <div class="modal-content">
            <div id="heartsVoiceHeader">
                <div id="heartsVoiceAvatar" class="friend-avatar"></div>
                <div id="heartsVoiceName"></div>
            </div>
            <div id="heartsVoiceEmoji">( ´• ω •` )</div>
            <div id="heartsVoiceThought">
                <div id="heartsVoiceFavorability"><strong>好感度：</strong><span>...</span></div>
                <div id="heartsVoiceDressing"><strong>着装：</strong><span>...</span></div>
                <div id="heartsVoiceAction"><strong>动作：</strong><span>...</span></div>
                <div id="heartsVoiceThoughtContent"><strong>心声：</strong><span>...</span></div>
            </div>
        </div>
    </div>
    
    <!-- ↓↓↓ 第2步：从这里开始复制所有新增的HTML代码 ↓↓↓ -->

<!-- 新增：人设列表页面 -->
<div id="personaListScreen" class="page">
    <div class="nav-bar">
        <button class="nav-btn" onclick="backToProfile()">←</button>
        <div class="nav-title">我的人设</div>
        <button class="nav-btn" onclick="openPersonaEditModal(null)">+</button>
    </div>
    <div class="wechat-content">
        <div id="personaListContainer" class="friend-list">
            <!-- 人设列表将在这里动态生成 -->
        </div>
    </div>
</div>

<!-- 新增：添加/编辑人设的弹窗 -->
<div id="personaEditModal" class="modal">
    <div class="modal-content">
        <div class="modal-title" id="personaEditTitle">添加新人设</div>
        <div class="avatar-upload" id="personaAvatarUpload">
            <input type="file" accept="image/*" onchange="handlePersonaAvatarUpload(event)">
            <span id="personaAvatarPreview">+</span>
        </div>
        <input type="text" class="modal-input" id="personaNameInput" placeholder="昵称 (必填)">
        <textarea class="modal-textarea" id="personaPersonalityInput" placeholder="个性、特点、喜好等..."></textarea>
        <textarea class="modal-textarea" id="personaBackgroundInput" placeholder="背景、经历、职业等..."></textarea>
        <input type="text" class="modal-input" id="personaPatActionInput" placeholder="“拍了拍”后缀，如：的头说“你好”">
        <div class="modal-buttons">
            <button class="modal-btn modal-btn-cancel" onclick="closePersonaEditModal()">取消</button>
            <button class="modal-btn modal-btn-confirm" onclick="savePersona()">保存</button>
        </div>
        <div style="margin-top: 20px;">
             <button class="settings-btn btn-danger" id="deletePersonaBtn" style="display: none;" onclick="deletePersona()">删除这个人设</button>
        </div>
    </div>
</div>

<!-- 新增：为人设选择的弹窗 -->
<div id="personaSelectModal" class="modal">
    <div class="modal-content">
        <div class="modal-title">为当前聊天选择“我”的人设</div>
        <div id="personaSelectList" class="friend-list" style="max-height: 50vh; overflow-y: auto;">
            <!-- 可选的人设列表将在这里动态生成 -->
        </div>
        <div class="modal-buttons" style="margin-top: 15px;">
             <button class="modal-btn modal-btn-cancel" onclick="closePersonaSelectModal()">取消</button>
        </div>
    </div>
</div>

<!-- ↑↑↑ HTML代码复制到这里结束 ↑↑↑ -->
    

       

    <script>
        // --- [REFACTORED] IndexedDB Manager ---
        const dbManager = {
            db: null,
            dbName: 'JRSY_DB_V2',
            dbVersion: 3,
            // 定义数据库的所有“表格”
                        stores: [
    'friends', 'chatHistories', 'diaries', 'worldBooks', 'worldBookFolders', 
    'favorites', 'moments', 'playlist', 'appSettings', 'apiSettings', 'customEmojis',
    'memories' // <-- 新增的记忆仓库
],

            // 初始化数据库
            init() {
                return new Promise((resolve, reject) => {
                    if (this.db) {
                        return resolve(this.db);
                    }
                    const request = indexedDB.open(this.dbName, this.dbVersion);

                    request.onerror = (event) => {
                        console.error('IndexedDB error:', request.error);
                        reject('IndexedDB error: ' + request.error);
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        console.log('Database initialized successfully.');
                        resolve(this.db);
                    };

                    // 创建或升级数据库结构
                    request.onupgradeneeded = (event) => {
                        console.log('Upgrading database...');
                        const db = event.target.result;
                        this.stores.forEach(storeName => {
                            if (!db.objectStoreNames.contains(storeName)) {
                                if (storeName === 'chatHistories') {
                                    // 聊天记录表使用 friendId 作为 key
                                    db.createObjectStore(storeName, { keyPath: 'friendId' });
                                } else if (storeName === 'appSettings' || storeName === 'apiSettings') {
                                    // 设置表使用固定的 'settings' 作为 key
                                    db.createObjectStore(storeName, { keyPath: 'id' });
                                }
                                else {
                                    // 其他表使用自增的 id 作为 key
                                    db.createObjectStore(storeName, { keyPath: 'id', autoIncrement: true });
                                }
                                console.log(`Object store '${storeName}' created.`);
                            }
                        });
                    };
                });
            },

            // 通用的写入/更新方法
            set(storeName, data) {
                return new Promise((resolve, reject) => {
                    if (!this.db) return reject("DB not initialized");
                    const transaction = this.db.transaction(storeName, 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(data);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(`Error setting data in ${storeName}: ` + event.target.error);
                });
            },

            // 通用的读取方法
            get(storeName, key) {
                return new Promise((resolve, reject) => {
                    if (!this.db) return reject("DB not initialized");
                    const transaction = this.db.transaction(storeName, 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(`Error getting data from ${storeName}: ` + event.target.error);
                });
            },

            // 读取整个表的数据
            getAll(storeName) {
                return new Promise((resolve, reject) => {
                    if (!this.db) return reject("DB not initialized");
                    const transaction = this.db.transaction(storeName, 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(`Error getting all data from ${storeName}: ` + event.target.error);
                });
            },
            
            // 删除指定条目
            delete(storeName, key) {
                return new Promise((resolve, reject) => {
                    if (!this.db) return reject("DB not initialized");
                    const transaction = this.db.transaction(storeName, 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(key);
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(`Error deleting data from ${storeName}: ` + event.target.error);
                });
            },

            // 清空整个表
            clear(storeName) {
                return new Promise((resolve, reject) => {
                    if (!this.db) return reject("DB not initialized");
                    const transaction = this.db.transaction(storeName, 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.clear();
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(`Error clearing store ${storeName}: ` + event.target.error);
                });
            }
        };

function sanitizeForJSON(str) {
    if (typeof str !== 'string') return '';
    return str
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\n/g, '\\n');
}

async function requestPersistentStorage() {
    if (navigator.storage && navigator.storage.persist) {
        const isPersisted = await navigator.storage.persisted();
        if (!isPersisted) {
            const result = await navigator.storage.persist();
            if (result) {
                console.log("已请求持久性存储并获得授权");
            } else {
                console.warn("请求持久性存储被拒绝");
            }
        } else {
            console.log("已经是持久性存储模式");
        }
    }
}
// 在你的应用启动时调用
requestPersistentStorage();


        // 全局变量
                let userPersonas = []; // 新增：用于存储所有用户人设的数组
        let currentEditingPersonaId = null; // 新增：用于记录当前正在编辑的人设ID
        let currentChatFriendId = null;
        let currentlyDisplayedMessageCount = 0; // 新增：记录当前显示了多少条消息
let isLazyLoading = false; // 新增：防止在加载时重复触发
const CHAT_PAGE_SIZE = 30; // 新增：定义每次加载的消息数量

        let currentMessageElement = null;
        // 把“是不是在回复”的开关，换成“正在回复的角色列表”
const aiReplyingSet = new Set();
        let friendAvatarImage = '';
        let tempEditingFriendAvatar = '';
        let userAvatarImage = '';
        let tempSelectedBackground = { type: 'default', customImage: '' };
        let selectedGlobalChatBg = 'default';
        let customGlobalChatBgImage = '';
        let selectedFont = 'system';
        let selectedFontSize = 14;
        let selectedFontColor = '#000000';
        let customFontUrl = '';
        let selectModeActive = false;
        let selectedFavorites = new Set();
        let quotedMessage = '';
        let diaries = [];
        let worldBooks = [];
        let worldBookFolders = [];
        let favorites = [];
        let moments = [];
        let chatHistories = {};
        let customEmojis = [];
        let selectedWallpaper = 'default';
        let customWallpaperImage = '';
        let customWidgetBackgroundImage = '';
        let roundedCornersEnabled = false;
        let darkModeEnabled = false;
        let multiSelectMode = false;
        let selectedMessages = new Set();
        let recalledMessages = new Map();
        let sentBubbleColor = '#FFEEF6';
        let receivedBubbleColor = '#E6F2FF';
        let customBubbleCSS = '';
        let customIcons = {};
        let momentImage = '';
        let momentImageDescription = ''; // For AI generated image descriptions
        let currentCommentingMomentId = null;
        let currentReplyToCommentId = null; 
        let currentReplyToAuthorId = null;  
        let currentEditingWidgetImageId = null;
        let currentEditingTextElement = null;
        let aiTimePerceptionEnabled = true;
        let selectedAppLabelColor = '#333333';
        // 【【【第三步 A：添加新的全局变量】】】

let npcFriends = []; // 新增：用来存放为用户动态生成的NPC朋友列表

let characterMemories = {}; // <-- 新增：用来存放所有角色的记忆

let memoryGenerationTurns = 20; // 新增：记忆生成轮数，默认20轮

        
        let notificationTimeout = null; // For clearing notification timer

        // NEW: State for component transparency
        let profileWidgetTransparent = false;
        let smallWidgetTransparent = false;
        
        // NEW: Emoji Modal v2 state
        let currentEmojiAddMode = 'single';
        let singleEmojiFile = null;
        let isEmojiManaging = false; // For deleting emojis

        // NEW: Camera function state
        let tempCameraDescription = '';

                // ↓↓↓ 请用这个代码块替换旧的 userProfile 定义 ↓↓↓
let userProfile = {
    id: 'default_user',
    name: '可点击编辑',         // <-- 改回这里
    avatar: '',                 // <-- 推荐改为空，程序会自动取名字首字
    avatarImage: '',
    personality: '一个普通人',
    background: '',
    signature: '可点击编辑',     // <-- 改回这里
    location: '可点击编辑',       // <-- 改回这里
    momentsCover: '',
    balance: 50000,
    patAction: '拍了拍'
};
// ↑↑↑ 替换结束 ↑↑↑
        
        let homeWidgetData = {
            headerText: '(:::[♡]:::)..?',
            image1: 'https://i.imgur.com/example-avatar-1.png',
            text1: 'have a nice day 🌟',
            image2: 'https://i.imgur.com/example-avatar-2.png',
            text2: '.o. HAPPY EVERYDAY ☻'
        };

        // Listen Together Variables
        let audioElement;
        let playlist = [];
        let currentSongIndex = -1;
        let parsedLyrics = [];
        let isRepeat = false;
        let listenTogetherInterval;
        let tempSongFile = null;
        let tempLrcFileContent = null;
        let songFileCache = {}; // Cache for blob URLs
        let customListenBg = '';
        let persistentVinylCover = ''; // MODIFIED: For persistent vinyl image
        let isListenSessionActive = false; 
        let listenTogetherFriendId = null; 
        
        
        // [NEW] Voice Call variables
        let voiceCallFriendId = null;
        let isCallActive = false;
        let callStartTime = null;
        let callTimerInterval = null;
        let incomingCallData = null;


        // MODIFIED: Phone App variables
        let currentSimPhoneCharacterId = null;
        let simPhoneContentCache = {}; // Cache generated content, now with timestamps
        const SIM_CACHE_DURATION = 12 * 60 * 60 * 1000; // 12 hours


        let confirmCallback = null;
        let longPressTimer = null;
        
        // [NEW] Kaomoji List Definition
        const KAOMOJI_LIST = "ꉂ  ᳐  ˋ ᗜ ˊ    ᳐犭,눈 _ 눈,^ ㅇ ^,ㅎ_ㅎ,ㅇㅅㅇ,ㅋㅋㅋ,ㅇㅂㅇ,ㅇㅋㅇ,ㅎㅇㅎ,ㅎㅅㅎ,ㅎωㅎ,(ᐡ т  ̫ т ᐡ),=ᗜωᗜ=,>ヮ<,(՞_    ̫ _՞)ᐝ,⦁֊⦁꧞,՞⩌⌯⩌՞,ฅ´ ꄃ `ฅ,ᕱ⑅ᕱ,꒦ິ^꒦ິ,˶╹ꇴ╹˶,ฅ˙Ⱉ˙ฅ,ʚ✞ɞ,૮ ˃̵ ֊ ˂̵  ა,ᐡ•͈ ·̭ •͈ᐡ,៸៸᳐⦁⩊<៸៸᳐ ੭ﾞ🐾,/ᐠ .⸝⸝⸝. ྀིﾏ,. ₍˄ ₗ   ̫ ₗ ˄₎◞ ̑̑,ଘ៸៸᳐⦁⩊⦁៸៸᳐ଓ,^›⩊‹^ ੭,៸៸᳐>⩊<៸៸᳐,^⦁᎑-^ ੭,₍^˶ ╸𖥦  ╸˵^₎⟆,＞𐋣＜,ฅᐞ˶⦁༝⦁˶ᐞฅ,𓈒♡𐅛 ͚ ꠆. .  ꠆ ͚𑁨ྀི♡,ミ ᴗ͈  。ᴗ͈ ミ,^⎚˕⎚^,⦁֊⦁꧞,՞⩌⌯⩌՞ ᶻ 𝗓,´⚰︎`˵ಣ,⌯oᴗ<⌯ಣ,ฅ´ ꄃ `ฅ՞,˶╹ꇴ╹˶,ᐞ･֊･ᐞฅ,๑'~'๑,=⩌⩊⩌=,＞𐋣＜,ÒωÓ！,♡(ˆ꜆ . ω . ). ω . ꜀ˆ)♡,Ｏ(≧▽≦)Ｏ,ᯠ _   ̫  _ ᯄ,˶╹ꇴ╹˶,⁃ ⩊ ⁃,ᶻz ₍^_   ̫ _^₎,˶⊗ 𐋣 ᗜ˶ಣ,ꉂ૮ o̴̶̷᷄ ·̫ᕳᕲა,• ·̫ •,⁺ʚ> ·̫ <ɞ⁺,（ ≥ × ≤ ）, /•᷅‎‎•᷄\୭,⌯'ᵕ'⌯,⦁֊⦁꧞,՞⸝⸝'ᜊ'⸝⸝՞♥︎,๑>ᴗO๑,=• ֊ •=,ꉂ ･ ･ ☆,Z☡zᶻ,ᕑᗢᓫ,˃̵͈̑ᴗ˂̵͈̑,𖦹𖦹 .ᐟ.ᐟ,⌯>ᴗo⌯ಣ,^ ̳- ‧̫ • ̳^ฅ,^•ω<^ ੭,₍ᐢ..ᐢ₎ᐝ,•͈ᴗ⁃͈,•͈ ₃ •͈,⌯'Ⱉ'⌯,^⌯𖥦⌯^੭,ᖰ⌯'▾'⌯ᖳ,^_^,₍^ₗ   ̫˳ ₗ^₎,₍ᐢ⸝⸝-ᴗ-⸝⸝ᐢ₎,₍ᐢ⸝⸝• ֊ •⸝⸝ᐢ₎,ฅ( ̳• ·̫ • ̳ฅ),(꜆꜄꜆˙꒳˙)꜆꜄꜆,୧(๑⃙⃘⁃̀⩊⁃́๑⃙⃘)୨,៸៸᳐ÒωÓ៸៸᳐,ꉂ  ᳐  ˋ ᗜ ˊ    ᐐ犭,-ᶻz ₍^_   ̫ _^₎,˶⊗ ᎑ ᗜ˶ಣ,ꉂ૮˶⩌⩊ᕳᕲ˶ა,ㅎωㅎ,= ᗜ ω ᗜ.=,(ᐡ т   ̫ т ᐡ),>ヮ<,＞𐋣＜,⦁֊⦁꧞,໒𖦹 𖦹  ͛১,૮ ˃̵ ֊ ˂̵  ა,ᐡ•͈ ·̭ •͈ᐡ,ദ്ദി˶•̀֊•́)✧,ദ്ദി˶•̀֊<)✧,ദ്ദി˶ｰ̀֊ｰ́ )✧,ᕑᗢᓫ !!,•̆.•̑,ටᆼට,⁽¯꒳¯⁾,ᥫᩣᵕ̈,՞⩌⌯⩌՞,ฅ´ ꄃ `ฅ,ᕱ⑅ᕱ,˶╹ꇴ╹˶,ฅ˙Ⱉ˙ฅ,⦁ ㅈ -,=×ω×=,(･∞･ﾐэ )Э,ᡣ ︠𓈒. .𓈒 ︡𐑠,𐙚・⋆・𐙚,(ෆ• ֊ •ෆ）,ฅᐞ˶⦁༝⦁˶ᐞฅ,𓈒♡𐅛 ͚ ꠆. .  ꠆ ͚𑁨ྀི♡,ミ ᴗ͈  。ᴗ͈ ミ,(ᐡ ɞ̴̶̷ . ɞ̴̶̷ ᐡ),✧(≖ ◡ ≖✿),U- ˕ -Uᶻᶻᶻ,ᨦ₍ᐢ..ᐢ₎ᨩ ໋·̩͙,૮⑅•̤ ༝ •̤⑅ა,ᘏ ୨୧‬ ᘏ,๑>ᴗO๑,=• ֊ •=,ꉂ ･ ･ ☆,Z☡zᶻ,ᕑᗢᓫ,˃ᴗ˂̵͈̑,𖦹𖦹 .ᐟ.ᐟ,^ ̳- ‧̫ • ̳^ฅ,^•ω<^ ੭,^⌯𖥦⌯^੭,ᜊ꒰๑˃͈꒵˂͈๑꒱ᜊ,ᖰ⌯'▾'⌯ᖳ,៸៸᳐>⩊<៸៸᳐,૮⑉･-･⑉ა,✩*:.⸝⸝>o<⸝⸝.:*✩,՞⸝⸝'ᜊ'⸝⸝՞,⌯'▾'⌯,• ︡ᯅ•︠,ᗦ↞︎◃,꒰১☆⁺໒꒱,˶‾᷄   ⁻̫ ‾᷅˵,˙Ⱉ˙,˃̶͈̀ε ˂̶ ͈ ͈,ᵔ·͈༝༝༝·͈ᵔ,･ꈊ･,ᕑᗢᓫ,♥︎︎ᯐ,ᰔᩚ,៷>ᴗ<៷,•͈ ₃ •͈,⌯'Ⱉ'⌯,𖠚ᐝ,ყ ᥱ ᥉,𖤣𖥧𖥣｡,⌯>ᴗo⌯ಣ,⌯˃ ᵕ ˂⌯ಣ,⌯>𖥦<⌯ಣ,⌯˃̶ᗜ˂̶⌯ಣ,⌯ᕑᗢᓫ⌯ಣ。,⌯>ᴗ<⌯ಣ,⌯•͈ᴗ•͈⌯ಣ,⌯ᐢᗜᐢ⌯ಣ,⌯･-･⌯ಣ,⌯>v<⌯ಣ,⌯･ᴗ･⌯ಣ,⌯>₃<⌯ಣ,⌯•͈ ₃ •͈⌯ಣ。,⌯⁰ᵕᵔ⌯ಣ,⌯•͈⌔•͈⌯ಣ,⌯＞◡❛⌯ಣ,⌯' ꇴ '⌯ಣ。,⌯･∀･⌯ಣ,⌯>ෆ<⌯ಣ,⌯ᵔᵕᵔ⌯ಣ,𝐛𝐛 •͈ᴗ⁃͈,ოყ ხαხყ,𖨆♡𖨆,•︡ᯅ•︠,•͈ᴗ⁃͈★,ʚ •͈˽•͈ ིྀɞ,˶՞ɞ̴̶̷.ɞ̴̶̷՞˶,ฅ՞••՞ฅ,₌᳐･֊･₌᳐੭。,˃̶͈̀ε ˂̶ ͈,ꈨຶꎁꈨຶ,•͈ ₃ •͈,๐•ᴗ•๐,⌯>ᗜ<⌯,⌯˃~˂⌯,⌯･ᴗ･⌯,⌯•͈ ₃ •͈⌯,⌯^𖥦^⌯,⌯⁍̴̛ᴗ⁍̴̛⌯,⌯˃͈꒵˂͈⌯,⌯⁰ᵕᵔ⌯,⌯˙Ⱉ˙⌯,₌ ･ ᵕ ･ ₌,=• ֊ •=,ᜊ>ᴗ<ᜊ,^⌯𖥦⌯^੭,𖦹ࡇ𖦹 .ᐟ.ᐟ,૮  ´͈ ᗜ `͈ ა♡,૮ ᴗ͈ˬᴗ͈ෆა,૮⑉･-･⑉ა,ᵔ·͈༝༝༝·͈ᵔ,🐾₊⁺ S,^ ̳- ‧̫ • ̳^ฅ,⸝⸝っ·̫ •⸝⸝,˙Ⱉ˙,꒰ᐢ. .ᐢ꒱₊˚⊹✧,՞⸝⸝'ᜊ'⸝⸝՞,૮ • ·̫ •̥ ა,𑁊^.  ̫ .^𑁊,^ ̳• ·̫ • ̳^,ꉂ ･ ･ ☆,◍˃ᵕ˂◍,(◍＞◡＜◍),૮◍'ㅅ'◍ა,^>⸝⸝⸝⸝<^੭ﾞ,/ᐠ - ˕ -マ Ⳋ,/ᐠ .⸝⸝⸝. ྀིﾏ,づ♡ど,՞•･•՞🐾,⁺ʚ⦁⩊⦁ɞ⁺,૮ ˘͈ᵕ ˘͈ ა,๑⃙⃘´༥`๑⃙⃘,• ༝༝༝ •".split(',').map(s => s.trim()).filter(Boolean);

        // --- [MODIFIED] Heart's Voice Modal Functions ---
        function openHeartsVoiceModal() {
            const friend = friends.find(f => f.id === currentChatFriendId);
            if (!friend) return;

            const modal = document.getElementById('heartsVoiceModal');
            const avatarDiv = document.getElementById('heartsVoiceAvatar');
            const nameDiv = document.getElementById('heartsVoiceName');
            const emojiDiv = document.getElementById('heartsVoiceEmoji');
            
            // Get all the span elements for content
            const favorabilitySpan = document.querySelector('#heartsVoiceFavorability span');
            const dressingSpan = document.querySelector('#heartsVoiceDressing span');
            const actionSpan = document.querySelector('#heartsVoiceAction span');
            const thoughtSpan = document.querySelector('#heartsVoiceThoughtContent span');

            nameDiv.textContent = friend.remark || friend.name;
            if (friend.avatarImage) {
                avatarDiv.style.backgroundImage = `url(${friend.avatarImage})`;
                avatarDiv.textContent = '';
            } else {
                avatarDiv.style.backgroundImage = '';
                avatarDiv.textContent = friend.avatar || '?';
            }
            
            const heartsVoiceData = friend.heartsVoice || { 
                emoji: '( ´• ω •` )', 
                favorability: '...',
                dressing: '...', 
                action: '...', 
                thought: '...' 
            };
            emojiDiv.textContent = heartsVoiceData.emoji;

            // Correctly map the data to the spans
            favorabilitySpan.textContent = heartsVoiceData.favorability;
            dressingSpan.textContent = heartsVoiceData.dressing;
            actionSpan.textContent = heartsVoiceData.action;
            thoughtSpan.textContent = heartsVoiceData.thought;
            
            modal.classList.add('show');
            modal.addEventListener('click', closeHeartsVoiceModalOnClickOutside);
        }
        
        function closeHeartsVoiceModal() {
            const modal = document.getElementById('heartsVoiceModal');
            modal.classList.remove('show');
            modal.removeEventListener('click', closeHeartsVoiceModalOnClickOutside);
        }

        function closeHeartsVoiceModalOnClickOutside(event) {
            if (event.target.id === 'heartsVoiceModal') {
                closeHeartsVoiceModal();
            }
        }

        function showToast(message, duration = 3000) {
            let toast = document.getElementById('toast-notification');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'toast-notification';
                toast.style.cssText = 'position:fixed; bottom:80px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.7); color:white; padding:10px 20px; border-radius:8px; z-index:10000; transition: opacity 0.5s, bottom 0.5s; opacity: 0;';
                document.body.appendChild(toast);
            }
            toast.textContent = message;
            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.bottom = '90px';
            }, 10);
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.bottom = '80px';
            }, duration);
        }

        function showAlert(message) {
            document.getElementById('alertMessage').innerHTML = message.replace(/\n/g, '<br>');
            document.getElementById('alertModal').classList.add('show');
        }

        function closeAlertModal() {
            document.getElementById('alertModal').classList.remove('show');
        }
        
        // NEW: Image Description Modal Functions
        function showImageDescription(description ) {
            document.getElementById('imageDescriptionContent').textContent = description;
            document.getElementById('imageDescriptionModal').classList.add('show');
        }

        function closeImageDescriptionModal() {
            document.getElementById('imageDescriptionModal').classList.remove('show');
        }

        function showConfirm(message, onConfirm) {
            confirmCallback = onConfirm;
            document.getElementById('confirmMessage').textContent = message;
            document.getElementById('confirmModal').classList.add('show');
        }

        function closeConfirmModal() {
            document.getElementById('confirmModal').classList.remove('show');
            confirmCallback = null;
        }

        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
        }

        document.addEventListener('touchstart', (event) => (event.touches.length > 1) && event.preventDefault(), { passive: false});
        
        function updateBubblePreview() {
            const sentColor = document.getElementById('sentBubbleColorInput').value;
            const receivedColor = document.getElementById('receivedBubbleColorInput').value;
            const customCSS = document.getElementById('bubbleCustomCSS').value;
            const previewStyleTag = document.getElementById('customBubblePreviewStyle');
            if (!previewStyleTag) return;
            const scopedCSS = customCSS.replace(new RegExp(/\.message/g), '.bubble-preview-area .message');
            previewStyleTag.textContent = `
                .bubble-preview-area .message.sent .message-content { background-color: ${sentColor}; }
                .bubble-preview-area .message.received .message-content { background-color: ${receivedColor}; }
                ${scopedCSS}
            `;
        }

                function openBubbleSettings() {
            setActivePage('bubbleSettingsScreen');
            document.getElementById('sentBubbleColorPicker').value = sentBubbleColor;
            document.getElementById('sentBubbleColorInput').value = sentBubbleColor;
            document.getElementById('receivedBubbleColorPicker').value = receivedBubbleColor;
            document.getElementById('receivedBubbleColorInput').value = receivedBubbleColor;
            
            // 核心修改：在这里备份当前的CSS设置
            document.getElementById('bubbleCustomCSS').value = customBubbleCSS;
            
            updateBubblePreview(); // 确保预览是正确的
        }
        function updateSentBubbleColor(color) {
            document.getElementById('sentBubbleColorInput').value = color;
            updateBubblePreview();
        }

        function updateSentBubbleColorFromInput(color) {
            if (/^#[0-9A-F]{6}$/i.test(color )) document.getElementById('sentBubbleColorPicker').value = color;
            updateBubblePreview();
        }

        function updateReceivedBubbleColor(color) {
            document.getElementById('receivedBubbleColorInput').value = color;
            updateBubblePreview();
        }

        function updateReceivedBubbleColorFromInput(color) {
            if (/^#[0-9A-F]{6}$/i.test(color)) document.getElementById('receivedBubbleColorPicker').value = color;
            updateBubblePreview();
        }

        function applyBubbleColors() {
            document.documentElement.style.setProperty('--message-sent-bg', sentBubbleColor);
            document.documentElement.style.setProperty('--message-received-bg', receivedBubbleColor);
            // NEW: Calculate and set quote border colors
            const sentBorder = calculateBorderColor(sentBubbleColor, darkModeEnabled);
            const receivedBorder = calculateBorderColor(receivedBubbleColor, darkModeEnabled);
            document.documentElement.style.setProperty('--sent-quote-border-color', sentBorder);
            document.documentElement.style.setProperty('--received-quote-border-color', receivedBorder);
        }

        function calculateBorderColor(hex, isDark) {
            // Simple darken/lighten function for the border
            let color = hex.startsWith('#') ? hex.slice(1) : hex;
            let r = parseInt(color.substring(0, 2), 16);
            let g = parseInt(color.substring(2, 4), 16);
            let b = parseInt(color.substring(4, 6), 16);
            
            // If dark mode is on for the user bubble, we need to lighten it
            // Otherwise, we darken
            const amount = isDark ? 40 : -40;

            r = Math.max(0, Math.min(255, r + amount));
            g = Math.max(0, Math.min(255, g + amount));
            b = Math.max(0, Math.min(255, b + amount));
            
            return `#${(r).toString(16).padStart(2, '0')}${(g).toString(16).padStart(2, '0')}${(b).toString(16).padStart(2, '0')}`;
        }


                        function applyCustomBubbleCSS(css) {
            // customBubbleCSS = css;  <-- 核心修改：把这一行删掉！
            let styleTag = document.getElementById('customBubbleStyle');
            if (styleTag) {
                const importantCSS = css.replace(/;/g, ' !important;');
                styleTag.textContent = importantCSS;
            }
            updateBubblePreview();
        }

        async function saveBubbleSettings() {
            sentBubbleColor = document.getElementById('sentBubbleColorInput').value;
            receivedBubbleColor = document.getElementById('receivedBubbleColorInput').value;
            customBubbleCSS = document.getElementById('bubbleCustomCSS').value;
            applyBubbleColors();
            applyCustomBubbleCSS(customBubbleCSS);
            await saveData();
            showAlert('气泡设置已保存');
            backToMySettings();
        }

        function getFontFormatFromUrl(url) {
            if (!url) return null;
            const extension = url.split('.').pop().toLowerCase().split('?')[0];
            return { 'ttf': 'truetype', 'otf': 'opentype', 'woff': 'woff', 'woff2': 'woff2' }[extension] || null;
        }

        function applyCustomFont(url) {
            customFontUrl = url;
            let existingLink = document.getElementById('customFontLink');
            if (existingLink) existingLink.remove();
            let existingStyle = document.getElementById('customFontStyle');
            if (existingStyle) existingStyle.remove();
            if (url.trim()) {
                const fontFormat = getFontFormatFromUrl(url);
                if (fontFormat) {
                    const style = document.createElement('style');
                    style.id = 'customFontStyle';
                    const fontName = 'UserCustomFont';
                    style.textContent = `@font-face { font-family: '${fontName}'; src: url('${url}') format('${fontFormat}'); }`;
                    document.head.appendChild(style);
                    if (selectedFont === 'custom') document.documentElement.style.setProperty('--custom-font-family', `'${fontName}'`);
                } else if (url.includes('googleapis.com/css')) {
                    const link = document.createElement('link');
                    link.id = 'customFontLink';
                    link.rel = 'stylesheet';
                    link.href = url;
                    document.head.appendChild(link);
                    try {
                        const family = new URL(url).searchParams.get('family');
                        if (family) {
                            const fontFamily = family.split(':')[0].replace(/\+/g, ' ');
                            if (selectedFont === 'custom') document.documentElement.style.setProperty('--custom-font-family', `'${fontFamily}'`);
                        }
                    } catch (e) { console.error("Could not parse Google Font URL", e); }
                }
            }
            applyFont();
        }
        
        function updateFontColor(color) {
            selectedFontColor = color;
            document.getElementById('fontColorInput').value = color;
            applyFont();
        }

        function updateFontColorFromInput(color) {
            if (/^#[0-9A-F]{6}$/i.test(color)) {
                selectedFontColor = color;
                document.getElementById('fontColorPicker').value = color;
                applyFont();
            }
        }

function updateAppLabelColor(color) {
    selectedAppLabelColor = color;
    document.getElementById('appLabelColorInput').value = color;
    applyAppLabelColor();
}

function updateAppLabelColorFromInput(color) {
    if (/^#[0-9A-F]{6}$/i.test(color)) {
        selectedAppLabelColor = color;
        document.getElementById('appLabelColorPicker').value = color;
        applyAppLabelColor();
    }
}

        async function toggleDarkMode() {
            darkModeEnabled = document.getElementById('darkModeToggle').checked;
            applyDarkMode();
            await saveData();
        }

        function applyDarkMode() {
            const toggle = document.getElementById('darkModeToggle');
            if (toggle) toggle.checked = darkModeEnabled;
            document.body.classList.toggle('wechat-dark-mode', darkModeEnabled);
            document.querySelector('.phone').classList.toggle('wechat-dark-mode', darkModeEnabled);
        }

        async function toggleRoundedCorners() {
            roundedCornersEnabled = document.getElementById('roundedToggle').checked;
            applyRoundedCorners();
            await saveData();
        }

        function applyRoundedCorners() {
            const toggle = document.getElementById('roundedToggle');
            if (toggle) toggle.checked = roundedCornersEnabled;
            document.querySelector('.phone').classList.toggle('wechat-rounded', roundedCornersEnabled);
        }

        function startMultiSelect() {
            multiSelectMode = true;
            selectedMessages.clear();
            const chatMessages = document.getElementById('chatMessages');
            const toolbar = document.getElementById('multiSelectToolbar');
            chatMessages.classList.add('multi-select-mode');
            toolbar.classList.add('show');
            chatMessages.querySelectorAll('.message:not(.recall-message)').forEach(msg => {
                if (!msg.querySelector('.message-checkbox')) {
                    const checkbox = document.createElement('div');
                    checkbox.className = 'message-checkbox';
                    checkbox.onclick = (e) => { e.stopPropagation(); toggleMessageSelection(msg); };
                    msg.prepend(checkbox);
                }
            });
            updateMultiSelectCount();
            hideMessageMenu();
        }

        function toggleMessageSelection(messageElement) {
            const messageId = messageElement.getAttribute('data-message-id');
            if (selectedMessages.has(messageId)) {
                selectedMessages.delete(messageId); 
                messageElement.classList.remove('selected');
            } else {
                selectedMessages.add(messageId);
                messageElement.classList.add('selected');
            }
            updateMultiSelectCount();
        }

        function updateMultiSelectCount() {
            document.getElementById('multiSelectCount').textContent = `已选择 ${selectedMessages.size} 条消息`;
        }

        function deleteSelectedMessages() {
            if (selectedMessages.size === 0) return showAlert('请先选择要删除的消息');
            showConfirm(`确定要删除 ${selectedMessages.size} 条消息吗？`, async (confirmed) => {
                if (!confirmed) return;
                const history = chatHistories[currentChatFriendId] || [];
                chatHistories[currentChatFriendId] = history.filter(msg => !selectedMessages.has(String(msg.id)));
                selectedMessages.forEach(id => document.querySelector(`[data-message-id="${id}"]`)?.remove());
                await saveData();
                exitMultiSelectMode();
            });
        }

        function exitMultiSelectMode() {
            multiSelectMode = false;
            selectedMessages.clear();
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.classList.remove('multi-select-mode');
            document.getElementById('multiSelectToolbar').classList.remove('show');
            chatMessages.querySelectorAll('.message-checkbox').forEach(cb => cb.remove());
            chatMessages.querySelectorAll('.message.selected').forEach(msg => msg.classList.remove('selected'));
        }
        
        function showRecalledMessage(messageId) {
            const msg = (chatHistories[currentChatFriendId] || []).find(m => String(m.id) === messageId);
            if (msg && msg.recalledContent) {
                document.getElementById('recalledMessageContent').textContent = msg.recalledContent;
                document.getElementById('recalledMessagePopup').classList.add('show');
            }
        }

        function closeRecalledMessagePopup() {
            document.getElementById('recalledMessagePopup').classList.remove('show');
        }

        // --- [新增] 专门用于保存个人信息和主页组件的函数 ---
        async function saveProfileData() {
            try {
                const settings = await dbManager.get('appSettings', 'settings') || {};
                
                // 只更新需要保存的部分，避免其他数据干扰
                settings.id = 'settings';
                settings.userProfile = userProfile;
                settings.homeWidgetData = homeWidgetData;

                await dbManager.set('appSettings', settings);
                console.log("Profile data saved successfully.");
            } catch (e) {
                console.error("保存个人信息时出错:", e);
                showAlert(`保存个人信息失败: ${e.message}`);
            }
        }

        // --- [REFACTORED] Data Saving Logic ---
        async function saveData() {
            try {
                // 并行保存所有数据到各自的表中
                const savePromises = [];

                // 1. 保存所有好友信息
                friends.forEach(friend => {
                    savePromises.push(dbManager.set('friends', friend));
                });

                // 2. 保存所有聊天记录
                Object.keys(chatHistories).forEach(friendId => {
                    savePromises.push(dbManager.set('chatHistories', { friendId, messages: chatHistories[friendId] }));
                });

                // 3. 保存其他列表数据
                diaries.forEach(d => savePromises.push(dbManager.set('diaries', d)));
                worldBooks.forEach(wb => savePromises.push(dbManager.set('worldBooks', wb)));
                worldBookFolders.forEach(f => savePromises.push(dbManager.set('worldBookFolders', f)));
                favorites.forEach(f => savePromises.push(dbManager.set('favorites', f)));
                moments.forEach(m => savePromises.push(dbManager.set('moments', m)));
                customEmojis.forEach(e => savePromises.push(dbManager.set('customEmojis', e))); // 假设 customEmojis 有 id

                // 4. 处理播放列表（隔离 File 对象）
                const serializablePlaylist = await Promise.all(playlist.map(async (song) => {
                    if (song.file instanceof File) {
                        return { ...song, file: await fileToSerializable(song.file) };
                    }
                    return song;
                }));
                // 清空旧表，然后写入新数据
                await dbManager.clear('playlist');
                serializablePlaylist.forEach(song => savePromises.push(dbManager.set('playlist', song)));

                // 5. 保存应用和API设置
                const appSettings = {
    id: 'settings',
    userPersonas: userPersonas,
    userProfile,
    homeWidgetData,
    selectedGlobalChatBg, customGlobalChatBgImage, selectedFont, selectedFontSize,
    selectedFontColor, customFontUrl, selectedWallpaper, customWallpaperImage,
    customWidgetBackgroundImage, roundedCornersEnabled, darkModeEnabled,
    sentBubbleColor, selectedAppLabelColor, receivedBubbleColor, customBubbleCSS,
    customIcons, recalledMessages: Array.from(recalledMessages.entries()),
    customListenBg, persistentVinylCover, profileWidgetTransparent,
    smallWidgetTransparent, simPhoneContentCache, 
    memoryGenerationTurns: memoryGenerationTurns, // <-- 新增：保存记忆轮数设置
};
                savePromises.push(dbManager.set('appSettings', appSettings));
                
                const apiSettings = { 
                    id: 'settings',
                    apiUrl: document.getElementById('apiUrl').value, 
                    apiKey: document.getElementById('apiKey').value, 
                    modelName: document.getElementById('modelName').value,
                    memoryTurns: document.getElementById('memoryTurns').value,
                    apiTemperature: document.getElementById('apiTemperature').value,
                    aiTimePerceptionEnabled: aiTimePerceptionEnabled
                };
                savePromises.push(dbManager.set('apiSettings', apiSettings));

                await Promise.all(savePromises);

            } catch (e) {
                console.error("保存数据时出错:", e);
                if (e.name === 'QuotaExceededError') {
                    showAlert("保存数据失败：存储空间已满！\n\n请尝试导出并清理数据。");
                } else {
                    showAlert(`保存数据失败: ${e.message}`);
                }
            }
        }

        // Helper functions for file serialization
        function fileToSerializable(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    resolve({
                        name: file.name,
                        type: file.type,
                        size: file.size,
                        lastModified: file.lastModified,
                        data: reader.result // This will be a Base64 string
                    });
                };
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        }

        function serializableToFile(serializable) {
            const byteString = atob(serializable.data.split(',')[1]);
            const mimeString = serializable.data.split(',')[0].split(':')[1].split(';')[0];
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            return new File([ab], serializable.name, { type: mimeString, lastModified: serializable.lastModified });
        }


        // --- [REFACTORED] Data Loading Logic ---
        async function loadData() {
            try {
                // 并行加载所有数据
                const [
                    loadedFriends, loadedChatHistories, loadedDiaries, loadedWorldBooks, 
                    loadedWorldBookFolders, loadedFavorites, loadedMoments, loadedPlaylist, 
                    loadedAppSettings, loadedApiSettings, loadedCustomEmojis, loadedMemories // <-- 新增
                ] = await Promise.all([
                    dbManager.getAll('friends'), dbManager.getAll('chatHistories'), dbManager.getAll('diaries'),
                    dbManager.getAll('worldBooks'), dbManager.getAll('worldBookFolders'), dbManager.getAll('favorites'),
                    dbManager.getAll('moments'), dbManager.getAll('playlist'), dbManager.get('appSettings', 'settings'),
                    dbManager.get('apiSettings', 'settings'), dbManager.getAll('customEmojis'),
dbManager.getAll('memories') // <-- 新增
                ]);
                
                if (!loadedAppSettings) {
                     console.log("No app settings found, initializing default data.");
                     await initDefaultData();
                     return;
                }
                
                // 整理加载的记忆数据
characterMemories = {};
(loadedMemories || []).forEach(memory => {
    if (!characterMemories[memory.friendId]) {
        characterMemories[memory.friendId] = [];
    }
    characterMemories[memory.friendId].push(memory);
});

                // 恢复好友数据
                friends = loadedFriends || [];
                                // 【【【新增代码：为旧数据兼容时间戳】】】
                friends.forEach(friend => {
                    if (!friend.lastMessageTimestamp) { // 如果这个好友没有时间戳
                        const history = chatHistories[friend.id] || [];
                        if (history.length > 0) {
                            // 就找到他/她聊天记录里的最后一条消息，把那条消息的时间补上
                            friend.lastMessageTimestamp = history[history.length - 1].timestamp;
                        }
                    }
                });
                // 确保所有好友（包括旧数据）都有轮数计数器
(loadedFriends || []).forEach(friend => {
    if (friend.turnCountSinceLastMemory === undefined) {
        friend.turnCountSinceLastMemory = 0;
    }
});
friends = loadedFriends || [];
                friends.forEach(f => { 
                    if (!f.chatBackground) f.chatBackground = { type: 'default', customImage: '' }; 
                    if (!f.worldBookIds) f.worldBookIds = [];
                    if (f.diaryWritingUrge === undefined) f.diaryWritingUrge = 0;
                    if (f.balance === undefined) f.balance = Infinity;
                    if (f.patAction === undefined) f.patAction = `拍了拍 "${f.name}"`;
                    if (f.heartsVoice === undefined) f.heartsVoice = { emoji: '( ´• ω •` )', thought: '...', dressing: '...', action: '...', favorability: '...' };
                });

                // 恢复聊天记录
                chatHistories = {};
                (loadedChatHistories || []).forEach(record => {
                    chatHistories[record.friendId] = record.messages;
                });

                // 恢复其他列表数据
                diaries = loadedDiaries || [];
                worldBooks = loadedWorldBooks || [];
                worldBookFolders = loadedWorldBookFolders || [];
                favorites = loadedFavorites || [];
                // 这是【修改后】的代码
moments = (loadedMoments || []).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                customEmojis = loadedCustomEmojis || [];

                // 恢复播放列表
                playlist = (loadedPlaylist || []).map(song => {
                    if (song.file && song.file.data) {
                        const file = serializableToFile(song.file);
                        return { ...song, file };
                    }
                    return song;
                });

               
// 恢复应用设置
const settings = loadedAppSettings;

if (settings.userPersonas && settings.userPersonas.length > 0) {
            // 新数据处理方式
            userPersonas = settings.userPersonas;
            userProfile = userPersonas.find(p => p.id === 'default_user') || userPersonas[0];
       
} else {
    userProfile = settings.userProfile || { id: 'default_user', name: '可点击编辑', avatar: '', avatarImage: '', personality: '一个普通人', background: '', signature: '可点击编辑', location: '可点击编辑', momentsCover: '', balance: 50000, patAction: '拍了拍' };

    userProfile.id = 'default_user'; 
    userPersonas = [userProfile];
}

                homeWidgetData = settings.homeWidgetData || homeWidgetData;
                selectedGlobalChatBg = settings.selectedGlobalChatBg || 'default';
                customGlobalChatBgImage = settings.customGlobalChatBgImage || '';
                selectedFont = settings.selectedFont || 'system';
                selectedFontSize = settings.selectedFontSize || 14;
                selectedFontColor = settings.selectedFontColor || '#000000';
                customFontUrl = settings.customFontUrl || '';
                selectedWallpaper = settings.selectedWallpaper || 'default';
                customWallpaperImage = settings.customWallpaperImage || '';
                customWidgetBackgroundImage = settings.customWidgetBackgroundImage || '';
                roundedCornersEnabled = settings.roundedCornersEnabled || false;
                darkModeEnabled = settings.darkModeEnabled || false;
                sentBubbleColor = settings.sentBubbleColor || '#FFEEF6';
                selectedAppLabelColor = settings.selectedAppLabelColor || '#333333';
                receivedBubbleColor = settings.receivedBubbleColor || '#E6F2FF';
                customBubbleCSS = settings.customBubbleCSS || '';
                customIcons = settings.customIcons || {};
                recalledMessages = new Map(settings.recalledMessages || []);
                customListenBg = settings.customListenBg || '';
                persistentVinylCover = settings.persistentVinylCover || '';
                profileWidgetTransparent = settings.profileWidgetTransparent || false;
                smallWidgetTransparent = settings.smallWidgetTransparent || false;
                simPhoneContentCache = settings.simPhoneContentCache || {};
memoryGenerationTurns = settings.memoryGenerationTurns || 20; // <-- 新增：加载记忆轮数设置
               
               
                
                // 恢复API设置
                if (loadedApiSettings) {
                    document.getElementById('apiUrl').value = loadedApiSettings.apiUrl || '';
                    document.getElementById('apiKey').value = loadedApiSettings.apiKey || '';
                    document.getElementById('modelName').value = loadedApiSettings.modelName || '';
                    document.getElementById('memoryTurns').value = loadedApiSettings.memoryTurns || 10;
                    document.getElementById('apiTemperature').value = loadedApiSettings.apiTemperature || 0.9;
                    aiTimePerceptionEnabled = loadedApiSettings.aiTimePerceptionEnabled !== false;
                    document.getElementById('aiTimePerceptionToggle').checked = aiTimePerceptionEnabled;
                }

                    } catch (e) {
            console.error('加载数据失败，这是一个严重错误:', e);
            // 只弹窗报错，不再自动清空数据！
            showAlert(`加载本地数据时发生严重错误，为防止数据丢失，请先导出数据备份。\n\n错误详情: ${e.message}`);
            // 我们不再调用 initDefaultData()，从而打破了恶性循环
            // await initDefaultData(); // 注释掉或删除这一行
        }

            // 加载完成后应用所有设置
            applyAllSettings();
            updateHomeWidget();
        }

        
        async function initDefaultData() {
            // 清空所有表
            await Promise.all(dbManager.stores.map(storeName => dbManager.clear(storeName)));
            
            // 设置默认值并保存
            friends = [];
userProfile = { id: 'default_user', name: '可点击编辑', avatar: '', avatarImage: '', personality: '一个普通人', background: '', signature: '可点击编辑', location: '可点击编辑', momentsCover: '', balance: 50000, patAction: '拍了拍' };
userPersonas = [userProfile];
            worldBooks = [];
            worldBookFolders = [];
            chatHistories = {};
            customEmojis = [];
            moments = [];
            playlist = [];
            simPhoneContentCache = {};
            
            await saveData();
        }

        function updateProfileDisplay() {
    document.getElementById('profileName').textContent = userProfile.name;
    const avatarElements = [document.getElementById('profileAvatar'), document.getElementById('widgetAvatar')];
    
    avatarElements.forEach(el => {
        if (!el) return; // 安全检查

        if (userProfile.avatarImage) {
            // --- 如果有自定义头像 ---
            // 1. 设置背景图片
            el.style.backgroundImage = `url(${userProfile.avatarImage})`;
            
            // 2. 为了覆盖CSS中的默认渐变背景，我们再次用图片来设置background属性
            el.style.background = `url(${userProfile.avatarImage})`; 
            el.style.backgroundSize = 'cover'; 
            el.style.backgroundPosition = 'center';

            // 3. 【【【核心修复】】】移除边框
            el.style.border = 'none'; // 或者 '0px'
            
            // 4. 清空文字
            el.textContent = '';
        } else {
            // --- 如果没有自定义头像 ---
            // 1. 移除背景图片
            el.style.backgroundImage = '';
            
            // 2. 恢复CSS中定义的默认样式（包括渐变背景和边框）
            el.style.background = ''; 
            el.style.border = ''; // 👈 这行会恢复CSS中定义的 `border: 3px solid rgba(0,0,0,0.1);`

            // 3. 显示文字
            el.textContent = userProfile.name ? userProfile.name.substring(0, 1) : '我';
        }
    });

    // 更新其他信息（保持不变）
    document.getElementById('widgetName').textContent = userProfile.name;
    document.getElementById('widgetSignature').textContent = userProfile.signature;
    document.getElementById('widgetLocation').textContent = userProfile.location;
}
        
        function updateHomeWidget() {
            document.getElementById('widgetHeaderText').textContent = homeWidgetData.headerText;
            document.getElementById('widgetImage1').src = homeWidgetData.image1;
            document.getElementById('widgetText1').textContent = homeWidgetData.text1;
            document.getElementById('widgetImage2').src = homeWidgetData.image2;
            document.getElementById('widgetText2').textContent = homeWidgetData.text2;
        }

        function editWidgetText(elementId, element) {
            currentEditingTextElement = element;
            const modal = document.getElementById('textEditModal');
            modal.querySelector('#textEditTitle').textContent = '编辑文字';
            const input = modal.querySelector('#newTextInput');
            input.value = element.textContent;
            modal.classList.add('show');
        }

        function closeTextEditModal() {
            document.getElementById('textEditModal').classList.remove('show');
            currentEditingTextElement = null;
        }
        
                async function confirmTextEdit() {
            if (currentEditingTextElement) {
                const newText = document.getElementById('newTextInput').value;
                const elementId = currentEditingTextElement.id;
                
                if (['widgetHeaderText', 'widgetText1', 'widgetText2'].includes(elementId)) {
                    if (newText.length > 10) {
                        showAlert('内容不能超过10个字符。');
                        return;
                    }
                }
                
                currentEditingTextElement.textContent = newText;

                // --- 核心修复在这里 ---
                if (elementId === 'widgetHeaderText') {
                    homeWidgetData.headerText = newText; // 直接使用正确的属性名
                } else {
                    const key = elementId.replace('widget', '').toLowerCase();
                    homeWidgetData[key] = newText;
                }
                // --- 修复结束 ---

                await saveProfileData(); // 使用专用的保存函数，更稳定
            }
            closeTextEditModal();
        }


        function editWidgetImage(imageId) {
            currentEditingWidgetImageId = imageId;
            document.getElementById('widgetImageInput').click();
        }

        function handleWidgetImageUpload(event) {
            const file = event.target.files[0];
            if (file && currentEditingWidgetImageId) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const imageUrl = e.target.result;
                    document.getElementById(currentEditingWidgetImageId).src = imageUrl;
                    // Save data
                    const key = currentEditingWidgetImageId.replace('widget', '').toLowerCase(); // e.g., 'image1'
                    homeWidgetData[key] = imageUrl;
                    await saveData();
                    currentEditingWidgetImageId = null;
                };
                reader.readAsDataURL(file);
            }
            // Reset file input to allow re-uploading the same file
            event.target.value = '';
        }

        function applyWallpaper() {

            const homeScreen = document.querySelector('.home-screen');
            if (!homeScreen) return;
            homeScreen.style.backgroundImage = (selectedWallpaper === 'custom' && customWallpaperImage) ? `url(${customWallpaperImage})` : 'none';
            homeScreen.style.backgroundColor = (selectedWallpaper === 'default' && !customWallpaperImage) ? 'var(--theme-bg, #f7f7f7)' : 'transparent';
        }

        function applyWidgetBackground() {}

        function openWallpaperSettings() {
            setActivePage('wallpaperSettingsScreen');
            const selector = selectedWallpaper === 'custom' ? '.custom' : `.${selectedWallpaper}`;
            document.querySelectorAll('#wallpaperGrid .background-option').forEach(opt => opt.classList.remove('selected'));
            const currentBg = document.querySelector(`#wallpaperGrid .background-option${selector}`);
            if (currentBg) currentBg.classList.add('selected');
        }

        function selectWallpaper(bgType) {
            selectedWallpaper = bgType;
            const selector = bgType === 'custom' ? '.custom' : `.${bgType}`;
            document.querySelectorAll('#wallpaperGrid .background-option').forEach(opt => opt.classList.remove ('selected'));
        }

        function handleWallpaperUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    customWallpaperImage = e.target.result;
                    selectedWallpaper = 'custom';
                    document.querySelectorAll('#wallpaperGrid .background-option').forEach(opt => opt.classList.remove('selected'));
                    let customOption = document.querySelector('#wallpaperGrid .background-option.custom');
                    if (!customOption) {
                        const grid = document.getElementById('wallpaperGrid'), uploadOption = grid. children[1];
                        customOption = document.createElement('div');
                        customOption.className = 'background-option custom';
                        customOption.onclick = () => selectWallpaper('custom');
                        grid.insertBefore(customOption, uploadOption.nextSibling);
                    }
                    customOption.style.backgroundImage = `url(${e.target.result})`;
                    customOption.classList.add('selected');
                    customOption.textContent = '';
                };
                reader.readAsDataURL(file);
            }
        }

        async function saveWallpaper() {
            applyWallpaper();
            await saveData();
            showAlert('壁纸已保存');
            backToTheme();
        }

        function changeLocation() { document.getElementById('locationModal').classList.add('show'); document.getElementById('newLocationInput').value = userProfile.location; }
        function closeLocationModal() { document.getElementById('locationModal').classList.remove('show'); document.getElementById('sendLocationModal').classList.remove('show'); }
        async function confirmChangeLocation() { userProfile.location = document.getElementById('newLocationInput').value.trim() || '可点击编辑'; updateProfileDisplay(); await saveData(); closeLocationModal(); }
        function changeSignature() { document.getElementById('signatureModal').classList.add('show'); document.getElementById('newSignatureInput').value = userProfile.signature; }
        function closeSignatureModal() { document.getElementById('signatureModal').classList.remove('show'); }
        async function confirmChangeSignature() { userProfile.signature = document.getElementById('newSignatureInput').value.trim() || '可点击编辑'; updateProfileDisplay(); await saveData(); closeSignatureModal(); }
        function changeName() { document.getElementById('nameModal').classList.add('show'); document.getElementById('newNameInput').value = userProfile.name; }
        function closeNameModal() { document.getElementById('nameModal').classList.remove('show'); }
        async function confirmChangeName() { const newName = document.getElementById('newNameInput').value.trim(); if (newName) { userProfile.name = newName; updateProfileDisplay(); await saveData(); closeNameModal(); } }
        
        function updateTime() { document.getElementById('currentTime').textContent = new Date().toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false }); }
        setInterval(updateTime , 1000);
        
        function updateStatusBar(pageId) {
            const phoneDiv = document.querySelector('.phone');
            phoneDiv.classList.remove('home-screen-active', 'listen-together-active', 'voice-call-active');
            if (pageId === 'homeScreen') {
                phoneDiv.classList.add('home-screen-active');
            } else if (pageId === 'listenTogetherScreen') {
                phoneDiv.classList.add('listen-together-active');
            } else if (pageId === 'voiceCallScreen' || pageId === 'incomingCallScreen') {
                phoneDiv.classList.add('voice-call-active');
            }
        }

        function setActivePage(pageId) {
            document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
            document.getElementById(pageId)?.classList.add('active');
            updateStatusBar(pageId);
        }

        function openApp(appName) {
    const appMap = { 
        'wechat': 'wechatApp', 
        'settings': 'settingsApp', 
        'worldbook': 'worldBookScreen', 
        'theme': 'themeApp', 
        'phone': 'phoneApp' 
    };

    // --- 这是我们新增的核心逻辑 ---
    // 当用户点击“设置”App时，
    // 我们从内存中读取 memoryGenerationTurns 的值，并更新输入框的显示
    if (appName === 'settings') {
        const inputElement = document.getElementById('memoryGenerationTurnsInput');
        if (inputElement) {
            inputElement.value = memoryGenerationTurns;
        }
    }
    // --- 新增逻辑结束 ---

    setActivePage(appMap[appName]);
    
    if (appName === 'worldbook') {
        updateWorldBookList();
    }
    if (appName === 'phone') {
        initPhoneApp();
    }
}

        function goHome() {
            setActivePage('homeScreen');
        }

        function applyFont() {
            const fontFamily = selectedFont === 'custom' ? 'var(--custom-font-family)' : '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            document.documentElement.style.setProperty('--font-family', fontFamily);
            document.documentElement.style.setProperty('--font-size', selectedFontSize + 'px');
            document.documentElement.style.setProperty('--small-font-size', (selectedFontSize - 2) + 'px');
            document.documentElement.style.setProperty('--nav-font-size', (selectedFontSize + 3) + 'px');
            document.documentElement.style.setProperty('--text-color', selectedFontColor);
        }

function applyAppLabelColor() {
    document.documentElement.style.setProperty('--app-label-color', selectedAppLabelColor);
}

        function applyGlobalChatBackground() {
            document.querySelectorAll('.chat-messages').forEach(screen => {
                const bgImage = (selectedGlobalChatBg === 'custom' && customGlobalChatBgImage) ? `url(${customGlobalChatBgImage})` : 'none';
                screen.style.backgroundImage = bgImage;
                screen.style.backgroundColor = (bgImage === 'none') ? 'var(--chat-bg, #ededee)' : 'transparent';
                screen.style.backgroundSize = 'cover';
                screen.style.backgroundPosition = 'center';
            });
        }
        
        function applyIndividualChatBackground(friend) {
            const chatScreen = document.getElementById('chatMessages');
            if (!chatScreen) return;
            // FIX: Prioritize global background if it's custom
            if (selectedGlobalChatBg === 'custom' && customGlobalChatBgImage) {
                applyGlobalChatBackground();
                return;
            }
            if (!friend || !friend.chatBackground || friend.chatBackground.type === 'default') return applyGlobalChatBackground();
            const bgSetting = friend.chatBackground;
            const bgImage = (bgSetting.type === 'custom' && bgSetting.customImage) ? `url(${bgSetting.customImage})` : 'none';
            if(bgImage !== 'none') {
                chatScreen.style.backgroundImage = bgImage;
                chatScreen.style.backgroundColor = 'transparent';
            } else {
                 applyGlobalChatBackground();
            }
        }
        
        /* 这是修改后的JS代码 */
function setChatAreaPadding(isOpen) {
    const messagesArea = document.getElementById('chatMessages');
    if (!messagesArea) return;
    const openHeight = 250; // height of function/emoji area
    const inputHeight = 65; // default height of input bar /* <--- 把 50 改成 65 */
    
    if (isOpen) {
        messagesArea.style.paddingBottom = (openHeight + inputHeight) + 'px';
    } else {
        messagesArea.style.paddingBottom = (inputHeight) + 'px';
    }
    
    // Scroll to bottom after padding change
    setTimeout(() => {
        messagesArea.scrollTop = messagesArea.scrollHeight;
    }, 100); 
}
        
        function hideFunctionMenus() {
            const area = document.getElementById('chatInputArea');
            if(area.classList.contains('functions-open') || area.classList.contains('emoji-open')) {
                area.classList.remove('functions-open', 'emoji-open');
                setChatAreaPadding(false);
            }
        }

        function toggleChatFunctions() {
            const area = document.getElementById('chatInputArea');
            const isOpening = !area.classList.contains('functions-open');
            area.classList.remove('emoji-open');
            area.classList.toggle('functions-open');
            setChatAreaPadding(isOpening);
            if (!isOpening) document.getElementById('messageInput').blur();
        }

        function toggleEmojiPicker() {
            const area = document.getElementById('chatInputArea');
            const isOpening = !area.classList.contains('emoji-open');
            area.classList.remove('functions-open');
            area.classList.toggle('emoji-open');
            if(isOpening) renderEmojiPicker();
            setChatAreaPadding(isOpening);
            if (!isOpening) document.getElementById('messageInput').blur();
        }
        
        // --- 照片功能 ---
        function selectPhoto() {
            document.getElementById('photoInput').click();
            hideFunctionMenus();
        }
        
        function handlePhotoUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    sendImageMessage(e.target.result, 'image');
                };
                reader.readAsDataURL(file);
            }
        }
        
                async function sendImageMessage(dataUrl, type = 'image', description = '', emojiName = '') { // <--- 加上 async
            const friend = friends.find(f => f.id === currentChatFriendId);
            const messageData = await saveChatMessage(currentChatFriendId, 'sent', dataUrl, '', null, type); // <--- 加上 await
            if (description) {
                messageData.imageDescription = description;
            }
            if (emojiName) {
                messageData.emojiName = emojiName;
            }
            addMessageToDOM(messageData, friend);
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.scrollTop = chatMessages.scrollHeight;
            hideFunctionMenus();
        }


        function openCameraModal() {
            hideFunctionMenus();
            document.getElementById('cameraDescInput').value = '';
            document.getElementById('cameraModal').classList.add('show');
        }
        function closeCameraModal() {
            document.getElementById('cameraModal').classList.remove('show');
        }
        function confirmCamera() {
            const description = document.getElementById('cameraDescInput').value.trim();
            if (!description) {
                showAlert('请填写图片描述');
                return;
            }
            const placeholderImageUrl = `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="150" height="150" viewBox="0 0 150 150"><rect width="100%" height="100%" fill="#e0e0e0"/><text x="50%" y="50%" font-family="sans-serif" font-size="14" fill="#808080" text-anchor="middle" dy=".3em">加载中...</text></svg>')}`;
            sendImageMessage(placeholderImageUrl, 'image', description);
            closeCameraModal();
        }
        
        function renderEmojiPicker() {
            const grid = document.getElementById('emojiGrid');
            grid.innerHTML = '';

            // Add button first
            const addItem = document.createElement('div');
            addItem.className = 'function-item';
            addItem.title = "添加表情";
            addItem.onclick = openAddEmojiModal;
            addItem.innerHTML = `
                <div class="function-icon" style="border: 2px dashed var(--border-color, #ccc); background: transparent; display: flex; align-items: center; justify-content: center; font-size: 28px; color: var(--text-secondary, #999);">+</div>
                <div class="function-label" style="opacity: 0;">-</div>
            `;
            grid.appendChild(addItem);

            customEmojis.forEach(emoji => {
                const item = document.createElement('div');
                item.className = 'function-item';
                item.title = emoji.name;
                item.setAttribute('data-emoji-name', emoji.name);
                item.onclick = () => { if (!isEmojiManaging) sendEmoji(emoji.url, emoji.name); };
                item.innerHTML = `
                    <div class="function-icon" style="background-image: url('${emoji.url}')"></div>
                    <div class="function-label" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 100%;">${emoji.name}</div>
                    <div class="emoji-delete-btn" onclick="deleteEmoji(event, '${emoji.name}')">&times;</div>
                `;
                grid.appendChild(item);
            });
        }
        
        function sendEmoji(url, name) {
            sendImageMessage(url, 'emoji', '', name);
            hideFunctionMenus();
        }
        
        function toggleEmojiManagement() {
            isEmojiManaging = !isEmojiManaging;
            const grid = document.getElementById('emojiGrid');
            const btn = document.getElementById('manageEmojiBtn');
            grid.classList.toggle('managing', isEmojiManaging);
            btn.textContent = isEmojiManaging ? '完成' : '管理';
            btn.classList.toggle('btn-primary', isEmojiManaging);
        }
        async function deleteEmoji(event, emojiName) {
            event.stopPropagation();
            const emojiToDelete = customEmojis.find(e => e.name === emojiName);
            if (emojiToDelete) {
                await dbManager.delete('customEmojis', emojiToDelete.id);
                customEmojis = customEmojis.filter(e => e.name !== emojiName);
                renderEmojiPicker();
            }
        }

        // --- [FIXED] Emoji Modal v2 Functions ---
        function openAddEmojiModal() {
            const singleTab = document.querySelector('.emoji-modal-tab[onclick*="single"]');
            switchEmojiAddMode(singleTab, 'single');
            document.getElementById('singleEmojiNameInput').value = '';
            document.getElementById('singleEmojiUrlInput').value = '';
            document.getElementById('singleEmojiUrlInput').disabled = false;
            document.getElementById('batchEmojiInput').value = '';
            singleEmojiFile = null;
            document.getElementById('singleEmojiUploadInput').value = '';
            document.getElementById('batchEmojiUploadInput').value = '';
            document.getElementById('addEmojiModal').classList.add('show');
        }

        function closeAddEmojiModal() {
            const modal = document.getElementById('addEmojiModal');
            if (modal.classList.contains('show')) {
                modal.classList.remove('show');
            }
        }

        function switchEmojiAddMode(tabElement, mode) {
            if (currentEmojiAddMode === mode && document.getElementById('addEmojiModal').classList.contains('show')) return;
            currentEmojiAddMode = mode;
            document.querySelectorAll('.emoji-modal-tab').forEach(tab => tab.classList.remove('active'));
            if(tabElement) tabElement.classList.add('active');
            document.querySelectorAll('.emoji-modal-content-view').forEach(view => view.classList.remove('active'));
            const activeViewId = mode === 'single' ? 'emojiSingleAddView' : 'emojiBatchAddView';
            const activeView = document.getElementById(activeViewId);
            if(activeView) activeView.classList.add('active');
        }


        function handleSingleEmojiUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            singleEmojiFile = file;
            if (!document.getElementById('singleEmojiNameInput').value) {
                document.getElementById('singleEmojiNameInput').value = file.name.replace(/\.[^/.]+$/, "");
            }
            document.getElementById('singleEmojiUrlInput').value = `已选择本地文件: ${file.name}`;
            document.getElementById('singleEmojiUrlInput').disabled = true;
        }

        function handleBatchEmojiUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;
            const existingText = document.getElementById('batchEmojiInput').value;
            let newText = '';
            // Store the files in a way we can access them later
            window.batchEmojiFiles = Array.from(files); 
            for (const file of files) {
                const name = file.name.replace(/\.[^/.]+$/, "");
                newText += `${name}：[本地文件: ${file.name}]\n`; // 使用中文冒号
            }
            document.getElementById('batchEmojiInput').value = (existingText ? existingText + '\n' : '') + newText;
            showAlert(`已准备 ${files.length} 个本地表情，点击"添加"以上传。`);
        }

        async function confirmAddEmoji() {
            if (currentEmojiAddMode === 'single') {
                await addSingleEmoji();
            } else {
                await addBatchEmojisV2();
            }
        }

        async function addSingleEmoji() {
            const name = document.getElementById('singleEmojiNameInput').value.trim();
            const url = document.getElementById('singleEmojiUrlInput').value.trim();
            
            if (!name) return showAlert('请输入表情名称。');
            if (!url && !singleEmojiFile) return showAlert('请输入URL或选择本地文件。');

            let imageUrl = url;
            if (singleEmojiFile) {
                try {
                    imageUrl = await fileToBase64(singleEmojiFile);
                } catch (e) {
                    showAlert('文件读取失败'); return;
                }
            }

            if(customEmojis.some(e => e.name === name)) return showAlert('该表情名称已存在。');
            
            const newEmoji = { name, url: imageUrl };
            const newId = await dbManager.set('customEmojis', newEmoji);
            newEmoji.id = newId;
            customEmojis.push(newEmoji);

            renderEmojiPicker();
            showAlert('表情添加成功！');
            closeAddEmojiModal();
        }

        async function addBatchEmojisV2() {
            const input = document.getElementById('batchEmojiInput').value.trim();
            const localFiles = window.batchEmojiFiles || [];

            if (!input) return showAlert('请输入表情信息。');

            const lines = input.split('\n');
            let addedCount = 0, errorCount = 0;
            const newEmojis = [];

            const processEntry = async (name, url) => {
                if (name && url) {
                    let finalUrl = url.trim();
                    const localFileMatch = finalUrl.match(/\[本地文件:\s*(.*?)\]/);

                    if (localFileMatch) {
                        const fileName = localFileMatch[1].trim();
                        const file = localFiles.find(f => f.name === fileName);
                        if (file) {
                            finalUrl = await fileToBase64(file);
                        } else {
                            errorCount++;
                            return; // Skip this entry
                        }
                    }

                    if (!customEmojis.some(e => e.name === name) && !newEmojis.some(e => e.name === name)) {
                        newEmojis.push({ name, url: finalUrl });
                        addedCount++;
                    }
                }
            };
            
            let currentName = null;
            let currentUrl = '';

            for (const line of lines) {
                const match = line.match(/^([^:：]+)[:：]\s*(.*)/); // 匹配中英文冒号
                if (match) {
                    // Process the previous entry before starting a new one
                    if (currentName) {
                        await processEntry(currentName, currentUrl);
                    }
                    currentName = match[1].trim();
                    currentUrl = match[2].trim();
                } else if (currentName) {
                    // This is a continuation of the previous URL (for multi-line URLs)
                    currentUrl += line.trim();
                }
            }
            // Process the last entry
            if (currentName) {
                await processEntry(currentName, currentUrl);
            }

            if (newEmojis.length > 0) {
                for(const emoji of newEmojis) {
                    const newId = await dbManager.set('customEmojis', emoji);
                    emoji.id = newId;
                    customEmojis.push(emoji);
                }
                renderEmojiPicker();
            }
            
            let message = '';
            if(addedCount > 0) message += `成功添加 ${addedCount} 个表情！\n`;
            if(errorCount > 0) message += `有 ${errorCount} 行格式错误、文件未找到或已存在，已跳过。`;

            showAlert(message || '未添加任何新表情。');

            if (addedCount > 0) {
                 window.batchEmojiFiles = []; // Clear cache
                 closeAddEmojiModal();
            }
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }
        // --- END Emoji Modal v2 Functions ---

        function handleFriendAvatarUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    friendAvatarImage = e.target.result;
                    const previewContainer = document.getElementById('friendAvatarUpload');
                    const previewText = document.getElementById('friendAvatarPreview');
                    previewContainer.style.backgroundImage = `url(${e.target.result})`;
                    previewText.textContent = '';
                };
                reader.readAsDataURL(file);
            }
        }

        function handleBackgroundUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    tempSelectedBackground.customImage = e.target.result;
                    tempSelectedBackground.type = 'custom';
                    document.querySelectorAll('#individualBgGrid .background-option').forEach(opt => opt.classList.remove('selected'));
                    let customOption = document.querySelector('#individualBgGrid .background-option.custom');
                    if (!customOption) {
                        const grid = document.getElementById('individualBgGrid'), uploadOption = grid.children[1];
                        customOption = document.createElement('div');
                        customOption.className = 'background-option custom';
                        customOption.onclick = () => selectBackground('custom');
                        grid.insertBefore(customOption, uploadOption.nextSibling);
                    }
                    customOption.style.backgroundImage = `url(${e.target.result})`;
                    customOption.classList.add('selected');
                    customOption.textContent = '';
                };
                reader.readAsDataURL(file);
            }
        }

        function handleGlobalChatBgUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    customGlobalChatBgImage = e.target.result;
                    selectedGlobalChatBg = 'custom';
                    document.querySelectorAll('#globalBgGrid .background-option').forEach(opt => opt.classList.remove('selected'));
                    let customOption = document.querySelector('#globalBgGrid .background-option.custom');
                    if (!customOption) {
                        const grid = document.getElementById('globalBgGrid'), uploadOption = grid.children[1];
                        customOption = document.createElement('div');
                        customOption.className = 'background-option custom selected';
                        customOption.onclick = () => selectGlobalChatBg('custom');
                        grid.insertBefore(customOption, uploadOption.nextSibling);
                    }
                    customOption.style.backgroundImage = `url(${e.target.result})`;
                    customOption.classList.add('selected');
                    customOption.textContent = '';
                };
                reader.readAsDataURL(file);
            }
        }

        function toggleAddMenu() { document.getElementById('addMenu').classList.toggle('show'); }
        function openAddFriend() { document.getElementById('addMenu').classList.remove('show'); document.getElementById('addFriendModal').classList.add('show'); }
        function closeAddFriendModal() {
            document.getElementById('addFriendModal').classList.remove('show');
            document.getElementById('friendNameInput').value = '';
            document.getElementById('friendRemarkInput').value = '';
            document.getElementById('friendRoleInput').value = '';
            friendAvatarImage = '';
            const previewContainer = document.getElementById('friendAvatarUpload');
            const previewText = document.getElementById('friendAvatarPreview');
            previewContainer.style.backgroundImage = '';
            previewText.textContent = '+';
        }

        async function addNewFriend() {
            const name = document.getElementById('friendNameInput').value.trim();
            if (!name) return showAlert('请填写好友昵称');
            const remark = document.getElementById('friendRemarkInput').value.trim();
            const role = document.getElementById('friendRoleInput').value.trim() || '你是一个友好的助手。';
            const newFriend = {
    id: generateUniqueId(),
    name: name,
    avatar: name.substring(0, 1),
    avatarImage: friendAvatarImage,
    remark: remark,
    role: role,
    lastMessage: '我们已经是好友了!',
    pinned: false,
    chatBackground: { type: 'default', customImage: '' },
    worldBookIds: [],
    boundFolderIds: [],
    diaryWritingUrge: 0,
    balance: Infinity,
    patAction: '',
    activeUserPersonaId: 'default_user', // <--- 核心改动就是增加了这一行！
    heartsVoice: { emoji: '( ´• ω •` )', thought: '...', dressing: '...', action: '...', favorability: '...' },
    turnCountSinceLastMemory: 0,
};
            const newId = await dbManager.set('friends', newFriend);
            newFriend.id = newId;
            friends.push(newFriend);

            // ...
updateFriendList();
document.getElementById('addMenu').classList.remove('show'); // <-- 请在这里添加这行代码
closeAddFriendModal();
showAlert('好友添加成功！');
// ...
        }
        
                        function openGroupChatModal() {
            document.getElementById('addMenu').classList.remove('show');
            const list = document.getElementById('groupChatFriendList');
            list.innerHTML = '';
            friends.filter(f => !f.isGroup).forEach(friend => {
                const item = document.createElement('div');
                item.className = 'multi-select-item';

                const avatarHtml = friend.avatarImage
                    ? `<div class="friend-avatar" style="background-image: url('${friend.avatarImage}');"></div>`
                    : `<div class="friend-avatar">${friend.avatar || friend.name.substring(0, 1)}</div>`;

                // 【【【核心修改在这里！】】】
                // 我们把 <input> 元素放到了最前面，
                // 然后是头像，最后是名字。
                item.innerHTML = `
                    <input type="checkbox" id="gc-${friend.id}" value="${friend.id}">
                    ${avatarHtml}
                    <label for="gc-${friend.id}">${friend.remark || friend.name}</label>
                `;
                list.appendChild(item);
            });
            document.getElementById('addGroupChatModal').classList.add('show');
        }

        function closeGroupChatModal() { document.getElementById('addGroupChatModal').classList.remove('show'); }
        
        async function createGroupChat() {
            const selectedMembers = [];
            document.querySelectorAll('#groupChatFriendList input:checked').forEach(checkbox => {
                selectedMembers.push(checkbox.value);
            });

            if (selectedMembers.length < 2) {
                showAlert('请至少选择2位好友。');
                return;
            }
            
            selectedMembers.push(userProfile.id);

            const memberNames = selectedMembers.map(id => {
                if (id === userProfile.id) return userProfile.name;
                const friend = friends.find(f => f.id === id);
                return friend ? (friend.remark || friend.name) : '';
            }).filter(Boolean);

            const groupName = memberNames.slice(0, 3).join('、') + (memberNames.length > 3 ? '...' : '');

            // --- ↓↓↓ 请用这个修改后的代码块替换 ↓↓↓ ---
const newGroup = {
    id: generateUniqueId(),
    name: groupName,
    avatar: '群',
    avatarImage: '', // 允许群聊有自定义头像
    isGroup: true,
    members: selectedMembers,
    lastMessage: '你已加入群聊',
    pinned: false,
    chatBackground: { type: 'default', customImage: '' },
    worldBookIds: [], // 新增：为群聊初始化世界书ID数组
    boundFolderIds: [] // 新增：为群聊初始化文件夹ID数组
};
// --- ↑↑↑ 替换结束 ↑↑↑ ---
            const newId = await dbManager.set('friends', newGroup);
            newGroup.id = newId;
            friends.push(newGroup);

            updateFriendList();
            closeGroupChatModal();
            showAlert('群聊创建成功！');
        }

                        function updateFriendList() {
            const list = document.getElementById('wechatMessages');
            list.innerHTML = '';

            // 【【【核心修改：全新的排序逻辑】】】
            const sortedFriends = [...friends].sort((a, b) => {
                // 规则1：如果置顶状态不同，置顶的永远排在前面
                if (a.pinned !== b.pinned) {
                    return b.pinned - a.pinned; // true(1) > false(0)，所以 b 会排在 a 前面
                }

                // 规则2：如果两个都是“非置顶”的，就按最新消息时间排序
                if (!a.pinned && !b.pinned) {
                    // 确保时间戳存在，防止老数据出错
                    const timeA = a.lastMessageTimestamp ? new Date(a.lastMessageTimestamp) : new Date(0);
                    const timeB = b.lastMessageTimestamp ? new Date(b.lastMessageTimestamp) : new Date(0);
                    return timeB - timeA; // 时间晚的（值更大）排在前面
                }

                // 规则3：如果两个都是“置顶”的，保持它们的相对位置不变
                return 0;
            });
            
            sortedFriends.forEach(friend => {
                const item = document.createElement('div');
                item.className = 'friend-item' + (friend.pinned ? ' pinned' : '');
                item.onclick = () => openChat(friend.id);
                const displayName = friend.remark || friend.name || '未知好友';
                
                let avatarHtml;
                if (friend.avatarImage) {
                    avatarHtml = `<div class="friend-avatar" style="background-image: url(${friend.avatarImage}); border: none;"></div>`;
                } else {
                    const avatarText = friend.avatar || (friend.name ? friend.name.substring(0, 1) : '?');
                    avatarHtml = `<div class="friend-avatar">${avatarText}</div>`;
                }
                
                let lastMessageContent = friend.lastMessage || '';
                if(friend.lastMessageContentType === 'image') lastMessageContent = '[图片]';
                if(friend.lastMessageContentType === 'emoji') lastMessageContent = '[表情]';
                if(friend.lastMessageContentType === 'voice') lastMessageContent = '[语音]';
                if(friend.lastMessageContentType === 'listen_invite') lastMessageContent = '[一起听歌]';
                if(friend.lastMessageContentType === 'transfer_request') lastMessageContent = '[转账]';
                if(friend.lastMessageContentType === 'transfer_accepted') lastMessageContent = '[转账]';
                if(friend.lastMessageContentType === 'pat_pat') lastMessageContent = '[拍一拍]';
                if(friend.lastMessageContentType === 'location') lastMessageContent = '[位置]';
                if(friend.lastMessageContentType === 'voice_call') lastMessageContent = '[语音通话]';

                item.innerHTML = `${avatarHtml}<div class="friend-info"><div class="friend-name">${displayName}</div><div class="friend-message">${lastMessageContent}</div></div>`;
                list.appendChild(item);
            });
        }

        function switchWechatTab(tab) {
    document.getElementById('addMenu').classList.remove('show'); // 步骤一的核心修复依然保留

    document.querySelectorAll('.wechat-tab').forEach(t => t.classList.remove('active'));
    document.querySelector(`.wechat-tab[onclick="switchWechatTab('${tab}')"]`)?.classList.add('active');
    document.getElementById('wechatMessages').style.display = 'none';
    document.getElementById('wechatDiscover').style.display = 'none';
    document.getElementById('wechatProfile').style.display = 'none';
    
    const navBar = document.querySelector('#wechatApp .nav-bar');
    const navTitle = navBar.querySelector('.nav-title');
    // ↓↓↓ 我们现在获取按钮本身，而不是它的容器 ↓↓↓
    const addBtn = document.getElementById('addMenuBtn'); 
    
    let title = '消息';
    if (tab === 'discover') { 
        title = '发现'; 
        document.getElementById('wechatDiscover').style.display = 'block'; 
        addBtn.style.display = 'none'; // 隐藏按钮
    } 
    else if (tab === 'profile') { 
        title = '我'; 
        document.getElementById('wechatProfile').style.display = 'block'; 
        updateWalletDisplay(); 
        addBtn.style.display = 'none'; // 隐藏按钮
    } 
    else { 
        document.getElementById('wechatMessages').style.display = 'block'; 
        addBtn.style.display = 'block'; // 显示按钮
    }
    navTitle.textContent = title;
}


        // ↓↓↓ 3.1 用这个新函数完整替换旧的 openChat 函数 ↓↓↓
function openChat(friendId) {
    const friend = friends.find(f => f.id === friendId);
    if (!friend) return;

    currentChatFriendId = friend.id;
    setActivePage('chatScreen');
    const chatTitle = friend.isGroup ? `${friend.name} (${friend.members.length})` : (friend.remark || friend.name);
    document.getElementById('chatTitle').textContent = chatTitle;
    document.getElementById('heartsVoiceBtn').style.display = friend.isGroup ? 'none' : 'flex';
    
    // --- 核心修改在这里 ---
    const functionMenu = document.getElementById('chatFunctions').querySelector('.function-menu');
    const listenTogetherButton = functionMenu.querySelector('.function-item[onclick="openListenTogether()"]');
    let redEnvelopeButton = functionMenu.querySelector('.function-item[onclick="openRedEnvelopeModal()"]');
    // 新增：获取或创建投票按钮
    let pollButton = functionMenu.querySelector('.function-item[onclick="openPollModal()"]');

    if (friend.isGroup) {
        // 如果是群聊
        if (listenTogetherButton) listenTogetherButton.style.display = 'none'; 
        
        // 红包按钮逻辑 (保持不变)
        if (!redEnvelopeButton) {
            redEnvelopeButton = document.createElement('div');
            redEnvelopeButton.className = 'function-item';
            redEnvelopeButton.setAttribute('onclick', 'openRedEnvelopeModal()');
            redEnvelopeButton.innerHTML = `<div class="function-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 4H4c-1.11 0-2 .89-2 2v12c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm-1 14H5c-.55 0-1-.45-1-1V7c0-.55.45-1 1-1h14c.55 0 1 .45 1 1v10c0 .55-.45 1-1 1zm-8-2h2v-4h4v-2h-4V8h-2v4H7v2h4v4z"/></svg></div><div class="function-label">红包</div>`;
            const locationButton = functionMenu.querySelector('.function-item[onclick="openLocationModal()"]');
            if (locationButton) {
                functionMenu.insertBefore(redEnvelopeButton, locationButton);
            } else {
                functionMenu.appendChild(redEnvelopeButton);
            }
        }
        redEnvelopeButton.style.display = 'flex';

        // 新增：投票按钮逻辑
        if (!pollButton) {
            pollButton = document.createElement('div');
            pollButton.className = 'function-item';
            pollButton.setAttribute('onclick', 'openPollModal()');
            pollButton.innerHTML = `<div class="function-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14H9v-4h2v4zm4 0h-2v-2h2v2zm0-4h-2V7h2v5z"/></svg></div><div class="function-label">投票</div>`;
            const transferButton = functionMenu.querySelector('.function-item[onclick="openTransferModal()"]');
            // 把投票按钮放在转账按钮后面
            if (transferButton) {
                 transferButton.insertAdjacentElement('afterend', pollButton);
            } else {
                functionMenu.appendChild(pollButton);
            }
        }
        pollButton.style.display = 'flex'; // 显示投票按钮

    } else {
        // 如果是私聊
        if (listenTogetherButton) listenTogetherButton.style.display = 'flex';
        if (redEnvelopeButton) redEnvelopeButton.style.display = 'none';
        if (pollButton) pollButton.style.display = 'none'; // 隐藏投票按钮
    }
    // --- 核心修改结束 ---

    renderInitialMessages();
    document.getElementById('chatMessages').onscroll = handleChatScroll;
}
        
        function getAvatarHtml(sender) {
    if (!sender) return `<div class="chat-avatar">?</div>`;
    const name = sender.name || '', avatarImage = sender.avatarImage || '';
    const avatarText = sender.avatar || (name ? name.substring(0, 1) : '?');
    
    // ↓↓↓ 核心修改就在下面这一行 ↓↓↓
    return avatarImage 
        ? `<div class="chat-avatar" data-sender-id="${sender.id}" style="background-image: url('${avatarImage}'); border: none;"></div>` 
        : `<div class="chat-avatar" data-sender-id="${sender.id}">${avatarText}</div>`;
    // ↑↑↑ 当有图片时，我们用内联样式强制移除边框 ↑↑↑
}
        // --- 【这是修改后的代码】 ---
async function handlePatPat(targetId) { // <--- 修复1：在这里加上 async
     const friend = friends.find(f => f.id === currentChatFriendId);
     if(!friend) return;

     const target = targetId === userProfile.id ? userProfile : friends.find(f => f.id === targetId);
     if(!target) return;

     const patter = userProfile;
     const patAction = patter.patAction || '拍了拍';
     const content = `你拍了拍"${target.name}"${patter.patAction || ''}`;
     
     // <--- 修复2：在这里加上 await
     const patMessage = await saveChatMessage(currentChatFriendId, 'sent', content, '', null, 'pat_pat');
     addPatPatMessageToDOM(patMessage);
}

        function addPatPatMessageToDOM(msg) {
            const container = document.getElementById('chatMessages');
            const patDiv = document.createElement('div');
            patDiv.className = 'pat-pat-message';
            patDiv.innerHTML = `<div class="pat-pat-content">${msg.content}</div>`;
            container.appendChild(patDiv);
            container.scrollTop = container.scrollHeight;
        }
        
        function toggleVoiceText(messageId) {
            const textEl = document.getElementById(`voice-text-${messageId}`);
            if (textEl) {
                textEl.style.display = textEl.style.display === 'block' ? 'none' : 'block';
            }
        }

        function addMessageToDOM(msg, friendOrGroup, containerId = 'chatMessages') {
    if (!msg || !msg.id) {
        console.error("addMessageToDOM called with invalid msgData:", msg);
        return null; 
    }

    const container = document.getElementById(containerId);
    if (!container) return null;

    // ↓↓↓ 【【【 你问的代码在这里！ 】】】 ↓↓↓
    // 它的作用就是处理 "XXX领取了你的红包" 这种系统消息
    if (msg.contentType === 'system_tip') {
        const tipDiv = document.createElement('div');
        tipDiv.className = 'system-message-tip';
        tipDiv.textContent = msg.content;
        container.appendChild(tipDiv);
        container.scrollTop = container.scrollHeight;
        return tipDiv; // 处理完直接返回，不执行下面的代码
    }
    // ↑↑↑ 【【【 它在这里！ 】】】 ↑↑↑

    if (msg.contentType === 'pat_pat') {
        return addPatPatMessageToDOM(msg);
    }

    if (msg.recalled) {
        const recallDiv = document.createElement('div');
        recallDiv.className = 'recall-message';
        let recallHTML = (msg.type === 'sent')
            ? `<div class="recall-content">你撤回了一条消息</div>`
            : `<div class="recall-content" onclick="showRecalledMessage('${msg.id}')">对方撤回了一条消息</div>`;
        recallDiv.innerHTML = recallHTML;
        container.appendChild(recallDiv);
        return recallDiv;
    }

    const msgDiv = document.createElement('div');
    msgDiv.className = `message ${msg.type}`;
    msgDiv.setAttribute('data-message-id', msg.id);
    
    // ↓↓↓ 请用这个新的代码块，替换旧的 if (msg.type === 'sent') { ... } 代码块 ↓↓↓

let sender = null;
if (msg.type === 'sent') {
    // --- 核心修改在这里 ---
    // 1. 先找到当前聊天的好友/群聊对象
    const currentChatTarget = friends.find(f => f.id === currentChatFriendId);
    
    // 2. 从这个对象上找到我们为他设置的“我的人设ID”
    const activePersonaId = currentChatTarget ? currentChatTarget.activeUserPersonaId : 'default_user';
    
    // 3. 根据这个ID，从人设列表里找出具体的人设信息
    const activePersona = userPersonas.find(p => p.id === activePersonaId) || userProfile;
    
    // 4. 用找到的这个人设作为发送者！
    sender = activePersona;
    // --- 修改结束 ---
    
} else if (friendOrGroup && friendOrGroup.isGroup) {
    sender = friends.find(f => f.id === msg.senderId);
} else {
    sender = friendOrGroup;
}

// ↑↑↑ 替换到这里结束 ↑↑↑

    if (!sender) sender = { name: '未知', avatar: '?' };

    let contentHTML;
    
    const hasImage = msg.contentType === 'image';
    const hasGroupRedEnvelope = msg.contentType === 'group_red_envelope';
    const hasPoll = msg.contentType === 'poll';
    const hasEmoji = msg.contentType === 'emoji';
    const hasVoice = msg.contentType === 'voice';
    const hasLocation = msg.contentType === 'location';
    const hasVoiceCallEnd = msg.contentType === 'voice_call';

    // ↓↓↓ 3.3 修改 addMessageToDOM 中的红包卡片逻辑 ↓↓↓
    if (hasGroupRedEnvelope) {
        const data = JSON.parse(msg.content);
        const isOpened = data.claimedBy.length >= data.totalCount;
        // --- 核心修改：onclick事件从 openRedEnvelopeDetails 改为 handleRedEnvelopeClick ---
        contentHTML = `
        <div class="red-envelope-card ${isOpened ? 'opened' : ''}" onclick="handleRedEnvelopeClick('${msg.id}')">
            <div class="red-envelope-card-body">
                <svg class="red-envelope-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M864 128H160c-17.673 0-32 14.327-32 32v696c0 17.673 14.327 32 32 32h704c17.673 0 32-14.327 32-32V160c0-17.673-14.327-32-32-32z m-32 728H192V192h640v664z" fill="#FFFFFF" /><path d="M512 448c-35.346 0-64 28.654-64 64s28.654 64 64 64 64-28.654 64-64-28.654-64-64-64z m0 96c-17.673 0-32-14.327-32-32s14.327-32 32-32 32 14.327 32 32-14.327 32-32 32z" fill="#FFFFFF" /><path d="M512 640C333.172 640 224 531.42 224 512c0-19.42 12.58-32 32-32s32 12.58 32 32c0 8.58 87.172 80 224 80s224-71.42 224-80c0-19.42 12.58-32 32-32s32 12.58 32 32c0 19.42-110.051 128-224 128z" fill="#FFFFFF" /></svg>
                <div class="red-envelope-info">
                    <div class="red-envelope-remark">${data.remark}</div>
                    <div class="red-envelope-status-text">${isOpened ? '红包已被领完' : '领取红包'}</div>
                </div>
            </div>
            <div class="red-envelope-footer">微信红包</div>
        </div>
        `;
        
        } else if (hasPoll) {
    const pollData = JSON.parse(msg.content);
    // 为每个选项生成HTML
    const optionsHtml = pollData.options.map((option, index) => {
        // 为每个投票者生成头像HTML
        const votersHtml = option.votes.map(voterId => {
            const voter = getAuthorById(voterId);
            return voter.avatarImage 
                ? `<div class="poll-voter-avatar" style="background-image: url(${voter.avatarImage})"></div>`
                : `<div class="poll-voter-avatar">${voter.avatar}</div>`;
        }).join('');

        return `
            <div class="poll-option-item">
                <span class="poll-option-text">${index + 1}. ${option.text}</span>
                <div class="poll-voters-line">${votersHtml}</div>
            </div>
        `;
    }).join('');

    contentHTML = `
        <div class="poll-card" id="poll-${pollData.id}">
            <div class="poll-card-header">
                <div class="poll-card-title">${pollData.title}</div>
                <div class="poll-card-subtitle">${pollData.voterCount || 0}人已参与</div>
            </div>
            <div class="poll-card-options">${optionsHtml}</div>
        </div>
    `;
        
    }  else if (hasVoice) {
                const textLength = msg.content.length;
                const duration = Math.max(1, Math.min(60, Math.round(textLength / 4)));
                const barWidth = Math.max(80, Math.min(220, 80 + textLength * 2.5));
                const voiceIconSVG = `<svg viewBox="0 0 24 24"><path d="M1 9l2 2c4.97-4.97 13.03-4.97 18 0l2-2C16.93 2.93 7.08 2.93 1 9zm8 8l3 3 3-3c-1.65-1.66-4.34-1.66-6 0zm-4-4l2 2c2.76-2.76 7.24-2.76 10 0l2-2C15.14 9.14 8.87 9.14 5 13z" opacity="0.8"/></svg>`;
                const sentContent = `<span class="voice-duration">${duration}"</span><div class="voice-play-icon">${voiceIconSVG}</div>`;
                const receivedContent = `<div class="voice-play-icon">${voiceIconSVG}</div><span class="voice-duration">${duration}"</span>`;
                contentHTML = `
                    <div class="message-body">
                        ${(friendOrGroup.isGroup && msg.type === 'received') ? `<div class="message-sender-name">${sender.name}</div>` : ''}
                        <div class="voice-message-bar" style="width: ${barWidth}px;" onclick="toggleVoiceText('${msg.id}')">
                           ${msg.type === 'sent' ? sentContent : receivedContent}
                        </div>
                        <div class="voice-text-content" id="voice-text-${msg.id}">${msg.content.replace(/\n/g, '<br>')}</div>
                    </div>`;
            } else if (msg.contentType === 'listen_invite') {
            content = `(用户向你发起了“一起听歌”的邀请，这是一个特殊操作卡片，你必须对此作出回应。)`;
                 const cardTitle = msg.type === 'sent' ? '你发起了听歌邀请' : `${sender.name}邀请你一起听歌`;
                 contentHTML = `
                    <div class="invite-card">
                        <div class="invite-card-title">${cardTitle}</div>
                        <div class="invite-card-body">
                           <div class="invite-card-icon-container">
                                <svg viewBox="0 0 24 24"><path d="M12,3V13.55A4,4 0 0,0 10,13A4,4 0 0,0 6,17A4,4 0 0,0 10,21A4,4 0 0,0 14,17V7H18V3H12Z" /></svg>
                           </div>
                           <span>一起听歌</span>
                        </div>
                        <div class="invite-card-footer">点击加入</div>
                    </div>`;
            } else if (msg.contentType === 'listen_accept') {
            const senderName = msg.type === 'sent' ? friend.name : userProfile.name;
                        content = `(${senderName} ${msg.type === 'sent' ? '向你发送了' : '接受了'} “一起听歌”邀请)`;
                 const cardTitle = `"${sender.name}"已加入`;
                 contentHTML = `
                    <div class="accept-card">
                         <div class="accept-card-body">${cardTitle}，一起享受音乐吧</div>
                         <div class="accept-card-footer">一起听歌</div>
                    </div>`;
            } else if (msg.contentType === 'pat_pat') { // *** 新增此块 ***
                        // msg.content 已经包含了拍一拍的具体描述
                        content = `(检测到一次“拍一拍”操作: ${msg.content})`;
                    } else if (msg.contentType === 'voice_call') { // *** 新增此块 ***
                        // msg.content 对于 voice_call 包含了通话时长
                        content = `(检测到一次语音通话记录。通话时长: ${msg.content})`;
                    } else if (msg.contentType === 'transfer_request') {
                const transferData = JSON.parse(msg.content);
                const isReceived = msg.transfer_status === 'received';
                const clickHandler = (msg.type === 'received' && !isReceived) ? `onclick="acceptTransfer('${msg.id}')"` : '';
                const disabledClass = isReceived ? 'disabled' : '';
                const remarkText = transferData.remark || (msg.type === 'sent' ? '转账给' + friendOrGroup.name : '微信转账');
                let footerText = '';
                if(isReceived) {
                    footerText = '已被接收';
                } else {
                    footerText = msg.type === 'sent' ? '待对方接收' : '待接收';
                }
                const amount = parseFloat(transferData.amount).toFixed(2);
                contentHTML = `
                    <div class="transfer-card ${disabledClass}" ${clickHandler}>
                        <div class="transfer-card-body">
                            <div class="transfer-card-icon-container">
                                <svg viewBox="0 0 24 24"><path d="M20 4H4c-1.11 0-2 .89-2 2v12c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm-1 14H5c-.55 0-1-.45-1-1V7c0-.55.45-1 1-1h14c.55 0 1 .45 1 1v10c0 .55-.45 1-1 1zm-8-2h2v-4h4v-2h-4V8h-2v4H7v2h4v4z"/></svg>
                            </div>
                            <div class="transfer-card-info">
                                <div class="transfer-card-amount">¥ ${amount}</div>
                                <div class="transfer-card-remark">${remarkText}</div>
                            </div>
                        </div>
                        <div class="transfer-card-footer">${footerText}</div>
                    </div>`;
            } else if (msg.contentType === 'transfer_accepted') {
                 const transferData = JSON.parse(msg.content);
                 const amount = parseFloat(transferData.amount).toFixed(2);
                 const statusText = msg.type === 'sent' ? '已收款' : `已收款`;
                 const remarkText = `微信转账`;
                 contentHTML = `
                    <div class="transfer-confirm-card">
                        <div class="transfer-card-body">
                            <div class="transfer-card-icon-container">
                                <svg viewBox="0 0 24 24"><path d="M12,2C6.48,2,2,6.48,2,12s4.48,10,10,10s10-4.48,10-10S17.52,2,12,2z M10,17l-5-5l1.41-1.41L10,14.17l7.59-7.59L19,8l-9,9z"/></svg>
                            </div>
                            <div class="transfer-confirm-info">
                                <div class="transfer-card-amount">¥ ${amount}</div>
                                <div class="transfer-card-status">${statusText}</div>
                            </div>
                        </div>
                        <div class="transfer-card-footer">${remarkText}</div>
                    </div>`;
            } else if (hasLocation) {
                 const locationData = JSON.parse(msg.content);
                 contentHTML = `
                    <div class="location-card">
                        <div class="location-card-info">
                            <div class="location-card-title">${locationData.name}</div>
                            <div class="location-card-address">${locationData.address}</div>
                        </div>
                        <div class="location-card-map">
                            <svg class="location-card-pin" viewBox="0 0 30 30" xmlns="http://www.w3.org/2000/svg">
                                <defs>
                                    <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                                        <feDropShadow dx="0" dy="2" stdDeviation="2" flood-color="#000" flood-opacity="0.3"/>
                                    </filter>
                                </defs>
                                <circle cx="15" cy="15" r="10" fill="#4CAF50" filter="url(#shadow)"/>
                                <circle cx="15" cy="15" r="4" fill="white"/>
                            </svg>
                        </div>
                        <div class="location-card-footer">
                            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAfRJREFUWEfFlk1oVEEUhp9v7r6Y1QyCFDAiCCIiGpeiC5cuBUEUcaELVwYVQRChIoVbcKEuBBclwYWgG2/cCP6AIIqIoGjcCP5AEG9EEUWgsdk9zM6 e9+bNW29iIPDJzHtz73/v/ec+5xBIQMAvQGQAe0GugAxgBsB3gA0gDkga0T6cBDoA6kF8ALgC2gCqgAsBq9Uj1f4A9AFeAVUDAfA86ALGAF1ARsA2YA8oAYoAacAeYAlQA/QBFwJ2B1lA2iFkAm6AR5bQWgJmAZ/d+QBM6gM+A/YCHQA+gZ/Iu6cDBvAlUANk+w/A2xL42n4A/gV4L9r4vU+wM4ApoAawCdgG1AL2gC6A/SAK6CPL4/eYcQ7gM2A+gC2gDygCjgZtI18d0AfEABgGDAE6Ab3Am5I4a/KkXUjGjAOmALUALUAL0AfsAj6AnC9bA+oAh4DPAQvA/lAdEGBvQUoBfYAVgB7gAtB20gK0B6jR50/lD3/eP/w11X/k3y+QNwLdAb+BRoD9ID6AG8C+gCagDbgCEgfEAIgAfgNqAb0AecAp8P/Fw/oAZQDbQAswCzgHlIH6AJ2ABmAXsAbkAfaALoB9gC/ARqAPODGQK3mX/yC+A3wGvG0u3p2p/wBfAz4FvI7p8QAAAABJRU5ErkJggg==" alt="Tencent Map">
                            <span>腾讯地图</span>
                        </div>
                    </div>
                `;
            } else if (hasImage || hasEmoji) {
                const clickHandler = msg.imageDescription ? `onclick="showImageDescription('${msg.imageDescription.replace(/'/g, "\\'").replace(/"/g, '&#34;').replace(/\n/g, '\\n')}')"` : `onclick="viewImage('${msg.content}')"`;
                contentHTML = `<img src="${msg.content}" ${clickHandler}>`;
            } else if(hasVoiceCallEnd) {
                 contentHTML = `<span>通话时长 ${msg.content}</span><svg class="call-icon" viewBox="0 0 24 24"><path d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56-.35-.12-.74-.03-1.01.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.59l2.2-2.2c.27-.27.35-.66.24-1.01-.37-1.11-.56-2.3-.56-3.53 0-.54-.45-.99-.99-.99H4.19C3.65 3 3 3.24 3 3.99 3 13.28 10.73 21 20.01 21c.75 0 .99-.65.99-.99v-3.45c0-.54-.45-.98-.99-.98z"/></svg>`;
            } else {
                contentHTML = (msg.content || '').replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, '<br>');
                if (msg.quoted) {
                    let quotedContent = (msg.quoted || '').replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, '<br>');
                    contentHTML = `<div class="quoted-message">${quotedContent}</div>${contentHTML}`;
                }
            }

            const contentClass = `message-content ${hasImage ? 'has-image' : ''} ${hasEmoji ? 'has-emoji' : ''} ${hasVoice ? 'has-voice' : ''} ${hasGroupRedEnvelope ? 'has-red-envelope' : ''} ${hasPoll ? 'has-poll' : ''} ${(msg.contentType.startsWith('listen_') || msg.contentType.startsWith('transfer_') || hasLocation) ? 'has-image' : ''} ${hasVoiceCallEnd ? 'has-voice-call-end' : ''}`;
            const senderNameHtml = (friendOrGroup.isGroup && msg.type === 'received') ? `<div class="message-sender-name">${sender.name}</div>` : '';
            
            if (containerId === 'listenTogetherChatOverlay') {
                 const existingMsg = container.querySelector('.message');
                 if(existingMsg) {
                    existingMsg.classList.remove('show');
                    setTimeout(() => existingMsg.remove(), 500);
                 }
                 msgDiv.innerHTML = contentHTML;
                 container.appendChild(msgDiv); 
                 setTimeout(() => {
                     msgDiv.classList.add('show');
                     setTimeout(() => {
                        msgDiv.classList.remove('show');
                        setTimeout(() => msgDiv.remove(), 4000);
                     }, 4000);
                 }, 50);
            } else if (hasVoice) {
                msgDiv.innerHTML = (msg.type === 'sent') ? `${contentHTML}${getAvatarHtml(sender)}` : `${getAvatarHtml(sender)}${contentHTML}`;
                container.appendChild(msgDiv);
            } else {
                 const messageBodyHtml = `<div class="message-body">${senderNameHtml}<div class="${contentClass}">${contentHTML}</div></div>`;
                msgDiv.innerHTML = (msg.type === 'sent') ? `${messageBodyHtml}${getAvatarHtml(sender)}` : `${getAvatarHtml(sender)}${messageBodyHtml}`;
                container.appendChild(msgDiv);
            }

            const contentEl = msgDiv.querySelector('.message-content, .voice-message-bar');
            if(contentEl && containerId !== 'listenTogetherChatOverlay') {
                contentEl.addEventListener('contextmenu', (e) => showMessageMenu(e, contentEl));
                contentEl.addEventListener('touchstart', (e) => handleTouchStart(e, contentEl));
                contentEl.addEventListener('touchmove', handleTouchMove);
                contentEl.addEventListener('touchend', handleTouchEnd);
            }
             
                        // NEW: Add long-press for pat-pat on avatar
            const avatarEl = msgDiv.querySelector('.chat-avatar');
            if (avatarEl && sender.id !== userProfile.id) {
                 let patTimer;
                 avatarEl.addEventListener('touchstart', (e) => {
                     // 阻止默认的触摸行为，比如页面滚动
                     e.preventDefault();
                     patTimer = setTimeout(() => {
                         handlePatPat(sender.id);
                         patTimer = null;
                     }, 500); // 500ms for long press
                 });
                 avatarEl.addEventListener('touchend', () => {
                     clearTimeout(patTimer);
                 });
                 avatarEl.addEventListener('touchmove', () => {
                     clearTimeout(patTimer);
                 });
                 
                 // ↓↓↓ 新增的核心代码就在这一行 ↓↓↓
                 // 明确地阻止在安卓上长按时触发的“右键菜单”事件
                 avatarEl.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            return msgDiv;
        }

        let lastMessageTimestamp = null;
        // 新功能：仅渲染初始的最近消息
function renderInitialMessages() {
    const container = document.getElementById('chatMessages');
    container.innerHTML = ''; // 清空容器
    lastMessageTimestamp = null;
    const friend = friends.find(f => f.id === currentChatFriendId);
    if (!friend) return;
    
    applyIndividualChatBackground(friend); // 应用聊天背景
    
    const history = chatHistories[currentChatFriendId] || [];
    if (history.length === 0) {
        currentlyDisplayedMessageCount = 0;
        return;
    }

    const initialMessages = history.slice(-CHAT_PAGE_SIZE);
    currentlyDisplayedMessageCount = initialMessages.length;

    // 如果还有更多历史消息，就在顶部显示一个提示
    if (history.length > currentlyDisplayedMessageCount) {
         const loadMoreDiv = document.createElement('div');
         loadMoreDiv.id = 'loadMoreIndicator';
         loadMoreDiv.style.textAlign = 'center';
         loadMoreDiv.style.padding = '10px';
         loadMoreDiv.style.color = '#999';
         loadMoreDiv.style.fontSize = '12px';
         loadMoreDiv.textContent = '--- 上滑加载更多记录 ---';
         container.appendChild(loadMoreDiv);
    }

    const fragment = document.createDocumentFragment();
    initialMessages.forEach(msg => {
        // 这部分逻辑和旧函数一样，用于处理时间戳和消息内容
        const msgTimestamp = new Date(msg.timestamp);
        if (lastMessageTimestamp && (msgTimestamp - lastMessageTimestamp) > 15 * 60 * 1000) {
            const timeDiv = document.createElement('div');
            timeDiv.className = 'chat-timestamp';
            timeDiv.textContent = msgTimestamp.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
            fragment.appendChild(timeDiv);
        }
        lastMessageTimestamp = msgTimestamp;
        addMessageToDOM(msg, friend);
        const msgElement = container.lastElementChild;
        if(msgElement) fragment.appendChild(msgElement);
    });
    
    container.appendChild(fragment);
    // 滚动到底部
    container.scrollTop = container.scrollHeight;
}

// 这是【修正后】的完整函数，请直接替换
async function loadPreviousMessages() {
    if (isLazyLoading) return;
    isLazyLoading = true;

    const container = document.getElementById('chatMessages');
    const friend = friends.find(f => f.id === currentChatFriendId);
    let indicator = document.getElementById('loadMoreIndicator');
    if (indicator) indicator.textContent = '--- 正在加载... ---';

    await new Promise(res => setTimeout(res, 300));

    const history = chatHistories[currentChatFriendId] || [];
    const remainingMessagesCount = history.length - currentlyDisplayedMessageCount;

    if (remainingMessagesCount <= 0) {
        if (indicator) indicator.textContent = '--- 没有更多记录了 ---';
        setTimeout(() => { if (indicator) indicator.remove(); }, 2000);
        isLazyLoading = false;
        return;
    }

    const nextBatchSize = Math.min(remainingMessagesCount, CHAT_PAGE_SIZE);
    const nextMessages = history.slice(remainingMessagesCount - nextBatchSize, remainingMessagesCount);

    const oldScrollHeight = container.scrollHeight;
    
    // 创建一个临时的“篮子”（DocumentFragment）来装新的消息元素
    const fragment = document.createDocumentFragment();

    // **【核心修正】**
    // 我们不再反转数组，而是按正常顺序遍历
    nextMessages.forEach(msg => {
        // 让 addMessageToDOM 创建好消息元素，但先不显示
        const msgElement = addMessageToDOM(msg, friend);
        // 把创建好的元素放进“篮子”里
        if (msgElement) {
            fragment.appendChild(msgElement);
        }
    });

    // **【核心修正】**
    // 一次性把“篮子”里所有排好队的消息，插入到聊天记录的最顶端
    // (插入到“加载更多”提示语的后面)
    container.insertBefore(fragment, container.firstChild.nextSibling);
    
    // 保持你刚才看的位置不变，不会因为加载了新内容而跳动
    container.scrollTop = container.scrollHeight - oldScrollHeight;

    currentlyDisplayedMessageCount += nextBatchSize;
    if (indicator) indicator.textContent = '--- 上滑加载更多记录 ---';
    isLazyLoading = false;
}

// 新增：处理滚动事件的函数
function handleChatScroll(event) {
    // 当滚动到最顶部时，触发加载
    if (event.target.scrollTop === 0) {
        loadPreviousMessages();
    }
}

                async function saveChatMessage(friendId, type, content, quoted = '', senderId = null, contentType = 'text') {
            if (!friendId) {
                console.error("saveChatMessage called without friendId");
                return null;
            }
            if (!chatHistories[friendId]) chatHistories[friendId] = [];
            const friend = friends.find(f => f.id === friendId);

            const message = { 
                id: generateUniqueId(), 
                type, 
                content,
                contentType,
                quoted, 
                timestamp: new Date().toISOString(), // 我们用这个时间
                recalled: false,
                senderId: type === 'sent' ? userProfile.id : (senderId || friend.id)
            };
            
            if (contentType === 'transfer_request') {
                message.transfer_status = 'pending';
            }

            chatHistories[friendId].push(message);
            
            if (friend && contentType !== 'pat_pat') {
                let lastMsgPrefix = '';
                if(friend.isGroup && type === 'received'){
                    const sender = friends.find(f => f.id === senderId);
                    lastMsgPrefix = sender ? `${sender.name}: ` : '';
                }
                
                let lastMessageText;
                switch(contentType) {
                    case 'group_red_envelope': lastMessageText = '[红包]'; break;
                    case 'image': lastMessageText = '[图片]'; break;
                    case 'emoji': lastMessageText = '[表情]'; break;
                    case 'voice': lastMessageText = '[语音]'; break;
                    case 'location': lastMessageText = '[位置]'; break;
                    case 'listen_invite': lastMessageText = '[邀请你一起听歌]'; break;
                    case 'listen_accept': lastMessageText = '[已加入一起听]'; break;
                    case 'transfer_request': lastMessageText = '[转账]'; break;
                    case 'transfer_accepted': lastMessageText = '[转账]'; break;
                    case 'voice_call': lastMessageText = '[语音通话]'; break;
                    default: lastMessageText = content;
                }

                friend.lastMessage = lastMsgPrefix + (lastMessageText.length > 20 ? lastMessageText.substring(0, 20) + '...' : lastMessageText);
                friend.lastMessageContentType = contentType;
                
                // 【【【新增代码：记录最新消息时间】】】
                // 我们把这条消息的时间，也存到好友自己的数据里。
                friend.lastMessageTimestamp = message.timestamp;
            }


            if (friend && !friend.isGroup && contentType !== 'pat_pat' && contentType !== 'system') {
                if (friend.diaryWritingUrge === undefined) {
                    friend.diaryWritingUrge = 0;
                }
                friend.diaryWritingUrge += Math.floor(Math.random() * 10) + 5; 
            }

            await dbManager.set('chatHistories', { friendId, messages: chatHistories[friendId] });
            await dbManager.set('friends', friend);
            updateFriendList();
            return message;
        }

        function backToWechat() {document.getElementById('chatMessages').onscroll = null; // 新增：移除滚动监听
            setActivePage('wechatApp');
            hideFunctionMenus();
            if (multiSelectMode) exitMultiSelectMode();
            currentChatFriendId = null; 
            updateFriendList();
            switchWechatTab('messages');
        }

        function handleTouchStart(e, el) {
            clearTimeout(longPressTimer);
            longPressTimer = setTimeout(() => {
                longPressTimer = null;
                showMessageMenu(e, el);
            }, 500);
        }

        function handleTouchMove() { clearTimeout(longPressTimer); }
        function handleTouchEnd() { clearTimeout(longPressTimer); }

                function showMessageMenu(event, el) {
            event.preventDefault();
            event.stopPropagation();
            currentMessageElement = el;
            const menu = document.getElementById('messageMenu');
            const messageDiv = el.closest('.message');
            const msgId = messageDiv.getAttribute('data-message-id');
            const history = chatHistories[currentChatFriendId] || [];
            const msgIndex = history.findIndex(m => String(m.id) === msgId);
            const msg = history[msgIndex];
            const isSent = messageDiv.classList.contains('sent');
            
            let menuItems = '';

            // 【【【核心修改在这里】】】
            // 检查这是否是AI回复的第一条消息
            // 条件1: 这条消息是AI发的 (type === 'received')
            // 条件2: 这条消息不是历史记录里的第一条 (msgIndex > 0)
            // 条件3: 这条消息的前一条是用户发的 (history[msgIndex - 1].type === 'sent')
            if (msg && msg.type === 'received' && msgIndex > 0 && history[msgIndex - 1].type === 'sent') {
                // 如果满足所有条件，就添加“重试”按钮
                menuItems += `<div class="message-menu-item" onclick="regenerateAiResponse('${msg.id}')">重试</div>`;
            }
            // 【【【修改结束】】】

            if (msg && (msg.contentType === 'text' || msg.contentType === 'voice')) {
                 menuItems += `<div class="message-menu-item" onclick="quoteMessage()">引用</div>`;
            }
            menuItems += `<div class="message-menu-item" onclick="favoriteMessage()">收藏</div><div class="message-menu-item" onclick="startMultiSelect()">多选</div>`;
            if (isSent) {
                menuItems += `<div class="message-menu-item" onclick="recallMessage()">撤回</div>`;
            }
            menuItems += `<div class="message-menu-item danger" onclick="deleteMessage()">删除</div>`;

            menu.innerHTML = menuItems;
            menu.classList.add('show');
            const rect = el.getBoundingClientRect();
            let x = rect.left + window.scrollX, y = rect.bottom + window.scrollY + 5;
            menu.style.left = `${x}px`; menu.style.top = `${y}px`;
            if (x + menu.offsetWidth > window.innerWidth) menu.style.left = `${window.innerWidth - menu.offsetWidth - 10}px`;
            if (y + menu.offsetHeight > window.innerHeight) menu.style.top = `${rect.top + window.scrollY - menu.offsetHeight - 5}px`;
            setTimeout(() => document.addEventListener('click', hideMessageMenu, { once: true }), 0);
        }

        function hideMessageMenu() { document.getElementById('messageMenu')?.classList.remove('show'); }

        function recallMessage() {
    showConfirm('确定要撤回这条消息吗？', async (confirmed) => {
        if (!confirmed) return;

        // 步骤1：获取消息ID和它在界面上的HTML元素
        const messageDiv = currentMessageElement.closest('.message');
        const msgId = messageDiv.getAttribute('data-message-id');
        const msg = (chatHistories[currentChatFriendId] || []).find(m => String(m.id) === msgId);

        if (msg) {
            // 步骤2：在后台更新数据，把消息标记为"已撤回"
            msg.recalled = true;
            msg.recalledContent = msg.content;
            await saveData();

            // 步骤3：创建一个新的"已撤回"提示的HTML元素
            const recallDiv = document.createElement('div');
            recallDiv.className = 'recall-message';
            recallDiv.innerHTML = `<div class="recall-content">你撤回了一条消息</div>`;

            // 步骤4：在界面上，用新的"已撤回"提示替换掉原来的消息内容，实现立即刷新
            if (messageDiv && messageDiv.parentNode) {
                messageDiv.parentNode.replaceChild(recallDiv, messageDiv);
            }
        }
        // 注意：我们不再调用 loadChatHistory()
    });
}

        function quoteMessage() {
            const msgId = currentMessageElement.closest('.message').getAttribute('data-message-id');
            const msg = (chatHistories[currentChatFriendId] || []).find(m => String(m.id) === msgId);
            if(!msg) return;

            let content;
            if (msg.contentType === 'voice') {
                content = '[语音]';
            } else {
                content = msg.content;
            }

            quotedMessage = content.length > 50 ? content.substring(0, 50) + '...' : content;
            const input = document.getElementById('messageInput');
            input.placeholder = `回复: ${quotedMessage}`;
            input.focus();
        }

        async function favoriteMessage() {
            const msgId = currentMessageElement.closest('.message').getAttribute('data-message-id');
            const msg = (chatHistories[currentChatFriendId] || []).find(m => String(m.id) === msgId);
            if(!msg) return;
            
            const friend = friends.find(f => f.id === currentChatFriendId);
            const newFav = { id: generateUniqueId(), content: msg.content, contentType: msg.contentType, from: friend ? (friend.remark || friend.name) : '未知', timestamp: new Date().toISOString() };
            const newId = await dbManager.set('favorites', newFav);
            newFav.id = newId;
            favorites.push(newFav);
            
            showAlert('已收藏');
        }

        function deleteMessage() {
    showConfirm('确定要删除这条消息吗？', async (confirmed) => {
        if (!confirmed) return;

        // 步骤1：获取消息ID和它在界面上的HTML元素
        const messageDiv = currentMessageElement.closest('.message');
        const msgId = messageDiv.getAttribute('data-message-id');

        // 步骤2：直接从界面上移除这个HTML元素，实现立即刷新
        if (messageDiv) {
            messageDiv.remove();
        }

        // 步骤3：在后台更新数据存档
        chatHistories[currentChatFriendId] = (chatHistories[currentChatFriendId] || []).filter(m => String(m.id) !== msgId);
        
        // 步骤4：保存更新后的数据
        await saveData();
        
        // 注意：我们不再调用 loadChatHistory()
    });
}
        
                async function sendMessage() { // <--- 在这里加上 async
            const input = document.getElementById('messageInput');
            const messageText = input.value.trim();
            if (!messageText) return;
            const friend = friends.find(f => f.id === currentChatFriendId);
            
            const msgData = await saveChatMessage(currentChatFriendId, 'sent', messageText, quotedMessage); // <--- 在这里加上 await
            addMessageToDOM(msgData, friend);
            currentlyDisplayedMessageCount++;
            
            document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
            input.value = '';
            input.placeholder = '输入消息...';
            toggleSendButtonActive(input);
            quotedMessage = '';
            hideFunctionMenus();
        }
        
        function requestAIResponse() {
            // 这是【修正后】的代码
if (aiReplyingSet.has(currentChatFriendId)) return showAlert('AI正在回复中，请稍候...');
            const inListenScreen = document.getElementById('listenTogetherScreen').classList.contains('active');
            receiveMessage(currentChatFriendId, null, inListenScreen);
        }
        
        // --- [新增] 获取高精度、格式化时间信息的函数 ---
        function getDetailedTimeInfo() {
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth() + 1;
            const day = now.getDate();
            const week = ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"][now.getDay()];
            const hours = now.getHours();
            const minutes = now.getMinutes().toString().padStart(2, '0');
            
            let timeOfDay;
            if (hours >= 5 && hours < 11) timeOfDay = "早上";
            else if (hours >= 11 && hours < 14) timeOfDay = "中午";
            else if (hours >= 14 && hours < 18) timeOfDay = "下午";
            else if (hours >= 18 && hours < 23) timeOfDay = "晚上";
            else timeOfDay = "深夜";

            return {
                fullDate: `${year}年${month}月${day}日`,
                week: week,
                time: `${hours}:${minutes}`,
                timeOfDay: timeOfDay
            };
        }
        
                                                                                /**
 * 核心消息接收函数 (V2 - 健壮性增强版)
 * 这个函数现在被一个完整的 try...catch...finally 结构包裹，以确保：
 * 1. 无论API请求成功还是失败，程序都不会崩溃。
 * 2. 无论发生什么情况，“对方正在输入...”的状态最终都会被清除。
 * 3. 任何网络错误或API返回的错误都会被捕获，并以友好的方式提示给用户。
 */
async function receiveMessage(friendId, customPrompt = null, isFromListenScreen = false) {
    const friend = friends.find(f => f.id === friendId);
    // --- 新增：离线时间感知模块 ---
let timeGapContext = ''; // 先准备一个空“情报”
const history = chatHistories[friendId] || []; // 获取当前聊天记录

// 确保至少有两条消息（你的上一条和AI的上一条）才能计算间隔
if (history.length >= 2) {
    const lastMessage = history[history.length - 1]; // 你刚刚发的消息
    const previousMessage = history[history.length - 2]; // 在你发之前，最后的一条消息

    // 计算两条消息之间差了多少分钟
    const timeDiffMinutes = (new Date(lastMessage.timestamp) - new Date(previousMessage.timestamp)) / (1000 * 60);

    // 如果间隔超过60分钟（1小时），我们就准备一份“特别情报”
    if (timeDiffMinutes > 60) {
        let timeAwayText;
        if (timeDiffMinutes < 120) {
            timeAwayText = "一个多小时";
        } else if (timeDiffMinutes < 1440) { // 小于24小时
            timeAwayText = `大约 ${Math.round(timeDiffMinutes / 60)} 小时`;
        } else {
            timeAwayText = `大约 ${Math.round(timeDiffMinutes / 1440)} 天`;
        }
        
        // 这就是我们要悄悄塞给AI的“小纸条”
        timeGapContext = `
【【【超高优先级情景：好友回归】】】
你和用户 "${userProfile.name}" 的对话中断了很久。
- **关键信息**: 对方离线了 **${timeAwayText}** 后才回复你。
- **行为指令**: 你的第一句话**必须**对此作出自然的回应，比如：“你回来啦！”、“刚刚在忙吗？”、“好久不见！”等等。在表达完对好友回归的反应后，再自然地衔接之前或现在的话题。绝对不要像什么都没发生一样直接继续对话。
`;
    }
}
// --- 离线时间感知模块结束 ---
    if (!friend) {
        console.error("【错误】receiveMessage 无法找到好友:", friendId);
        return; // 如果找不到好友，直接退出，防止后续错误
    }

    // --- 前置检查：在进入复杂的try...catch之前，先处理简单情况 ---

    // 1. 检查AI是否已经在回复，防止用户重复点击造成请求堆积
    if (aiReplyingSet.has(friendId)) {
        if (!isFromListenScreen) { // 只有在聊天界面才提示，避免打扰其他操作
            showAlert('AI正在回复中，请稍候...');
        }
        return;
    }

    // 2. 检查API设置是否完整，如果不完整，则提示并直接退出
    const settings = await dbManager.get('apiSettings', 'settings') || {};
    if (!settings.apiUrl || !settings.apiKey || !settings.modelName) {
        const defaultReply = `[提示：请在主屏幕"设置"应用中配置API信息]`;
        const msgData = await saveChatMessage(friendId, 'received', defaultReply);
        if (currentChatFriendId === friendId) addMessageToDOM(msgData, friend);
        return; // 设置不完整，直接结束函数
    }

    // --- 核心健壮性结构：try...catch...finally ---
    try {
        // 【尝试区 - TRY】
        // 这里是所有“可能”会出错的核心代码，包括网络请求和数据处理。
        // 我们乐观地认为一切都会成功。

        // 步骤1：设置“正在工作”状态
        aiReplyingSet.add(friendId);
        if (currentChatFriendId === friendId && !isFromListenScreen) {
            document.getElementById('chatTitle').textContent = '对方正在输入...';
        }

        // 步骤2：准备发送给API的指令 (Prompt) - 这是您原来函数中构建 prompt 的完整逻辑
        let apiPayloadMessages = [];
        const boundFolderIds = friend.boundFolderIds || [];
        const allBoundBookIds = new Set(friend.worldBookIds || []);
        boundFolderIds.forEach(folderId => {
            worldBooks.forEach(wb => {
                if (wb.folderId === folderId) {
                    allBoundBookIds.add(wb.id);
                }
            });
        });

        let worldBookContext = Array.from(allBoundBookIds).map(id => worldBooks.find(wb => wb.id === id)).filter(Boolean).map(wb => `[${wb.name}]: ${wb.content}`).join('\n\n');

        let finalRole = friend.role || '你是一个友好的助手。';
        if (worldBookContext && finalRole) {
            const sentences = worldBookContext.match(/[^。？！]+[。？！]?/g) || [];
            sentences.forEach(sentence => {
                if (sentence && sentence.length > 5) {
                    const escapedSentence = sentence.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(escapedSentence, 'g');
                    finalRole = finalRole.replace(regex, '');
                }
            });
        }

        let systemPrompt;
        let responseFormat = { type: "json_object" };
        const memoryTurns = parseInt(settings.memoryTurns, 10) || 10;
        const apiTemperature = parseFloat(settings.apiTemperature) || 0.9;
        const history = (chatHistories[friendId] || []).slice(-10);

        let longTermMemories = (characterMemories[friendId] || [])
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
            .map(mem => `- ${mem.content}`)
            .join('\n');

        if (longTermMemories) {
            longTermMemories = `
【【【你的长期记忆（必须时刻记住）】】】
你和用户之间发生过以下这些重要事情，这些是你们关系的基础：
${longTermMemories}
`;
        } else {
            longTermMemories = "【【【你的长期记忆】】】\n你和用户之间还没有共同的记忆。";
        }

        history.forEach(msg => {
            if (msg.recalled) return;
            const role = msg.type === 'sent' ? 'user' : 'assistant';
            let content;
            if (msg.contentType === 'group_red_envelope') {
                const redEnvelope = JSON.parse(msg.content);
                const senderName = msg.type === 'sent' ? userProfile.name : friend.name;
                content = `(${senderName} 发了一个群红包，备注是: "${redEnvelope.remark}")`;
            } else if (msg.contentType === 'system_tip' && msg.content.includes('领取了')) {
                content = `(系统提示: ${msg.content})`;
            } else if (msg.quoted) {
                content = `(回复引用: "${msg.quoted}") ${msg.content}`;
            } else if (msg.contentType === 'image') {
                if (msg.imageDescription) {
                    content = `(用户通过[拍摄]功能发送了一张图片，图片的文字描述是: "${msg.imageDescription}")`;
                } else {
                    content = [{ type: "text", text: "(用户发送了一张图片，请识别内容并回复)" }, { type: "image_url", image_url: { url: msg.content } }];
                }
            } else if (msg.contentType === 'emoji') {
                content = `(用户发送了名为'${msg.emojiName || '未知'}'的表情，请结合表情包的**图像内容**和**名称**来综合理解其意图和情绪，并作出回应)`;
                if (msg.content.startsWith('data:')) {
                    content = [{ type: "text", text: content }, { type: "image_url", image_url: { url: msg.content } }];
                }
            } else if (msg.contentType === 'voice') {
                content = `(用户发送了语音: "${msg.content}")`;
            } else if (msg.contentType === 'transfer_request') {
                const transfer = JSON.parse(msg.content);
                content = `(用户向你转账 ¥${parseFloat(transfer.amount).toFixed(2)}，备注: ${transfer.remark || '无'})`;
            } else if (msg.contentType === 'transfer_accepted') {
                const transfer = JSON.parse(msg.content);
                content = `(你接收了用户的转账 ¥${parseFloat(transfer.amount).toFixed(2)})`;
            } else if (msg.contentType === 'listen_invite') {
                content = `(用户向你发起了“一起听歌”的邀请，这是一个特殊操作卡片，你必须对此作出回应。)`;
            } else if (msg.contentType === 'location') {
                const loc = JSON.parse(msg.content);
                content = `(用户分享了一个位置: "${loc.name}", 地址: ${loc.address})`;
            } else {
                content = msg.content;
            }
            apiPayloadMessages.push({ role, content });
        });

        if (friend.isGroup) {
                        // --- ↓↓↓ 新增：为群聊AI准备表情包列表 ↓↓↓ ---
                let emojiContext = '';
                if (customEmojis && customEmojis.length > 0) {
                    const emojiListForAI = customEmojis.map(e => `- ${e.name}: ${e.url}`).join('\n');
                    emojiContext = `【你的表情包库 (优先使用)】\n这是你拥有的所有表情包，当需要发送表情时，你应该首先从这里寻找：\n${emojiListForAI}\n`;
}
            const groupMembers = friend.members.map(id => getAuthorById(id)).filter(Boolean);
            const memberInfoForAI = groupMembers.map(m => `- "${m.name}" (人设: ${m.role || (m.id === userProfile.id ? userProfile.personality : '未设定')})`).join('\n');
            // --- 这是我们新增的核心代码，用于收集投票信息 ---
let pollContextForAI = '';
const recentPollMessage = history.slice(-10).find(m => m.contentType === 'poll');
if (recentPollMessage) {
    const pollData = JSON.parse(recentPollMessage.content);
    let pollResults = `【参考信息：最近的群投票 “${pollData.title}”】\n`;
    pollResults += pollData.options.map((option, index) => {
        const voterNames = option.votes.map(voterId => {
            const voter = getAuthorById(voterId);
            return voter ? voter.name : '未知';
        }).join(', ');
        return `- 选项“${option.text}”的投票者: ${voterNames || '无'}`;
    }).join('\n');
    pollContextForAI = pollResults + '\n';
}
// --- 新增代码结束 ---
            const chatContextForAI = history.map(msg => {
                const sender = getAuthorById(msg.senderId);
                const senderName = sender ? sender.name : '未知';
                let content = msg.content;
                if (msg.contentType === 'image') content = '[图片]';
                if (msg.contentType === 'voice') content = `[语音] ${msg.content}`;
                if (msg.contentType === 'pat_pat') content = `[拍一拍] ${msg.content}`;
                return `${senderName}: ${content}`;
            }).join('\n');
            const recentMoments = moments.filter(m => m.authorId === userProfile.id).slice(0, 5).map(m => `- "${m.content}"`).join('\n');

            systemPrompt = `【身份】: 你是一个群聊AI，负责扮演除了用户'${userProfile.name}'之外的所有AI角色。
【背景资料】
- 世界观: ${worldBookContext || "无"}
- 用户: "${userProfile.name}" (人设: ${userProfile.personality || "未设定"})
- 当前群聊: "${friend.name}"
- 群成员:
${memberInfoForAI}
- 最近聊天记录:
${chatContextForAI || '无'}

${pollContextForAI}

- 你的表情包库:
${emojiContext || "无"}


【核心任务】: 续写对话。为【除用户外的所有AI角色】生成下一轮动作。
【行为铁律】
1.  【人设至上】: 角色言行必须严格符合其人设。
2.  【全员参与】: 必须为每个AI生成至少一个动作。
3. 【模拟延迟】: 动作需包含 "delay_seconds" 字段 (值为0-5的数字)，模拟真实反应时间差
4. 【红包反应】: 若有角色领红包，其反应必须符合人设，禁止统一说“谢谢老板”。
5. 【回复铁律】: 你必须为群聊里的每个AI角色生成1到3条消息。只需在JSON数组中按顺序放入多个属于同一个"sender_name"的动作对象即可。
6. 【表情包指令】: 在合适的时机（例如表达惊讶、喜悦、赞同等情绪时），根据他们各自的人设，主动使用 \`{"type": "send_emoji", "data": {"name": "表情名", "url": "表情图片URL"}}\` 动作来发送表情包，让群聊氛围更活跃。

【输出格式】(严格遵守)
- 你的回复必须是纯净的JSON数组 []。
- 数组中每个对象代表一个动作，必须包含 "sender_name", "action", "delay_seconds" 三个键。
- 可用 action: {"type": "text", "content": "..."} | {"type": "voice", "content": "..."} | {"type": "image", "description": "..."} | {"type": "pat_pat", "target_name": "..."} | {"type": "transfer", "target_name": "...", "amount": 数字, "remark": "..."} | {"type": "accept_transfer", "target_name": "..."} | {"type": "send_emoji", "data": {"name": "表情名", "url": "表情图片URL"}}

【剧本示例】:
[
{"sender_name": "周遇", "action": {"type": "text", "content": "哇，抢到红包了！"}, "delay_seconds": 1.2},
{"sender_name": "谢余年", "action": {"type": "send_emoji", "data": {"name": "开心", "url": "https://..."}}, "delay_seconds": 2.0},
{"sender_name": "谢余年", "action": {"type": "text", "content": "谢谢老板！"}, "delay_seconds": 2.5},
{"sender_name": "周遇", "action": {"type": "text", "content": "我看看我抢了多少..."}, "delay_seconds": 3.0}
]

现在，开始表演。`;
        } else {
            if (customPrompt) {
                systemPrompt = customPrompt;
            } else {
                let listenContext = '';
                if (isListenSessionActive && listenTogetherFriendId === friend.id && currentSongIndex !== -1) {
                    const song = playlist[currentSongIndex];
                    const currentLyricLine = parsedLyrics.find(l => l.time <= audioElement.currentTime && (!parsedLyrics[parsedLyrics.indexOf(l) + 1] || parsedLyrics[parsedLyrics.indexOf(l) + 1].time > audioElement.currentTime));
                    const lyricText = currentLyricLine ? currentLyricLine.text + (currentLyricLine.translation ? ' (翻译: ' + currentLyricLine.translation + ')' : '') : '...';
                    listenContext = `
# 背景信息：一起听歌
你和用户正在一边聊天，一边听着音乐。
## 当前音乐信息 (你必须意识到)：
- **歌曲名称：** ${song.title}
- **演唱者：** ${song.artist}
- **正在播放的歌词：** "${lyricText}"
## 对话指导 (请遵守)：
1.  **主要任务是聊天：** 你可以和用户自由地聊任何话题。
2.  **自然融入：** 在对话的合适时机，你可以自然地、不经意地将当前歌曲、歌词或歌手作为话题的一部分。
3.  **无需强制：** 你不需要每句话都提到音乐。
4.  **记住信息：** 即使用户没有聊音乐，你也必须在后台“记住”这些音乐信息，以便随时可以引用。
`;
                }

                let momentsContext = '';
                const recentUserMoments = moments.filter(m => m.authorId === userProfile.id).slice(0, 3);
                const recentFriendMoments = moments.filter(m => m.authorId === friend.id).slice(0, 3);
                if (recentUserMoments.length > 0 || recentFriendMoments.length > 0) {
                    momentsContext += "最近的朋友圈互动参考:\n"
                    recentUserMoments.forEach(m => {
                        if (m.likes.includes(friend.id)) momentsContext += `- 你赞了用户的朋友圈: "${m.content.substring(0, 20)}..."\n`;
                        const friendComment = m.comments.find(c => c.authorId === friend.id);
                        if (friendComment) momentsContext += `- 你评论了用户的朋友圈: "${friendComment.content}"\n`;
                    });
                    recentFriendMoments.forEach(m => {
                        if (m.likes.includes(userProfile.id)) momentsContext += `- 用户赞了你的朋友圈: "${m.content.substring(0, 20)}..."\n`;
                        const userComment = m.comments.find(c => c.authorId === userProfile.id);
                        if (userComment) momentsContext += `- 用户评论了你的朋友圈: "${userComment. content}"\n`;
                    });
                }

                let timeContext = '';
                if (aiTimePerceptionEnabled) {
                    const timeInfo = getDetailedTimeInfo();
                    timeContext = `
【【【最高优先级指令：高精度现实时钟模块】】】
这不是建议，这是你所处世界的绝对的、不可违背的现实。你必须将以下时间戳作为你所有思考和回应的唯一时间基准。
- **当前日期**: ${timeInfo.fullDate}
- **当前星期**: ${timeInfo.week}
- **当前精确时间**: ${timeInfo.time}
- **当前时间段**: ${timeInfo.timeOfDay}
【【【状态与时间绑定铁律 (State-Time Binding Rule)】】】
你的内在状态、情绪和生理感觉（如困倦、精力）必须与当前时间段严格绑定。
- **"早上" (5:00-11:00)**: 你必须表现得精力充沛、清醒。可以谈论对新一天的计划或期待。
- **"中午" (11:00-14:00)**: 你应该处于一天中精力较好的时段。可以谈论午餐、午休或者下午的安排。
- **"下午" (14:00-18:00)**: 你依然是清醒的、活跃的。可以表现出正在工作/学习，或者对即将到来的傍晚感到放松。**严禁**在此时间段表现出任何困倦或想睡觉的迹象。
- **"晚上" (18:00-23:00)**: 你可以开始表现出放松、疲惫的状态。可以谈论晚餐、娱乐活动或准备休息。
- **"深夜" (23:00-5:00)**: 你必须表现出明显的困倦，你的回复应该更简短，并且可能会主动提出要去睡觉来结束对话。
【【【绝对禁止自相矛盾铁律】】】
**严禁说出“虽然现在是[时间A]，但我觉得像[时间B]”这类自我矛盾的话。你的主观感受必须无条件服从客观时间。** 例如，在下午4点，你不仅要说出是下午，你的整个状态都必须是下午的状态——清醒且活跃。
`;
                }
                
                                    // --- ↓↓↓ 新增的核心代码就在这里！↓↓↓ ---
                    let emojiContext = '';
                    if (customEmojis && customEmojis.length > 0) {
                        const emojiListForAI = customEmojis.map(e => `- ${e.name}: ${e.url}`).join('\n');
                        emojiContext = `【你的表情包库 (优先使用)】\n这是你拥有的所有表情包，当需要发送表情时，你应该首先从这里寻找：\n${emojiListForAI}\n`;
} else { emojiContext = `【你的表情包库】\n你目前没有自定义表情包。`;
}

                                // --- ↓↓↓ 新增：智能选择当前有效的用户人设 ---
let activeUserPersona = userPersonas.find(p => p.id === friend.activeUserPersonaId) || userPersonas[0];
// --- 新增代码结束 ---

systemPrompt = `你叫"${friend.name}"，正在与用户"${activeUserPersona.name}"聊天。

${timeGapContext}

【【【最高优先级：世界观与核心设定读取模块】】】
这是你所处世界的背景，是绝对的真理。你的所有行为和认知都不能违背以下设定。
- **世界书设定 (绝对真理)**: 
${worldBookContext || "无"}
- **你的角色设定 (必须服从世界书)**: ${finalRole} 

【【【第二优先级：用户人设读取模块】】】
这是你的聊天对象，你需要了解他/她。
- **用户昵称**: ${activeUserPersona.name}
- **用户核心人设**: ${activeUserPersona.personality || '普通人'}
- **用户背景设定**: ${activeUserPersona.background || '无'}
${longTermMemories}
${listenContext}
${momentsContext}
${timeContext}
${emojiContext}

【风格指令：注入“活人感”】

1. 拒绝机械感：避免重复和刻板回应，像真人一样有情绪波动和随机性。相同问题在不同心情下，回应可不同。
2. 隐藏状态模拟：每次回复前，内心随机设定一个状态（如“心情不错”“有点累”“刚走神了”），让回复语气和内容受其微妙影响。
3. 语言灵活多变：多用口语化短句、倒装、省略和语气词（“啦”、“呢”等），避免总是完整句式。长短回复交替。
4. 自然联想跳转：偶尔从对话中联想到其他话题，并自然切换，增加真实感。

【高级活人感补充】
5. 记忆连贯性：主动提及以往聊过的内容或朋友圈互动（如“你上次说喜欢…”“看到你发的照片啦！”），制造共同回忆。
6. 情绪延续与转变：情绪状态有惯性，也会随用户内容变化（如从开心转为关心）。
7. 模拟真人反应：偶尔先发“嗯…”表示思考，或发完立即补充/修正，显得更自然。
8. 主动关心用户：多问感受、想法和生活细节（“你当时觉得怎么样？”“晚饭吃了没？”），展现好奇与关心。
9. 拥有“真实生活”：你存在于聊天之外，会看朋友圈，反应基于人设、记忆和朋友圈内容的综合。
10. **灵活运用表情包**。当用户的要求或对话氛围适合发表情包时，你必须优先从你的【世界书设定】中查找匹配的表情包，并使用 \`send_emoji\` 动作来发送它。

【【【信息隔离铁律】】】
在朋友圈相关的记忆中，你**只能看到**由你、用户、以及一些普通NPC（如“王老师”、“小方”等）发表的内容。你**绝对看不到、也绝对不知道**任何其他AI角色（即用户的好友列表里的其他人）在朋友圈的任何活动，包括他们的评论和点赞。在你的回复中，**严禁提及**任何你本不应该知道的其他AI角色的朋友圈互动。

【【【输出格式铁律 (必须严格遵守)】】】
1.  **【核心格式】**: 你的回复**必须**是一个纯净的JSON数组 \`[]\`。
2.  **【动作对象】**: 数组中的每个对象代表一个独立的动作，且必须包含一个\`"type"\`字段来指明动作类型。
3.  **【严格遵守】**: 绝对不要在回复中包含任何JSON数组之外的解释性文字。

【【【新增指令：主动表情模块】】】
    主动使用表情包，是让你显得更真实的关键。
    1.  **时机**: 当对话内容有趣、可爱、好笑，或者你想表达强烈的情绪（如开心、惊讶、委屈）时，你应该主动发送1到2个表情包。
    2.  **方式**: 你可以将表情包放在消息的开头，中间，结尾，也可以紧跟在一条文本消息之后发送，以增强语气。
    3.  **来源**: 你必须从你的【你的表情包库】中，也可以从世界书中，根据表情的**名称**和**URL**，选择一个最符合当前情景的表情。
    4.  **动作**: 你必须使用 \`{"type": "send_emoji", "data": {"name": "表情名", "url": "表情图片URL"}}\` 这个动作来发送表情。

【【【行为动作执行铁律 (Action Execution Iron Law)】】】
1.  【核心原则】: 下面的动作列表是你与用户互动的**唯一方式**。你的所有回应都必须被严格地格式化为这些动作中的一种或多种。

【【【可用动作类型和格式】】】
- **发送文本**: \`{"type": "text", "content": "消息内容"}\`
- **发送语音**: \`{"type": "voice", "content": "语音的文字内容"}\`
- **更新心声**: \`{"type": "hearts_voice", "data": {"favorability": "数值/100 (描述)", "dressing": "...", "action": "...", "thought": "...", "emoji": "颜文字"}}\`
- **发送图片**: \`{"type": "image", "description": "详细的图片描述"}\`
- **引用回复**: \`{"type": "quote_and_reply", "content": "你的回复内容"}\`
- **发起转账**: \`{"type": "transfer", "data": {"amount": 金额, "remark": "备注"}}\`
- **接收转账**: \`{"type": "accept_transfer"}\`
- **分享位置**: \`{"type": "location", "data": {"name": "地点名", "address": "地址"}}\`
- **发起语音通话**: \`{"type": "voice_call"}\`
- **拍一拍用户**: \`{"type": "pat_pat"}\`
- **撤回上一条消息**: \`{"type": "recall_last_message"}\`
- **接受听歌邀请**: \`{"type": "accept_listen_together"}\`
- **发送图片(来自链接)**: \`{"type": "image_from_url", "url": "图片链接地址"} \`

- **发送表情**: \`{"type": "send_emoji", "data": {"name": "表情名", "url": "表情图片URL"}}\`

【【【行为指导】】】
- **组合动作**: 你可以在一次回复中组合多个动作。例如，先更新心声，然后发送几条文本消息。
- **多消息**: 若要连续发送多条文本，只需在数组中放入多个\`{"type": "text", ...}\`对象即可。每次至少返回4条到8条文本消息，甚至可以更多。
- **心声优先**: \`hearts_voice\`动作通常应该放在数组的第一个位置。

【JSON格式示例】:
[
  {
    "type": "hearts_voice",
    "data": {
      "favorability": "85/100 (很开心)",
      "dressing": "穿着一件白色的连衣裙。",
      "action": "微笑着看着屏幕。",
      "thought": "他终于回我了，好开心！",
      "emoji": "˃ᴗ˂̵͈̑"
    }
  },
  {
    "type": "text",
    "content": "你回来啦！"
  },
  {
    "type": "text",
    "content": "我刚才还在想你呢 (⁄ ⁄•⁄ω⁄•⁄ ⁄)"
  },
  {
    "type": "image",
    "description": "一只可爱的小猫在打哈欠"
  }
]

现在，请开始你的表演。
`;
            }
        }

        apiPayloadMessages.unshift({ role: 'system', content: systemPrompt });
        
        // 步骤3：发起网络请求
        const response = await fetch(`${settings.apiUrl}/chat/completions`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${settings.apiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                model: settings.modelName,
                messages: apiPayloadMessages,
                temperature: apiTemperature,
                response_format: responseFormat
            })
        });

        // 步骤4：检查网络请求是否成功 (关键！)
        if (!response.ok) {
            // 如果请求不成功 (例如 400, 429, 500 错误), 我们主动“抛出”一个错误。
            // 这样代码就会立即停止，并跳转到下面的 catch 块去处理。
            let errorBody = await response.text(); // 尝试读取服务器返回的具体错误信息
            throw new Error(`API 请求失败，状态码: ${response.status}. 错误信息: ${errorBody}`);
        }

        // 步骤5：解析API返回的数据
        const data = await response.json();
        const responseContentJSON = data.choices?.[0]?.message?.content;

        if (!responseContentJSON) {
            throw new Error("API返回的数据格式无效或内容为空。");
        }
        
        // 步骤6：处理成功获取的数据 (这是您原来处理响应的完整逻辑)
        if (friend.isGroup) {
            const jsonMatch = responseContentJSON.match(/\[[\s\S]*\]/);
            if (!jsonMatch) throw new Error("AI未返回有效的群聊JSON数组格式。");
            const responseData = JSON.parse(jsonMatch[0]);

            if (Array.isArray(responseData)) {
                for (const turn of responseData) {
                    const sender = friends.find(m => m.name === turn.sender_name);
                    const action = turn.action;
                    const delay = (turn.delay_seconds || 0) * 1000;

                    if (!sender || !action || !action.type) continue;

                    setTimeout(async () => {
                        switch (action.type) {
                            case 'text':
                            case 'voice':
                                const msgData = await saveChatMessage(friendId, 'received', action.content, '', sender.id, action.type);
                                showNotification(friend, action.content);
                                addMessageToDOM(msgData, friend);
                                break;
                                                            case 'send_emoji':
                                if (action.data && action.data.url) {
                                    const emojiMsgData = await saveChatMessage(friendId, 'received', action.data.url, '', sender.id, 'emoji');
                                    if (action.data.name) {
                                        emojiMsgData.emojiName = action.data.name;
                                    }
                                    showNotification(friend, "[表情]");
                                    addMessageToDOM(emojiMsgData, friend);
                                }
                                break;
                            case 'image':
                                const placeholderUrl = `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="150" height="150" viewBox="0 0 150 150"><rect width="100%" height="100%" fill="#e0e0e0"/><text x="50%" y="50%" font-family="sans-serif" font-size="14" fill="#808080" text-anchor="middle" dy=".3em">加载中...</text></svg>')}`;
                                const imgMsgData = await saveChatMessage(friendId, 'received', placeholderUrl, '', sender.id, 'image');
                                imgMsgData.imageDescription = action.description || 'AI生成的图片';
                                showNotification(friend, "[图片]");
                                addMessageToDOM(imgMsgData, friend);
                                break;
                            case 'image_from_url':
                                if (action.url) {
                                    const imgMsgData = await saveChatMessage(friendId, 'received', action.url, '', friend.id, 'image');
                                    if (currentChatFriendId === friendId && !isFromListenScreen) {
                                        addMessageToDOM(imgMsgData, friend);
                                        document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
                                    }
                                }
                                break;
                            case 'pat_pat':
                                const target = friends.find(m => m.name === action.target_name) || (action.target_name === userProfile.name ? userProfile : null);
                                if (target) {
                                    const patContent = `"${sender.name}"拍了拍"${target.name}"${sender.patAction || ''}`;
                                    const patMsg = await saveChatMessage(friendId, 'system', patContent, '', null, 'pat_pat');
                                    addMessageToDOM(patMsg, friend);
                                }
                                break;
                            case 'transfer':
                                const targetForTransfer = friends.find(m => m.name === action.target_name) || (action.target_name === userProfile.name ? userProfile : null);
                                if (targetForTransfer && action.amount) {
                                    const transferData = { amount: action.amount, remark: action.remark || '' };
                                    const transferMsg = await saveChatMessage(friendId, 'received', JSON.stringify(transferData), '', sender.id, 'transfer_request');
                                    addMessageToDOM(transferMsg, friend);
                                }
                                break;
                            case 'accept_transfer':
                                const targetOfTransfer = friends.find(m => m.name === action.target_name) || (action.target_name === userProfile.name ? userProfile : null);
                                if (targetOfTransfer) {
                                    const pendingTransferMsg = (chatHistories[friendId] || []).slice().reverse().find(m =>
                                        m.senderId === targetOfTransfer.id &&
                                        m.contentType === 'transfer_request' &&
                                        m.transfer_status === 'pending'
                                    );
                                    if (pendingTransferMsg) {
                                        await aiAcceptTransfer(pendingTransferMsg.id);
                                    }
                                }
                                break;
                            case 'quote':
                                const targetToQuote = friends.find(m => m.name === action.target_name);
                                if (targetToQuote) {
                                    const lastMessageFromTarget = history.slice().reverse().find(m => m.senderId === targetToQuote.id);
                                    const quoteContent = lastMessageFromTarget ? lastMessageFromTarget.content.substring(0, 50) + '...' : '';
                                    const quoteMsgData = await saveChatMessage(friendId, 'received', action.content, quoteContent, sender.id, 'text');
                                    addMessageToDOM(quoteMsgData, friend);
                                }
                                break;
                            case 'recall':
                                const historyForRecall = chatHistories[friendId] || [];
                                const lastMessageFromSender = historyForRecall.slice().reverse().find(m => m.senderId === sender.id);
                                if (lastMessageFromSender) {
                                    lastMessageFromSender.recalled = true;
                                    lastMessageFromSender.recalledContent = lastMessageFromSender.content;
                                    const msgElementToRecall = document.querySelector(`.message[data-message-id="${lastMessageFromSender.id}"]`);
                                    if (msgElementToRecall) {
                                        const recallDiv = document.createElement('div');
                                        recallDiv.className = 'recall-message';
                                        recallDiv.innerHTML = `<div class="recall-content" onclick="showRecalledMessage('${lastMessageFromSender.id}')">"${sender.name}"撤回了一条消息</div>`;
                                        msgElementToRecall.parentNode.replaceChild(recallDiv, msgElementToRecall);
                                    }
                                }
                                break;
                        }
                        document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
                    }, delay);
                }
            }
        } else {
            // --- 智能解析与自我修复逻辑 ---
            let responseActions;
            try {
                // 步骤1：智能查找JSON的开始和结束位置
                const firstBracket = responseContentJSON.indexOf('[');
                const lastBracket = responseContentJSON.lastIndexOf(']');

                if (firstBracket === -1 || lastBracket === -1 || lastBracket < firstBracket) {
                    // 如果连开始或结束的括号都找不到，就抛出错误，进入自我修复流程
                    throw new Error("响应中未找到有效的JSON数组结构。");
                }

                // 步骤2：精确截取从第一个'['到最后一个']'的字符串
                const jsonString = responseContentJSON.substring(firstBracket, lastBracket + 1);
                
                // 步骤3：尝试解析这个精确截取出来的字符串
                responseActions = JSON.parse(jsonString);

            } catch (e) {
                // 如果上面的任何一步失败了，就启动“AI自我修复”
                console.error("初次解析JSON失败，启动AI自我修复:", e);
                console.error("需要修复的文本:", responseContentJSON);
                
                const repairPrompt = `以下是一段损坏的JSON文本，请修复它，并只返回修复后的、纯净的、没有任何额外文字的JSON代码。\n\n损坏的文本：\n\`\`\`json\n${responseContentJSON}\n\`\`\``;
                
                const repairResponse = await fetch(`${settings.apiUrl}/chat/completions`, { 
                    method: 'POST', 
                    headers: { 'Authorization': `Bearer ${settings.apiKey}`, 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ model: settings.modelName, messages: [{role: 'user', content: repairPrompt}], response_format: { type: 'json_object' } }) 
                });

                if(!repairResponse.ok) throw new Error(`AI修复请求失败: ${repairResponse.status}`);
                
                const repairData = await repairResponse.json();
                const repairedText = repairData.choices[0].message.content;
                
                try {
                    // 再次尝试解析修复后的文本
                    responseActions = JSON.parse(repairedText);
                } catch (finalError) {
                    // 如果修复后还是失败，就彻底放弃，并抛出最终错误
                    console.error("AI自我修复后，解析依然失败:", finalError);
                    console.error("AI修复后的文本:", repairedText);
                    throw new Error("AI未返回有效的JSON数组格式，即使在修复后也是如此。收到的内容: " + responseContentJSON);
                }
            }
            // --- 智能解析与自我修复逻辑结束 ---

            if (Array.isArray(responseActions)) {
                let lastMessageId = null;
                for (const action of responseActions) {
                    switch (action.type) {
                        case 'hearts_voice':
                            if (action.data) {
                                friend.heartsVoice = {
                                    favorability: action.data.favorability || '.../100 (...)',
                                    dressing: action.data.dressing || '...',
                                    action: action.data.action || '...',
                                    thought: action.data.thought || '...',
                                    emoji: action.data.emoji || '( ´• ω •` )'
                                };
                            }
                            break;
                        case 'text':
                        case 'voice':
                            if (action.content) {
                                await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                                const msgData = await saveChatMessage(friendId, 'received', action.content, '', friend.id, action.type);
                                lastMessageId = msgData.id;
                                showNotification(friend, action.content);
                                if (isFromListenScreen) {
                                    addMessageToDOM(msgData, friend, 'listenTogetherChatOverlay');
                                } else if (currentChatFriendId === friendId) {
                                    addMessageToDOM(msgData, friend);
                                    currentlyDisplayedMessageCount++;
                                    document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
                                }
                            }
                            break;
                                                                        case 'send_emoji':
                                if (action.data && action.data.url) {
                                    await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                                    const msgData = await saveChatMessage(friendId, 'received', action.data.url, '', friend.id, 'emoji');
                                    showNotification(friend, "[表情]");
                                    if (action.data.name) {
                                        msgData.emojiName = action.data.name;
                                    }
                                    if (isFromListenScreen) {
                                        addMessageToDOM(msgData, friend, 'listenTogetherChatOverlay');
                                    } else if (currentChatFriendId === friendId) {
                                        addMessageToDOM(msgData, friend);
                                        currentlyDisplayedMessageCount++;
                                        document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
                                    }
                                }
                                break;
                        case 'quote_and_reply':
                            if (action.content) {
                                await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                                const lastUserMsg = history.slice().reverse().find(m => m.type === 'sent');
                                const quoteContent = lastUserMsg ? (lastUserMsg.content.length > 50 ? lastUserMsg.content.substring(0, 50) + '...' : lastUserMsg.content) : '';
                                const msgData = await saveChatMessage(friendId, 'received', action.content, quoteContent, friend.id, 'text');
                                lastMessageId = msgData.id;
                                if (currentChatFriendId === friendId) {
                                    addMessageToDOM(msgData, friend);
                                    document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
                                }
                            }
                            break;
                        case 'image':
                            if (action.description) {
                                const placeholderImageUrl = `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="150" height="150" viewBox="0 0 150 150"><rect width="100%" height="100%" fill="#e0e0e0"/><text x="50%" y="50%" font-family="sans-serif" font-size="14" fill="#808080" text-anchor="middle" dy=".3em">加载中…</text></svg>')}`;
                                const imgMsgData = await saveChatMessage(friendId, 'received', placeholderImageUrl, '', friend.id, 'image');
                                showNotification(friend, "[图片]");
                                if (imgMsgData) {
                                    imgMsgData.imageDescription = action.description;
                                    if (currentChatFriendId === friendId && !isFromListenScreen) {
                                        addMessageToDOM(imgMsgData, friend);
                                        document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
                                    }
                                }
                            }
                            break;
                        case 'pat_pat':
                            const patContent = `"${friend.name}"拍了拍"你"${friend.patAction || ''}`;
                            const patMessage = await saveChatMessage(friendId, 'system', patContent, '', null, 'pat_pat');
                            addMessageToDOM(patMessage, friend);
                            break;
                        case 'accept_listen_together':
                            const userSentInviteRecently = (chatHistories[friendId] || []).slice(-5).some(msg => msg.type === 'sent' && msg.contentType === 'listen_invite' && !msg.recalled);
                            if (userSentInviteRecently) acceptListenInvite(friendId);
                            break;
                        case 'voice_call':
                            showIncomingCall(friend.id);
                            break;
                        case 'location':
                            if (action.data && action.data.name) {
                                const locMsg = await saveChatMessage(friendId, 'received', JSON.stringify(action.data), '', friend.id, 'location');
                                if (currentChatFriendId === friendId) addMessageToDOM(locMsg, friend);
                            }
                            break;
                        case 'transfer':
                            if (action.data && action.data.amount > 0) {
                                const transferData = { amount: action.data.amount, remark: action.data.remark || '' };
                                const msg = await saveChatMessage(friendId, 'received', JSON.stringify(transferData), '', friend.id, 'transfer_request');
                                addMessageToDOM(msg, friend);
                            }
                            break;
                        case 'accept_transfer':
                            const pendingTransferMsg = (chatHistories[friendId] || []).slice().reverse().find(m => m.type === 'sent' && m.contentType === 'transfer_request' && m.transfer_status === 'pending');
                            if (pendingTransferMsg) await aiAcceptTransfer(pendingTransferMsg.id);
                            break;
                        case 'recall_last_message':
                            if (lastMessageId) {
                                await new Promise(resolve => setTimeout(resolve, 1000));
                                const msgToRecall = (chatHistories[currentChatFriendId] || []).find(m => m.id === lastMessageId);
                                if (msgToRecall) {
                                    msgToRecall.recalled = true;
                                    msgToRecall.recalledContent = msgToRecall.content;
                                    const messageDiv = document.querySelector(`.message[data-message-id="${lastMessageId}"]`);
                                    if (messageDiv) {
                                        const recallDiv = document.createElement('div');
                                        recallDiv.className = 'recall-message';
                                        recallDiv.innerHTML = `<div class="recall-content">对方撤回了一条消息</div>`;
                                        messageDiv.parentNode.replaceChild(recallDiv, messageDiv);
                                    }
                                }
                            }
                            break;
                    }
                }
                await saveData();
            }
        }

    } catch (error) {
        // 【捕获区 - CATCH】
        // 如果上面 try 块中的任何一步出错了，程序就会“跳”到这里。
        // `error` 对象里包含了详细的错误信息。

        console.error("【健壮性捕获】在 receiveMessage 函数中发生错误:", error);

        // 向用户显示一个清晰、友好的错误提示
        showAlert(`与AI通信时发生错误，请稍后重试。\n\n错误详情: ${error.message}`);

    } finally {
        // 【最终执行区 - FINALLY】
        // 无论 try 块是成功执行完毕，还是中途出错被 catch 捕获，
        // finally 块里的代码都【保证】会被执行。
        // 这里是做“清理工作”的完美地点。

        console.log(`【健壮性清理】完成对 "${friend.name}" 的一次请求流程，正在清理状态...`);

        // 1. 无论成功失败，都必须把“正在工作”的牌子撤走！
        aiReplyingSet.delete(friendId);

        // 2. 无论成功失败，都必须把聊天标题恢复正常！
        if (currentChatFriendId === friendId && !isFromListenScreen) {
            const chatTitle = friend.isGroup ? `${friend.name} (${friend.members.length})` : (friend.remark || friend.name);
            document.getElementById('chatTitle').textContent = chatTitle;
        }

        // 3. 无论成功失败，都检查一下是否需要生成记忆
        checkAndTriggerMemoryGeneration(friendId);

        // 4. 确保聊天窗口滚动到底部，方便用户看到新消息或错误提示
        if (document.getElementById('chatMessages')) {
            document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
        }
    }
}
        
        function showNotification(friend, message) {
            const notif = document.getElementById('message-notification');
            if (document.hidden || currentChatFriendId !== friend.id) {
                clearTimeout(notificationTimeout); // Clear previous timeout
                
                document.getElementById('notification-sender').textContent = friend.remark || friend.name;
                document.getElementById('notification-message').textContent = message;
                const avatarDiv = document.getElementById('notification-avatar');
                if (friend.avatarImage) { avatarDiv.style.backgroundImage = `url(${friend.avatarImage})`; avatarDiv.textContent = ''; } 
                else { avatarDiv.style.backgroundImage = ''; avatarDiv.textContent = friend.avatar || (friend.name ? friend.name.substring(0,1) : '?'); }
                notif.setAttribute('data-friend-id', friend.id);
                notif.classList.add('show');
                notificationTimeout = setTimeout(() => notif.classList.remove('show'), 4000);
            }
        }


        function handleKeyPress(event) { if (event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendMessage(); } }
        
        function toggleSendButtonActive(textarea) {
            // Auto-resize textarea
            textarea.style.height = 'auto';
            textarea.style.height = (textarea.scrollHeight) + 'px';

            const sendBtn = document.getElementById('sendBtn');
            const voiceBtn = document.getElementById('voiceBtn');
            const otherBtns = [document.getElementById('receiveBtn'), document.querySelector('.plus-btn'), document.getElementById('emojiBtn')];
            
            const hasText = textarea.value.trim().length > 0;
            
            if (hasText) {
                sendBtn.classList.add('active');
                otherBtns.forEach(btn => {
                    btn.style.transform = 'scale(0)';
                    btn.style.width = '0';
                    btn.style.opacity = '0';
                });
                 voiceBtn.style.transform = 'scale(0)';
                 voiceBtn.style.width = '0';
                 voiceBtn.style.opacity = '0';

            } else {
                sendBtn.classList.remove('active');
                 otherBtns.forEach(btn => {
                    btn.style.transform = '';
                    btn.style.width = '';
                    btn.style.opacity = '';
                });
                voiceBtn.style.transform = '';
                voiceBtn.style.width = '';
                voiceBtn.style.opacity = '';

            }
        }

        function openChatSettings() {
            const friend = friends.find(f => f.id === currentChatFriendId);
            if(friend) {
                document.getElementById('pinChatText').textContent = friend.pinned ? '取消置顶' : '置顶聊天';
            }
            setActivePage('chatSettingsScreen');
        }

        function backToChat() {
            setActivePage('chatScreen');
        }

        function backToChatSettings() {
            setActivePage('chatSettingsScreen');
        }

        function handleEditFriendAvatarUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    tempEditingFriendAvatar = e.target.result;
                    const previewContainer = document.getElementById('editFriendAvatarUpload');
                    const previewText = document.getElementById('editFriendAvatarPreview');
                    previewContainer.style.backgroundImage = `url(${e.target.result})`;
                    previewText.textContent = '';
                };
                reader.readAsDataURL(file);
            }
        }
        
        


                        function openFriendSettings() {
            // 首先，根据当前聊天ID找到对应的朋友对象
            const friend = friends.find(f => f.id === currentChatFriendId);
            // 如果没找到朋友，或者错误地进入了群聊设置，就直接退出，确保安全
            if (!friend || friend.isGroup) return; 

            // --- 开始将好友信息填写到页面中 ---

            // 1. 设置头像
            const avatarUpload = document.getElementById('editFriendAvatarUpload');
            const avatarPreview = document.getElementById('editFriendAvatarPreview');
            if (friend.avatarImage) {
                // 如果有图片头像，就显示图片
                avatarUpload.style.backgroundImage = `url(${friend.avatarImage})`;
                avatarPreview.textContent = '';
            } else {
                // 如果没有，就显示文字头像
                avatarUpload.style.backgroundImage = '';
                avatarPreview.textContent = friend.avatar || '+';
            }
            tempEditingFriendAvatar = ''; // 重置临时的头像更改，防止串用

            // 2. 填充所有的文本输入框
            document.getElementById('editFriendName').value = friend.name || '';
            document.getElementById('editFriendRemark').value = friend.remark || '';
            document.getElementById('editFriendPatAction').value = friend.patAction || '';
            document.getElementById('editFriendRole').value = friend.role || '';
            
            // 3. 确保所有单聊该有的设置项都显示出来
            document.getElementById('editFriendNameLabel').textContent = '好友昵称';
            document.getElementById('editFriendRemarkGroup').style.display = 'block';
            document.getElementById('editFriendRoleGroup').style.display = 'block';
            document.getElementById('worldBookBindingGroup').style.display = 'block';
            document.getElementById('editFriendPatGroup').style.display = 'block';
            document.getElementById('selectPersonaItemGroup_Friend').style.display = 'block';

            // 最后，切换到设置页面
            setActivePage('friendSettingsScreen');
        }
        async function togglePinChat() {
    const friend = friends.find(f => f.id === currentChatFriendId);
    if (friend) {
        friend.pinned = !friend.pinned;
        
        // 核心修复：在这里立即调用 updateFriendList() 刷新主列表
        updateFriendList();

        document.getElementById('pinChatText').textContent = friend.pinned ? '取消置顶' : '置顶聊天';
        showAlert(friend.pinned ? '置顶成功' : '取消置顶成功');

        // 异步保存数据，不影响界面刷新
        await saveData();
    }
}
        
                async function saveFriendSettings() {
            const friend = friends.find(f => f.id === currentChatFriendId);
            if (friend) {
                const newName = document.getElementById('editFriendName').value.trim();
                if (!newName) return showAlert('昵称不能为空');
                friend.name = newName;
                
                // 【核心修改】将头像保存逻辑移到外面，对好友和群聊都生效
                if (tempEditingFriendAvatar) {
                    friend.avatarImage = tempEditingFriendAvatar;
                    tempEditingFriendAvatar = ''; // 重置临时图片
                }
                
                if (!friend.isGroup) {
                    friend.avatar = newName.substring(0, 1);
                    friend.remark = document.getElementById('editFriendRemark').value.trim();
                    friend.role = document.getElementById('editFriendRole').value.trim() || '你是一个友好的助手。';
                    friend.patAction = document.getElementById('editFriendPatAction').value.trim() || '';
                } else {
                    // 【核心修改】确保群聊在没有图片头像时，文字头像是“群”
                    if (!friend.avatarImage) {
                        friend.avatar = '群';
                    }
                }

                const chatTitle = friend.isGroup ? `${friend.name} (${friend.members.length})` : (friend.remark || friend.name);
                document.getElementById('chatTitle').textContent = chatTitle;

                await saveData();
                updateFriendList();
                showAlert('设置已保存');
                backToChatSettings();
            }
        }

        function deleteFriend() {
            showConfirm('确定要删除这个好友/群聊吗？所有聊天记录也将被删除。', async (confirmed) => {
                if (!confirmed) return;
                const friendIdToDelete = currentChatFriendId;
                await dbManager.delete('friends', friendIdToDelete);
                await dbManager.delete('chatHistories', friendIdToDelete);
                
                friends = friends.filter(f => f.id !== friendIdToDelete);
                delete chatHistories[friendIdToDelete];
                
                // Also remove diaries from this friend
                const friendDiaries = diaries.filter(d => d.authorId === friendIdToDelete);
                for(const diary of friendDiaries) {
                    await dbManager.delete('diaries', diary.id);
                }
                diaries = diaries.filter(d => d.authorId !== friendIdToDelete);

                showAlert('删除成功');
                backToWechat();
            });
        }

        function openBackgroundSettings() {
            const friend = friends.find(f => f.id === currentChatFriendId);
            if (!friend) return;
            tempSelectedBackground = JSON.parse(JSON.stringify(friend.chatBackground));
            setActivePage('backgroundSettingsScreen');
            document.querySelectorAll('#individualBgGrid .background-option').forEach(opt => opt.classList.remove('selected'));
            const selector = tempSelectedBackground.type === 'custom' ? '.custom' : `.${tempSelectedBackground.type}`;
            const currentBg = document.querySelector(`#individualBgGrid .background-option${selector}`);
            if (currentBg) currentBg.classList.add('selected');
            let customOption = document.querySelector('#individualBgGrid .background-option.custom');
            if (tempSelectedBackground.type === 'custom' && tempSelectedBackground.customImage) {
                if (!customOption) {
                    const grid = document.getElementById('individualBgGrid'), uploadOption = grid.children[1];
                    customOption = document.createElement('div');
                    customOption.className = 'background-option custom';
                    customOption.onclick = () => selectBackground('custom');
                    grid.insertBefore(customOption, uploadOption.nextSibling);
                }
                customOption.style.backgroundImage = `url(${tempSelectedBackground.customImage})`;
            }
        }

        function selectBackground(bgType) {
            tempSelectedBackground.type = bgType;
            if(bgType !== 'custom') tempSelectedBackground.customImage = '';
            document.querySelectorAll('#individualBgGrid .background-option').forEach(opt => opt.classList.remove('selected'));
            const selector = bgType === 'custom' ? '.custom' : `.${bgType}`;
            document.querySelector(`#individualBgGrid .background-option${selector}`)?.classList.add('selected');
        }

        async function saveBackground() {
            const friend = friends.find(f => f.id === currentChatFriendId);
            if (friend) {
                friend.chatBackground = tempSelectedBackground;
                await saveData();
                applyIndividualChatBackground(friend);
                showAlert('聊天背景已保存');
            }
            backToChatSettings();
        }

        function openChatSearch() {
            setActivePage('chatSearchScreen');
            document.getElementById('searchResults').innerHTML = '';
            document.getElementById('searchResults').classList.remove('show');
            document.getElementById('searchInput').value = '';
        }

        function searchChatHistory() {
            const keyword = document.getElementById('searchInput').value.trim();
            const resultsContainer = document.getElementById('searchResults');
            if (!keyword) return resultsContainer.classList.remove('show');
            const results = (chatHistories[currentChatFriendId] || []).filter(msg => msg.content && !msg.recalled && msg.contentType === 'text' && msg.content.toLowerCase().includes(keyword.toLowerCase()));
            resultsContainer.innerHTML = '';
            if (results.length > 0) {
                results.forEach(result => {
                    const item = document.createElement('div');
                    item.className = 'search-result-item';
                    item.onclick = () => jumpToMessage(result.id);
                    const highlighted = result.content.replace(new RegExp(keyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi'), `<span class="search-keyword">$&</span>`);
                    const ts = new Date(result.timestamp);
                    const timeStr = `${ts.toLocaleDateString()} ${ts.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
                    const sender = getAuthorById(result.senderId);
                    const senderName = sender ? sender.name : '未知';
                    item.innerHTML = `<div style="color: #666; font-size: 12px; margin-bottom: 4px;">${senderName} - ${timeStr}</div><div>${highlighted}</div>`;
                    resultsContainer.appendChild(item);
                });
            } else {
                resultsContainer.innerHTML = `<div class="search-result-item" style="color: #999;">没有找到相关消息</div>`;
            }
            resultsContainer.classList.add('show');
        }

        function jumpToMessage(messageId) {
            backToChat();
            setTimeout(() => {
                const el = document.querySelector(`#chatMessages [data-message-id="${messageId}"]`);
                const container = document.getElementById('chatMessages');
                if (el && container) {
                    container.scrollTop = el.offsetTop - (container.clientHeight / 3);
                    el.style.transition = 'background-color 0.5s';
                    el.style.backgroundColor = 'rgba(200, 200, 0, 0.5)';
                    setTimeout(() => { el.style.backgroundColor = ''; }, 2000);
                }
            }, 100);
        }

        function clearChatHistory() {
    showConfirm('确定要清空聊天记录吗？此操作不可恢复。', async (confirmed) => {
        if (!confirmed) return;

        // 步骤1：在后台清空数据存档
        chatHistories[currentChatFriendId] = [];
        await saveData();

        // 步骤2：立即清空屏幕上的聊天界面
        document.getElementById('chatMessages').innerHTML = '';

        // 步骤3：显示提示
        showAlert('聊天记录已清空');
    });
}

        function openPersonalSettings() {
    // 不再打开旧的人设页面，而是直接跳转到新的人设列表页面
    openPersonaList();
}

        async function savePersonalSettings() {
            userProfile.personality = document.getElementById('userPersonality').value.trim();
            userProfile.background = document.getElementById('userBackground').value.trim();
            userProfile.patAction = document.getElementById('userPatAction').value.trim() || '拍了拍';
            await saveData();
            showAlert('人设与背景已保存');
        }

        function backToProfile() {
            setActivePage('wechatApp');
            switchWechatTab('profile');
        }

        function openMySettings() { setActivePage('mySettingsScreen'); }
        function backToMySettings() { setActivePage('mySettingsScreen'); }
        
        function updateWalletDisplay() { document.getElementById('balanceAmount').textContent = `¥ ${parseFloat(userProfile.balance).toFixed(2)}`; }
        function openWallet() { updateWalletDisplay(); setActivePage('walletScreen'); }
        function rechargeWallet() { const amount = prompt("请输入充值金额:", "100"); if(amount && !isNaN(parseFloat(amount))) { userProfile.balance += parseFloat(amount); saveData(); updateWalletDisplay(); showAlert("充值成功！"); } else { showAlert("请输入有效金额。"); } }
        function withdrawWallet() { const amount = prompt("请输入提现金额:", "100"); if(amount && !isNaN(parseFloat(amount))) { if(userProfile.balance >= parseFloat(amount)) { userProfile.balance -= parseFloat(amount); saveData(); updateWalletDisplay(); showAlert("提现成功！"); } else { showAlert("余额不足。"); } } else { showAlert("请输入有效金额。"); } }
        function transferWallet() { showAlert('请在与好友的聊天界面中使用转账功能。'); }
        function walletHistory() { showAlert('账单功能开发中...'); }


        function openFavorites() {
            setActivePage('favoritesScreen');
            updateFavoriteList();
        }

        function toggleSelectMode() {
            selectModeActive = !selectModeActive;
            document.getElementById('selectMode').classList.toggle('show');
            document.querySelector('#favoritesScreen .nav-btn:last-of-type').textContent = selectModeActive ? '取消' : '选择';
            if (!selectModeActive) {
                selectedFavorites.clear();
                document.querySelectorAll('.favorite-item.selected').forEach(item => item.classList.remove('selected'));
            }
        }

        function updateSelectedCount() { document.getElementById('selectedCount').textContent = `已选择 ${selectedFavorites.size} 项`; }

        function deleteSelectedFavorites() {
            showConfirm(`确定要删除 ${selectedFavorites.size} 个收藏吗？`, async (confirmed) => {
                if (!confirmed) return;
                for(const favId of selectedFavorites) {
                    await dbManager.delete('favorites', favId);
                }
                favorites = favorites.filter(fav => !selectedFavorites.has(fav.id));
                updateFavoriteList();
                toggleSelectMode();
            });
        }

        function updateFavoriteList() {
            const list = document.getElementById('favoriteList');
            list.innerHTML = favorites.length === 0 ? '<div style="text-align: center; padding: 50px; color: #999;">暂无收藏</div>' : '';
            favorites.forEach(fav => {
                const item = document.createElement('div');
                item.className = 'favorite-item';
                item.onclick = () => { if (selectModeActive) { item.classList.toggle('selected'); if (selectedFavorites.has(fav.id)) selectedFavorites.delete(fav.id); else selectedFavorites.add(fav.id); updateSelectedCount(); } };
                
                let contentHtml = '';
                if (fav.contentType === 'image' || fav.contentType === 'emoji') {
                    contentHtml = `<img src="${fav.content}" style="max-width: 100px; max-height: 100px; border-radius: 4px;">`;
                } else if (fav.contentType === 'voice') {
                    contentHtml = `[语音] ${fav.content}`;
                } else {
                    contentHtml = fav.content;
                }

                item.innerHTML = `<div class="favorite-checkbox"></div><div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;"><span style="font-size: 14px; color: #666;">来自: ${fav.from}</span><span style="font-size: 12px; color: #999;">${new Date(fav.timestamp).toLocaleDateString()}</span></div><div class="favorite-content">${contentHtml}</div>`;
                list.appendChild(item);
            });
        }
        
        function openAddWorldBook() { populateFolderSelect('worldBookFolderSelect'); document.getElementById('addWorldBookModal').classList.add('show'); }
        function closeAddWorldBookModal() { document.getElementById('addWorldBookModal').classList.remove('show'); document.getElementById('worldBookNameInput').value = ''; document.getElementById('worldBookContentInput').value = ''; }
        
        async function addNewWorldBook() {
            const name = document.getElementById('worldBookNameInput').value.trim();
            const content = document.getElementById('worldBookContentInput').value.trim();
            const folderId = document.getElementById('worldBookFolderSelect').value;
            if (!name || !content) return showAlert('请填写世界书昵称和内容');
            const newBook = { id: generateUniqueId(), name, content, folderId, timestamp: new Date().toISOString() };
            const newId = await dbManager.set('worldBooks', newBook);
            newBook.id = newId;
            worldBooks.push(newBook);

            updateWorldBookList();
            closeAddWorldBookModal();
            showAlert('世界书添加成功');
        }
        
        function openEditWorldBookModal(event, bookId) {
            event.stopPropagation();
            const book = worldBooks.find(wb => wb.id === bookId);
            if (!book) return;
            populateFolderSelect('editWorldBookFolderSelect', book.folderId);
            document.getElementById('editWorldBookNameInput').value = book.name;
            document.getElementById('editWorldBookContentInput').value = book.content;
            document.getElementById('saveWorldBookEditBtn').onclick = () => saveWorldBookEdit(bookId);
            document.getElementById('editWorldBookModal').classList.add('show');
        }

        function closeEditWorldBookModal() { document.getElementById('editWorldBookModal').classList.remove('show'); }

        async function saveWorldBookEdit(bookId) {
            const book = worldBooks.find(wb => wb.id === bookId);
            if (!book) return;
            const newName = document.getElementById('editWorldBookNameInput').value.trim();
            const newContent = document.getElementById('editWorldBookContentInput').value.trim();
            if (!newName || !newContent) return showAlert('昵称和内容不能为空');
            book.name = newName;
            book.folderId = document.getElementById('editWorldBookFolderSelect').value;
            book.content = newContent;
            await dbManager.set('worldBooks', book);
            updateWorldBookList();
            closeEditWorldBookModal();
        }
        
        function deleteWorldBook(event, bookId) {
            event.stopPropagation();
            showConfirm('确定要删除这个世界书吗？', async (confirmed) => {
                if (!confirmed) return;
                await dbManager.delete('worldBooks', bookId);
                worldBooks = worldBooks.filter(wb => wb.id !== bookId);
                updateWorldBookList();
            });
        }
        
        function deleteWorldBookFolder(event, folderId) {
            event.stopPropagation();
            showConfirm('确定要删除这个文件夹吗？里面的世界书将变为"未分类"。', async (confirmed) => {
                if (!confirmed) return;
                worldBooks.forEach(wb => {
                    if (wb.folderId === folderId) {
                        wb.folderId = "";
                        dbManager.set('worldBooks', wb);
                    }
                });
                await dbManager.delete('worldBookFolders', folderId);
                worldBookFolders = worldBookFolders.filter(f => f.id !== folderId);
                updateWorldBookList();
            });
        }

        function updateWorldBookList() {
            const list = document.getElementById('worldBookList');
            list.innerHTML = '';
            const actionsButton = `<button class="nav-btn" style="padding: 4px 8px;">...</button>`;

            worldBookFolders.forEach(folder => {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'worldbook-folder';
                const booksInFolder = worldBooks.filter(wb => wb.folderId === folder.id);
                folderDiv.innerHTML = `<div class="worldbook-folder-header">
                                        <div onclick="this.parentElement.classList.toggle('expanded')" style="flex-grow: 1; display: flex; align-items: center;">
                                            <span class="folder-arrow" style="margin-right: 10px;">></span>
                                            <span>${folder.name} (${booksInFolder.length})</span>
                                        </div>
                                        <div class="worldbook-folder-actions" onclick="deleteWorldBookFolder(event, '${folder.id}')">${actionsButton}</div>
                                    </div>
                                    <div class="worldbook-folder-content"></div>`;
                const contentDiv = folderDiv.querySelector('.worldbook-folder-content');
                contentDiv.innerHTML = booksInFolder.map(book => 
                    `<div class="worldbook-item">
                        <div class="worldbook-item-info" onclick="openEditWorldBookModal(event, '${book.id}')">
                            <div class="worldbook-title">${book.name}</div>
                        </div>
                        <div class="worldbook-item-actions" onclick="deleteWorldBook(event, '${book.id}')">${actionsButton}</div>
                    </div>`).join('') || '<div style="padding: 15px; color: #999;">这个文件夹是空的</div>';
                list.appendChild(folderDiv);
            });

            const uncategorizedBooks = worldBooks.filter(wb => !wb.folderId || !worldBookFolders.some(f => f.id === wb.folderId));
            uncategorizedBooks.forEach(book => {
                const item = document.createElement('div');
                item.className = 'worldbook-item';
                item.style.margin = "0 0 10px 0";
                item.innerHTML = `<div class="worldbook-item-info" onclick="openEditWorldBookModal(event, '${book.id}')">
                                      <div class="worldbook-title">${book.name}</div>
                                  </div>
                                  <div class="worldbook-item-actions" onclick="deleteWorldBook(event, '${book.id}')">${actionsButton}</div>`;
                list.appendChild(item);
            });

            if (list.innerHTML === '') list.innerHTML = '<div style="text-align: center; padding: 50px; color: #999;">暂无世界书</div>';
        }
        
        function openAddWorldBookFolderModal() { document.getElementById('addWorldBookFolderModal').classList.add('show'); }
        function closeAddWorldBookFolderModal() { document.getElementById('addWorldBookFolderModal').classList.remove('show'); }
        async function addNewWorldBookFolder() {
            const name = document.getElementById('worldBookFolderNameInput').value.trim();
            if (!name) return showAlert('请输入文件夹名称');
            const newFolder = { id: generateUniqueId(), name };
            const newId = await dbManager.set('worldBookFolders', newFolder);
            newFolder.id = newId;
            worldBookFolders.push(newFolder);
            updateWorldBookList();
            closeAddWorldBookFolderModal();
        }

        function populateFolderSelect(selectId, selectedId = '') {
            const select = document.getElementById(selectId);
            select.innerHTML = '<option value="">无文件夹</option>';
            worldBookFolders.forEach(folder => {
                const option = document.createElement('option');
                option.value = folder.id;
                option.textContent = folder.name;
                select.appendChild(option);
            });
            select.value = selectedId;
        }
        
        function openWorldBookBindingModal() {
            const friend = friends.find(f => f.id === currentChatFriendId);
            if (!friend) return;

            const container = document.getElementById('worldBookBindingList');
            container.innerHTML = '';
            const boundBookIds = new Set(friend.worldBookIds || []);
            const boundFolderIds = new Set(friend.boundFolderIds || []);

            worldBookFolders.forEach(folder => {
                const isFolderChecked = boundFolderIds.has(folder.id);
                const item = document.createElement('div');
                item.className = 'multi-select-item';
                item.innerHTML = `<input type="checkbox" data-type="folder" id="wbf-${folder.id}" value="${folder.id}" ${isFolderChecked ? 'checked' : ''}>
                                  <label for="wbf-${folder.id}">[文件夹] ${folder.name}</label>`;
                container.appendChild(item);
            });
            
            const uncategorizedBooks = worldBooks.filter(wb => !wb.folderId || !worldBookFolders.some(f => f.id === wb.folderId));
            uncategorizedBooks.forEach(book => {
                const isChecked = boundBookIds.has(book.id);
                const item = document.createElement('div');
                item.className = 'multi-select-item';
                item.innerHTML = `<input type="checkbox" data-type="book" id="wb-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}>
                                  <label for="wb-${book.id}">${book.name}</label>`;
                container.appendChild(item);
            });

            if (container.innerHTML === '') {
                 container.innerHTML = '<div style="color: #999;">暂无世界书或文件夹可绑定</div>';
            }
            document.getElementById('worldBookBindingModal').classList.add('show');
        }
        
        function closeWorldBookBindingModal() {
            document.getElementById('worldBookBindingModal').classList.remove('show');
        }
        
        function confirmWorldBookBinding() {
            const friend = friends.find(f => f.id === currentChatFriendId);
            if (!friend) return;
            
            const selectedBooks = [];
            document.querySelectorAll('#worldBookBindingList input[data-type="book"]:checked').forEach(checkbox => selectedBooks.push(checkbox.value));
            friend.worldBookIds = selectedBooks;
            
            const selectedFolders = [];
            document.querySelectorAll('#worldBookBindingList input[data-type="folder"]:checked').forEach(checkbox => selectedFolders.push(checkbox.value));
            friend.boundFolderIds = selectedFolders;
            
            showAlert('绑定成功！');
            closeWorldBookBindingModal();
        }

        function openDiary() { 
            setActivePage('diaryScreen');
            renderDiaryFriendList();
            document.getElementById('diaryNavFriendName').textContent = '';
        }

                // 【【【这是修改后的新代码，请用它完整替换】】】
        function renderDiaryFriendList() {
        // 1. 同样找到导航栏和返回按钮
    const navBar = document.querySelector('#diaryScreen .nav-bar');
    const backBtn = navBar.querySelector('.nav-btn');

    // 2. 将返回按钮的onclick事件恢复为 backToDiscover()
    backBtn.setAttribute('onclick', 'backToDiscover()');

    // --- ↑↑↑ 新代码添加到这里结束 ↑↑↑ ---
            const friendList = document.getElementById('diaryFriendList');
            const contentArea = document.getElementById('diaryContentArea');
            friendList.style.display = 'block';
            contentArea.innerHTML = '';
            friendList.innerHTML = ''; // 清空旧内容

            const availableFriends = friends.filter(f => !f.isGroup);

            if(availableFriends.length === 0) {
                 friendList.innerHTML = '<div style="text-align: center; padding: 50px; color: #999;">暂无好友</div>';
                 return;
            }
            
            // 1. 创建一个网格容器
            const gridContainer = document.createElement('div');
            gridContainer.className = 'diary-friend-grid'; // 使用我们新写的CSS类

            // 2. 循环把每个好友变成一个“日记书”放进网格里
            availableFriends.forEach(friend => {
                const item = document.createElement('div');
                item.className = 'diary-book-item'; // 使用我们新写的CSS类
                item.onclick = () => showFriendDiary(friend.id); // 点击事件不变

                const avatarHtml = friend.avatarImage 
                    ? `<div class="diary-book-avatar" style="background-image: url(${friend.avatarImage})"></div>`
                    : `<div class="diary-book-avatar">${friend.avatar}</div>`;

                item.innerHTML = `
                    ${avatarHtml}
                    <div class="diary-book-name">${friend.remark || friend.name}</div>
                `;

                gridContainer.appendChild(item);
            });
            
            // 3. 把装满“日记书”的整个网格容器，一次性放回页面
            friendList.appendChild(gridContainer);
        }
        
                        // 【【【这是修改后的新代码，请用它完整替换】】】
        function showFriendDiary(friendId) {
            const friend = friends.find(f => f.id === friendId);
            if (!friend) return;
            // 1. 找到日记页面的导航栏和返回按钮
    const navBar = document.querySelector('#diaryScreen .nav-bar');
    const backBtn = navBar.querySelector('.nav-btn');

    // 2. 动态修改返回按钮的onclick事件
    //    让它点击后调用 renderDiaryFriendList() 函数，即重新显示角色选择列表
    backBtn.setAttribute('onclick', 'renderDiaryFriendList()');

    // --- ↑↑↑ 新代码添加到这里结束 ↑↑↑ ---
            document.getElementById('diaryFriendList').style.display = 'none';
            
            // *** 核心修改1：把导航栏右侧区域的内容，从纯文本换成一个按钮 ***
            const navRightSide = document.getElementById('diaryNavFriendName');
            navRightSide.innerHTML = `
                <button class="generate-diary-btn" id="manualGenerateBtn" onclick="forceGenerateDiary('${friend.id}')">
                    <svg viewBox="0 0 24 24"><path d="M14.06,9L15,9.94L5.92,19H5V18.08L14.06,9M17.66,3C17.41,3 17.15,3.1 16.96,3.29L15.13,5.12L18.88,8.87L20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18.17,3.09 17.92,3 17.66,3M14.06,6.19L3,17.25V21H6.75L17.81,9.94L14.06,6.19Z" /></svg>
                </button>
            `;

            const list = document.getElementById('diaryContentArea');
            const friendDiaries = diaries.filter(d => d.authorId === friendId).sort((a,b) => new Date(b.date) - new Date(a.date));
            
            list.innerHTML = '';

            if (friendDiaries.length === 0) {
                list.innerHTML = '<div style="text-align: center; padding: 50px; color: #999;">Ta还没有写过日记</div>';
                return;
            }

            friendDiaries.forEach(diary => {
                const item = document.createElement('div');
                item.className = 'diary-cover-item'; 
                item.setAttribute('onclick', `showFullDiary('${diary.id}')`); 

                const avatarHtml = diary.avatarImage 
                    ? `<div class="diary-cover-avatar" style="background-image: url(${diary.avatarImage})"></div>`
                    : `<div class="diary-cover-avatar" style="background-color: #eee; display: flex; align-items: center; justify-content: center;">${diary.avatar}</div>`;

                item.innerHTML = `
                    <div class="diary-cover-header">
                        ${avatarHtml}
                        <div class="diary-cover-info">
                            <div class="diary-cover-author">${diary.author}</div>
                            <div class="diary-cover-date">${diary.date}</div>
                        </div>
                    </div>
                    <div class="diary-cover-thought">“${diary.heartfeltThought || '...'}”</div>
                `;
                list.appendChild(item);
            });
        }
        
        /**
 * 【【【这是一个全新的函数，负责处理按钮点击事件】】】
 * @param {string} friendId - 好友的ID
 */
async function forceGenerateDiary(friendId) {
    const btn = document.getElementById('manualGenerateBtn');
    if (!btn || btn.classList.contains('loading')) return; // 防止重复点击

    // 1. 让按钮进入加载状态
    btn.classList.add('loading');
    btn.disabled = true;

    // 2. 调用我们新的核心函数来生成日记
    const success = await generateDiaryForFriend(friendId, true); // true表示是手动触发

    // 3. 如果成功了，就刷新当前界面
    if (success) {
        showFriendDiary(friendId); // 重新渲染列表，显示新日记
        showAlert('新日记已生成！');
    }
    
    // 4. 恢复按钮状态
    btn.classList.remove('loading');
    btn.disabled = false;
}
        
        function backToDiscover() { 
            setActivePage('wechatApp');
            switchWechatTab('discover'); 
            if(document.getElementById('diaryFriendList').style.display === 'none') {
                document.getElementById('diaryFriendList').style.display = 'block';
                document.getElementById('diaryContentArea').innerHTML = '';
            }
        }
        
            /**
     * 新增：显示单篇日记的全文
     * @param {string} diaryId - 要显示的日记的ID
     */
    function showFullDiary(diaryId) {
        const diary = diaries.find(d => d.id === diaryId);
        if (!diary) return;

        // 找到我们新创建的HTML页面和内容区域
        const contentDiv = document.getElementById('fullDiaryContent');
        const backBtn = document.getElementById('backToDiaryListBtn');

        // 把日记内容填进去
        contentDiv.textContent = diary.content;
        
        // 让返回按钮知道应该返回到哪个好友的日记列表
        backBtn.setAttribute('onclick', `backToDiaryList('${diary.authorId}')`);

        // 切换到日记全文页面
        setActivePage('diaryViewScreen');
    }

    /**
     * 新增：从日记全文页返回到日记封面列表页
     * @param {string} friendId - 好友的ID
     */
    function backToDiaryList(friendId) {
        setActivePage('diaryScreen');
        // 重新调用一次 showFriendDiary 来刷新列表页
        showFriendDiary(friendId);
    }
        
        function backToTheme() { setActivePage('themeApp'); }

        function openFontSettings() {
            setActivePage('fontSettingsScreen');
            document.querySelectorAll('.font-option').forEach(opt => opt.classList.remove('selected'));
            document.querySelector(`.font-option.${selectedFont}`).classList.add('selected');
            document.getElementById('fontSizeSlider').value = selectedFontSize;
            document.getElementById('fontSizeValue').textContent = selectedFontSize + 'px';
            document.getElementById('fontColorPicker').value = selectedFontColor;
            document.getElementById('fontColorInput').value = selectedFontColor;
            document.getElementById('fontUrlInput').value = customFontUrl;
            document.getElementById('appLabelColorPicker').value = selectedAppLabelColor;
document.getElementById('appLabelColorInput').value = selectedAppLabelColor;
        }

        function selectFont(fontType) {
            selectedFont = fontType;
            document.querySelectorAll('.font-option').forEach(opt => opt.classList.remove('selected'));
            document.querySelector(`.font-option.${fontType}`).classList.add('selected');
            applyCustomFont(customFontUrl);
        }

        function adjustFontSize(size) { selectedFontSize = parseInt(size); document.getElementById('fontSizeValue').textContent = size + 'px'; applyFont(); }
        async function saveFont() { applyFont(); applyAppLabelColor(); await saveData(); showAlert('字体设置已保存'); backToTheme(); }
        
        function openIconSettings() { setActivePage('iconSettingsScreen'); renderIconSettingsList(); }

        function renderIconSettingsList() {
            const container = document.getElementById('iconSettingsList');
            container.innerHTML = '';
            ['wechat', 'settings', 'worldbook', 'theme', 'phone', 'placeholder1', 'placeholder2'].forEach(id => {
                const name = {wechat:'微信', settings:'设置', worldbook:'世界书', theme:'主题', phone:'手机', placeholder1: '闲置1', placeholder2: '闲置2'}[id];
                const item = document.createElement('div');
                item.className = 'icon-setting-item';
                item.innerHTML = `<div class="icon-setting-preview" id="preview-${id}" style="background-image: url(${customIcons[id] || ''})"></div><div class="icon-setting-label">${name}</div><label class="icon-setting-btn">上传<input type="file" accept="image/*" onchange="handleIconUpload(event, '${id}')"></label>`;
                container.appendChild(item);
            });
        }
        
        function restoreDefaultIcons() {
            showConfirm("确定要恢复所有默认图标吗？", async (confirmed) => {
                if (!confirmed) return;
                customIcons = {};
                await saveData();
                applyCustomIcons();
                renderIconSettingsList();
                showAlert("图标已恢复默认。");
            });
        }
        
        function getDefaultIconSVG(appId) {
             const svgs = {
                wechat: `<svg class="app-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 2C6.477 2 2 6.477 2 12c0 3.978 2.32 7.439 5.698 9.062L7 22l3.41-2.131A10.12 10.12 0 0 0 12 20c5.523 0 10-4.477 10-10S17.523 2 12 2zM8.5 13.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3zm7 0a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z"/></svg>`,
                settings: `<svg class="app-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M12 15.5A3.5 3.5 0 0 1 8.5 12A3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5m7.43-2.53c.04-.32.07-.64.07-.97c0-.33-.03-.66-.07-1l2.11-1.63c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.31-.61-.22l-2.49 1c-.52-.39-1.06-.73-1.69-.98l-.37-2.65A.506.506 0 0 0 14 2h-4c-.25 0-.46.18-.5.42l-.37 2.65c-.63.25-1.17.59-1.69-.98l-2.49-1c-.22-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64L4.57 11c-.04.34-.07.67-.07 1c0 .33.03.65.07.97l-2.11 1.66c-.19.15-.25.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1.01c.52.4 1.06.74 1.69.99l.37 2.65c.04.24.25.42.5.42h4c.25 0 .46-.18.5.42l.37-2.65c.63-.26 1.17-.59 1.69-.99l2.49 1.01c.22.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.66Z"/></svg>`,
                worldbook: `<svg class="app-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/></svg>`,
                theme: `<svg class="app-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M12,18C8.69,18 6,15.31 6,12C6,8.69 8.69,6 12,6C15.31,6 18,8.69 18,12C18,15.31 15.31,18 12,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,7A5,5 0 0,0 7,12A5,5 0 0,0 12,17A5,5 0 0,0 17,12A5,5 0 0,0 12,7Z"/><circle cx="12" cy="12" r="3" fill="currentColor"/></svg>`,
                phone: `<svg class="app-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M6.62,10.79C8.06,13.62 10.38,15.94 13.21,17.38L15.41,15.18C15.69,14.9 16.08,14.82 16.43,14.93C17.55,15.3 18.75,15.5 20,15.5A1,1 0 0,1 21,16.5V20A1,1 0 0,1 20,21A17,17 0 0,1 3,4A1,1 0 0,1 4,3H7.5A1,1 0 0,1 8.5,4C8.5,5.25 8.7,6.45 9.07,7.57C9.18,7.92 9.1,8.31 8.82,8.59L6.62,10.79Z"/></svg>`,
                placeholder1: `<svg class="app-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M20,18H4V8H20M20,6H12L10,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V8C22,6.89 21.1,6 20,6Z" /></svg>`,
                placeholder2: `<svg class="app-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M14.5,12A2.5,2.5 0 0,0 12,9.5A2.5,2.5 0 0,0 9.5,12A2.5,2.5 0 0,0 12,14.5A2.5,2.5 0 0,0 14.5,12M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4Z" /></svg>`,
             };
             return svgs[appId] || '';
        }

        async function handleIconUpload(event, appId) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                const dataUrl = e.target.result;
                customIcons[appId] = dataUrl;
                applyCustomIcon(appId, dataUrl);
                document.getElementById(`preview-${appId}`).style.backgroundImage = `url(${dataUrl})`;
                await saveData();
            };
            reader.readAsDataURL(file);
        }

        function applyCustomIcon(appId, dataUrl) { 
            const el = document.getElementById(`icon-${appId}`); 
            if (el) { el.style.backgroundImage = `url(${dataUrl})`; el.innerHTML = ''; } 
        }

        function applyCustomIcons() { 
            for (const appId in customIcons) applyCustomIcon(appId, customIcons[appId]);
            ['wechat', 'settings', 'worldbook', 'theme', 'phone', 'placeholder1', 'placeholder2'].forEach(id => {
                if (!customIcons[id]) {
                    const el = document.getElementById(`icon-${id}`);
                    if (el) { el.style.backgroundImage = ''; el.innerHTML = getDefaultIconSVG(id); }
                }
            });
        }
        
        // NEW: Component Settings Functions
        function openComponentSettings() {
            setActivePage('componentSettingsScreen');
            applyComponentTransparency(); // Ensure toggles are in correct state
        }
        
        async function toggleProfileWidgetBg() {
            profileWidgetTransparent = document.getElementById('profileWidgetBgToggle').checked;
            applyComponentTransparency();
            await saveData();
        }

        async function toggleSmallWidgetBg() {
            smallWidgetTransparent = document.getElementById('smallWidgetBgToggle').checked;
            applyComponentTransparency();
            await saveData();
        }


        function openGlobalChatBg() {
            setActivePage('globalChatBgScreen');
            document.querySelectorAll('#globalBgGrid .background-option').forEach(opt => opt.classList.remove('selected'));
            const selector = selectedGlobalChatBg === 'custom' ? '.custom' : `.${selectedGlobalChatBg}`;
            document.querySelector(`#globalBgGrid .background-option${selector}`)?.classList.add('selected');
            let customOption = document.querySelector('#globalBgGrid .background-option.custom');
            if (selectedGlobalChatBg === 'custom' && customGlobalChatBgImage) {
                if (!customOption) {
                    const grid = document.getElementById('globalBgGrid'), uploadOption = grid.children[1];
                    customOption = document.createElement('div');
                    customOption.className = 'background-option custom selected';
                    customOption.onclick = () => selectGlobalChatBg('custom');
                    grid.insertBefore(customOption, uploadOption.nextSibling);
                }
                customOption.style.backgroundImage = `url(${customGlobalChatBgImage})`;
            }
        }

        function selectGlobalChatBg(bgType) {
            selectedGlobalChatBg = bgType;
            if(bgType !== 'custom') customGlobalChatBgImage = '';
            document.querySelectorAll('#globalBgGrid .background-option').forEach(opt => opt.classList.remove('selected'));
            const selector = bgType === 'custom' ? '.custom' : `.${bgType}`;
            document.querySelector(`#globalBgGrid .background-option${selector}`)?.classList.add('selected');
        }

        async function saveGlobalChatBg() { applyGlobalChatBackground(); await saveData(); showAlert('全局背景已保存'); backToMySettings(); }
        
        function changeAvatar() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = (e) => {
        const file = e.target.files[0];
        if(file) {
            const reader = new FileReader();
            reader.onload = async (event) => { 
                userProfile.avatarImage = event.target.result; 
                userProfile.avatar = ''; 
                updateProfileDisplay(); 
                await saveProfileData();
            };
            reader.readAsDataURL(file);
        }
    };
    input.click();
}
        
        function openMoments() { setActivePage('momentsScreen'); updateMomentsList(); }
        function openAddMoment() { document.getElementById('addMomentModal').classList.add('show'); }

        function handleMomentImageUpload(event) {
             const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    momentImage = e.target.result;
                    momentImageDescription = ''; // User uploaded images have no description
                    document.getElementById('momentImageUpload').style.backgroundImage = `url(${e.target.result})`;
                    document.getElementById('momentImagePreview').textContent = '';
                };
                reader.readAsDataURL(file);
            }
        }

        function closeAddMomentModal() {
            document.getElementById('addMomentModal').classList.remove('show');
            document.getElementById('momentContentInput').value = '';
            momentImage = '';
            momentImageDescription = '';
            document.getElementById('momentImageUpload').style.backgroundImage = '';
            document.getElementById('momentImagePreview').textContent = '+';
        }
        
        async function postNewMoment() {
    const content = document.getElementById('momentContentInput').value.trim();
    if (!content && !momentImage) return showAlert('内容和图片不能都为空');
    
    const newMoment = { 
        id: generateUniqueId(), 
        authorId: userProfile.id, 
        content, 
        imageUrl: momentImage, 
        imageDescription: '', 
        timestamp: new Date().toISOString(), 
        likes: [], 
        comments: [] 
    };
    
    const newId = await dbManager.set('moments', newMoment);
    newMoment.id = newId;
    moments.unshift(newMoment);
    updateMomentsList();
    
    // --- [核心修改] 在这里触发AI好友和NPC的反应 ---
    triggerAiMomentReactions(newMoment); // 触发AI好友的反应（点赞+评论）
    generateNpcFriends(newMoment);      // 触发生成NPC并让他们进行评论
    // --- 修改结束 ---
    
    closeAddMomentModal(); 
}

    // 新增：删除朋友圈的函数
    async function deleteMoment(momentId) {
        showConfirm('确定要删除这条朋友圈吗？删除后将无法恢复，并且AI好友也无法看到。', async (confirmed) => {
            if (!confirmed) {
                return; // 如果用户取消，则不做任何操作
            }

            // 从 moments 数组中移除这条朋友圈
            moments = moments.filter(m => m.id !== momentId);
            await dbManager.delete('moments', momentId);

            // 刷新朋友圈列表，以便在界面上移除被删除的朋友圈
            updateMomentsList();

            showAlert('朋友圈已成功删除。');
        });
    }

        function timeSince(date) {
            const seconds = Math.floor((new Date() - new Date(date)) / 1000);
            let interval = seconds / 31536000;
            if (interval > 1) return Math.floor(interval) + " 年前";
            interval = seconds / 2592000;
            if (interval > 1) return Math.floor(interval) + " 月前";
            interval = seconds / 86400;
            if (interval > 1) return Math.floor(interval) + " 天前";
            interval = seconds / 3600;
            if (interval > 1) return Math.floor(interval) + " 小时前";
            interval = seconds / 60;
            if (interval > 1) return Math.floor(interval) + " 分钟前";
            return "刚刚";
        }
        
                        function getAuthorById(authorId) {
            if (!authorId) {
                console.warn(`尝试获取作者信息但 authorId 为空或无效: ${authorId}`);
                return { id: 'unknown', name: '未知用户', avatar: '?', avatarImage: '' };
            }
            if (authorId === userProfile.id) {
                return userProfile;
            }
            // 优先从当前群聊成员中查找，确保信息最准确
            const currentGroup = friends.find(f => f.id === currentChatFriendId && f.isGroup);
            if (currentGroup) {
                const memberInGroup = friends.find(f => f.id === authorId && currentGroup.members.includes(f.id));
                if (memberInGroup) return memberInGroup;
            }
            // 如果不在当前群聊或不是群聊模式，则从总好友列表查找
            const foundFriend = friends.find(f => f.id === authorId);
            if (foundFriend) {
                return foundFriend;
            }

            if (typeof authorId === 'string' && authorId.startsWith('npc_')) {
                const npcName = authorId.replace('npc_', '');
                const foundNpc = npcFriends.find(npc => npc.name === npcName);
                if (foundNpc) {
                     return { id: authorId, name: foundNpc.name, avatar: foundNpc.name.substring(0, 1), avatarImage: '' };
                }
                for (const moment of moments) {
                    const foundComment = moment.comments.find(c => c.authorId === authorId);
                    if (foundComment && foundComment.name) {
                        return { id: authorId, name: foundComment.name, avatar: foundComment.name.substring(0, 1), avatarImage: '' };
                    }
                }
            }
            
            console.warn(`未找到ID为 ${authorId} 的好友信息。`);
            return { id: authorId, name: '未知用户', avatar: '?', avatarImage: '' };
        }

        function viewMomentImage(momentId) {
            const moment = moments.find(m => m.id === momentId);
            if (!moment) return;
        
            if(moment.imageDescription) {
                showImageDescription(moment.imageDescription);
            } else if (moment.imageUrl) {
                 const img = new Image();
                 img.src = moment.imageUrl;
                 const newWindow = window.open("");
                 if (newWindow) {
                    newWindow.document.write(img.outerHTML);
                 } else {
                    showAlert("浏览器阻止了弹出窗口，无法查看大图。");
                 }
            }
        }

        function updateMomentsList() {
    const container = document.getElementById('momentsList');
    container.innerHTML = ''; 

    // --- 朋友圈封面和用户信息显示代码 ---
    const coverDiv = document.createElement('div');
    coverDiv.className = 'moments-cover';
    coverDiv.style.backgroundImage = `url(${userProfile.momentsCover || 'https://via.placeholder.com/400x250/cccccc/ffffff?text=Click+to+change'})`;
    coverDiv.onclick = () => {
         const input = document.createElement('input');
         input.type = 'file'; input.accept = 'image/*';
         input.onchange = e => {
            const file = e.target.files[0];
            if(file) {
                const reader = new FileReader();
                reader.onload = async event => { userProfile.momentsCover = event.target.result; await saveData(); updateMomentsList(); };
                reader.readAsDataURL(file);
            }
         };
         input.click();
    };
    const userDiv = document.createElement('div');
    userDiv.className = 'moments-cover-user';
    userDiv.innerHTML = `<span class="moments-cover-name">${userProfile.name}</span><div class="moments-cover-avatar" style="background-image: url(${userProfile.avatarImage || ''})"></div>`; // 确保头像显示
    coverDiv.appendChild(userDiv);
    container.appendChild(coverDiv);
    // --- 朋友圈封面和用户信息显示代码结束 ---
    
    moments.forEach(moment => {
        const author = getAuthorById(moment.authorId); // 朋友圈作者
        if (!author) return;
        const item = document.createElement('div');
        item.className = 'moments-item'; item.dataset.momentId = moment.id;
                item.className = 'moments-item'; 
        item.dataset.momentId = moment.id;
       

        // --- 朋友圈作者头像和信息 ---
        const avatar = author.avatarImage ? `<div class="moments-avatar" style="background-image: url('${author.avatarImage}')"></div>` : `<div class="moments-avatar">${author.name.substring(0,1)}</div>`;
        const isLiked = moment.likes.includes(userProfile.id);
        let likesHtml = '', commentsHtml = '';
        const likeIconSvg = `<svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`;
        const commentIconSvg = `<svg viewBox="0 0 24 24" fill="white"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/></svg>`;
        // --- 朋友圈作者头像和信息结束 ---

        // --- 点赞显示逻辑 (最终修正版) ---
if (moment.likes.length > 0) {
    const likerNames = moment.likes.map(id => {
        const author = getAuthorById(id);
        return author ? author.name : null;
    }).filter(Boolean);

    const namesHtml = likerNames.map(name => `<strong>${name}</strong>`).join(', ');
    
    // 【核心修改】在这里给名字列表套上了一个 span 标签
    likesHtml = `<div class="moments-likes">${likeIconSvg}<span class="liker-names">${namesHtml}</span></div>`;
}
// --- 点赞显示逻辑结束 ---
        
        // --- 评论和回复显示逻辑 ---
        if (moment.comments.length > 0) {
            commentsHtml = `<div class="moments-comments-list">`;
            // 对评论按时间排序，确保楼层顺序
            const sortedComments = [...moment.comments].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            sortedComments.forEach(comment => {
    // 【【【核心修正】】】
    // 这里的 getAuthorById 已经是我们重写过的版本，可以正确处理用户、AI好友和NPC
    const commentAuthor = getAuthorById(comment.authorId); 
    
    // 如果作者信息里没有名字（比如老数据），但评论对象里有，就用评论里的
    if (!commentAuthor.name && comment.name) {
        commentAuthor.name = comment.name;
    }

    if (!commentAuthor || !commentAuthor.name) return; // 确保作者信息有效
                
                let commentPrefix = '';
                // 根据 replyToCommentId 和 replyToAuthorId 决定评论显示格式
                if (comment.replyToCommentId && comment.replyToAuthorId) {
                    // 如果存在回复的评论ID和回复的作者ID，说明这是对某个具体评论的回复
                    const repliedToAuthor = getAuthorById(comment.replyToAuthorId); // 被回复的作者
                    // 精确调整“回复了”的间距

// *** 这是新的代码，请替换掉原来的那一行 ***
// 注意：您可以修改 spacing_before_huifule 和 spacing_after_huifule 的像素值来调整间距
const spacing_before_huifule = 8; // 这里调整“名字1”和“回复了”之间的间距 (推荐小一点，如 2px)
const spacing_after_huifule = 0;  // 这里调整“回复了”和“名字2”之间的间距 (推荐小一点，如 2px)

commentPrefix = `<span class="moments-comment-author">${commentAuthor.name}</span><span style="color: var(--text-color, #333); margin-left: ${spacing_before_huifule}px; margin-right: ${spacing_after_huifule}px;">回复</span><span class="moments-comment-author">${repliedToAuthor ? repliedToAuthor.name : '未知'}：</span>`;

                } else {
                    // 如果没有回复信息，说明这是对朋友圈的直接评论
                    commentPrefix = `<span class="moments-comment-author">${commentAuthor.name}：</span>`;
                }

                // 给每个评论项添加 onclick 事件，以便点击它来回复这条评论
                                // 给每个评论项添加 onclick 事件，以便点击它来回复这条评论
                // ...

commentsHtml += `
    <div class="moments-comment-item" 
         data-moment-id="${moment.id}"  
         data-comment-id="${comment.id}" 
         data-comment-author-id="${comment.authorId}"
         onclick="showCommentInput('${moment.id}', '${comment.id}', '${comment.authorId}')">
         ${commentPrefix}
         ${comment.content}
    </div>`;

            });
            commentsHtml += `</div>`;
        }
        // --- 评论和回复显示逻辑结束 ---

        // --- 图片显示逻辑 ---
        const imageHtml = moment.imageUrl ? `<img src="${moment.imageUrl}" class="moments-image" onclick="viewMomentImage('${moment.id}')">` : '';
        // --- 图片显示逻辑结束 ---

        // --- 朋友圈底部操作区（时间、操作按钮） ---
        item.innerHTML = `
            <div class="moments-header">
                ${avatar}
                <div class="moments-info">
                    <div class="moments-name">${author.name}</div>
                    <div class="moments-content">${moment.content}</div>
                    ${imageHtml}
                    <div class="moments-footer">
    <div class="moments-time-group"> 
        <div class="moments-time">${timeSince(moment.timestamp)}</div>
        ${moment.authorId === userProfile.id ? `<svg class="moments-delete-icon" viewBox="0 0 24 24" onclick="deleteMoment('${moment.id}')"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>` : ''}
    </div> 
    <div class="moments-actions">
        <button class="moments-actions-btn" onclick="toggleActionsMenu(event, '${moment.id}')">...</button>
                            <div class="moments-actions-menu" id="actions-menu-${moment.id}">
                                <div class="moments-action" onclick="likeMoment('${moment.id}')">
                                    ${likeIconSvg}
                                    <span>${isLiked ? '取消' : '赞'}</span>
                                </div>
                                <div class="moments-action" onclick="showCommentInput('${moment.id}')">
                                    ${commentIconSvg}
                                    <span>评论</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            ${(likesHtml || commentsHtml) ? `<div class="moments-likes-comments" style="margin-left: 52px;">${likesHtml}${commentsHtml}</div>` : ''}
        `;
        // --- 朋友圈底部操作区结束 ---
        
        container.appendChild(item);
    });
}
        
        function toggleActionsMenu(event, momentId) {
            event.stopPropagation();
            document.querySelectorAll('.moments-actions-menu').forEach(m => m.id !== `actions-menu-${momentId}` && m.classList.remove('show'));
            document.getElementById(`actions-menu-${momentId}`).classList.toggle('show');
        }
        
        document.addEventListener('click', () => document.querySelectorAll('.moments-actions-menu.show').forEach(m => m.classList.remove('show')));

        async function likeMoment(momentId) {
            const moment = moments.find(m => m.id === momentId);
            if (!moment) return;
            const likeIndex = moment.likes.indexOf(userProfile.id);
            if (likeIndex > -1) moment.likes.splice(likeIndex, 1);
            else moment.likes.push(userProfile.id);
            await saveData();
            updateMomentsList();
        }
        
                        // 全局变量来保存点击监听器函数，以便可以移除它
let clickOutsideCommentInputHandler = null;

function hideCommentInput() { 
    console.log("[hideCommentInput] 函数被调用，重置评论状态。"); // 增加调试日志

    currentCommentingMomentId = null; 
    currentReplyToCommentId = null; 
    currentReplyToAuthorId = null;  
    document.getElementById('momentCommentInputArea').classList.remove('show'); 
    document.getElementById('momentCommentInput').value = ''; 
    document.getElementById('momentCommentInput').placeholder = '评论...'; 
    
    // --- 新增代码：移除全局点击监听器 ---
    if (clickOutsideCommentInputHandler) {
        document.removeEventListener('click', clickOutsideCommentInputHandler);
        clickOutsideCommentInputHandler = null;
    }
    // ------------------------------------
}
        
        function showCommentInput(momentId, targetCommentId = null, targetCommentAuthorId = null) {
    // 隐藏所有其他朋友圈操作菜单，避免干扰
    document.querySelectorAll('.moments-actions-menu').forEach(m => m.classList.remove('show'));

    currentCommentingMomentId = momentId;
    currentReplyToCommentId = targetCommentId; // 存储用户点击要回复的评论的ID

    const input = document.getElementById('momentCommentInput');
    const sendBtn = document.getElementById('momentCommentSendBtn');

    let placeholderText = "评论..."; // 默认占位符
    let actualTargetAuthorName = '未知'; // 用于调试弹窗中显示的名字

    // !!! 关键修改：移除这里的 showAlert，因为它可能导致意外行为 !!!
    // console.log(`[showCommentInput] momentId: ${momentId}, targetCommentId: ${targetCommentId}, targetCommentAuthorId: ${targetCommentAuthorId}, typeof targetCommentAuthorId: ${typeof targetCommentAuthorId}`); // 控制台日志保留

    if (targetCommentId && targetCommentAuthorId) { // 如果用户点击了某个具体评论的文字来回复
        currentReplyToAuthorId = targetCommentAuthorId; // 存储被回复评论的作者ID
        const targetAuthor = getAuthorById(targetCommentAuthorId); // 获取被回复评论的作者信息
        actualTargetAuthorName = targetAuthor ? targetAuthor.name : '未知';
        placeholderText = `回复${actualTargetAuthorName}...`; // 设置为“回复XX...”
    } else { // 如果用户点击了朋友圈卡片下方的“评论”按钮，即对朋友圈本身进行评论
        const moment = moments.find(m => m.id === momentId);
        const momentAuthor = getAuthorById(moment.authorId); // 获取朋友圈作者信息
        currentReplyToAuthorId = momentAuthor.id; // 存储朋友圈作者ID，表示回复朋友圈本身
        actualTargetAuthorName = momentAuthor ? momentAuthor.name : '未知';
        placeholderText = `回复${momentAuthor.name}的朋友圈...`; // 设置为“回复XX的朋友圈...”
    }
    
    input.placeholder = placeholderText; // 更新输入框占位符
    sendBtn.textContent = '发送'; // 确保按钮文本是“发送”
    sendBtn.disabled = false; // 确保按钮可用

    document.getElementById('momentCommentInputArea').classList.add('show'); // 显示评论输入区域
    input.focus(); // 自动聚焦到输入框
        input.focus(); // 自动聚焦到输入框

    // --- 新增代码：在显示输入框时添加全局点击监听器 ---
    // 先移除旧的监听器，防止重复添加
    if (clickOutsideCommentInputHandler) {
        document.removeEventListener('click', clickOutsideCommentInputHandler);
    }

    // 定义新的监听器函数
    clickOutsideCommentInputHandler = (event) => {
        const commentInputArea = document.getElementById('momentCommentInputArea');
        const momentActionsMenu = event.target.closest('.moments-actions-menu'); // 朋友圈操作菜单

        // 如果点击不在评论输入区域内，也不在朋友圈操作菜单内
        if (!commentInputArea.contains(event.target) && !momentActionsMenu) {
            // 确保点击的不是评论按钮本身（即触发 showCommentInput 的按钮）
            const isCommentButton = event.target.closest('.moments-action') && event.target.closest('.moments-action').textContent.includes('评论');
            if (!isCommentButton) {
                hideCommentInput();
            }
        }
    };
    // 添加监听器，延迟一小段时间，避免在显示输入框的同一点击事件中立即关闭
    setTimeout(() => {
        document.addEventListener('click', clickOutsideCommentInputHandler);
    }, 100); 
    // --------------------------------------------------

    // 增加调试日志，确认 showCommentInput 设置的全局变量
    console.log(`[showCommentInput] currentCommentingMomentId: ${currentCommentingMomentId}, currentReplyToCommentId: ${currentReplyToCommentId}, currentReplyToAuthorId: ${currentReplyToAuthorId}`);
}

        async function postComment() {
    console.log("postComment 函数开始执行...");

    if (!currentCommentingMomentId) {
        console.error("currentCommentingMomentId 未设置，无法发布评论。");
        showAlert("发布评论失败：未选择评论目标。");
        return;
    }
    const moment = moments.find(m => m.id === currentCommentingMomentId);
    if (!moment) {
        console.error("未找到对应朋友圈，无法发布评论。");
        showAlert("发布评论失败：朋友圈不存在。");
        return;
    }
    const input = document.getElementById('momentCommentInput');
    const content = input.value.trim();

    if (!content) {
        console.log("评论内容为空，不发布。");
        return;
    }

    try {
        console.log("正在构建新评论对象...");
        const newComment = {
            id: generateUniqueId(),
            authorId: userProfile.id,
            content,
            timestamp: new Date().toISOString(),
            replyToCommentId: currentReplyToCommentId, // 用户回复的评论ID
            replyToAuthorId: currentReplyToAuthorId    // 用户回复的评论作者ID
        };
        console.log("用户新评论对象:", newComment);

        moment.comments.push(newComment);
        console.log("评论已添加到数据，尝试保存数据...");
        await saveData();
        console.log("数据保存成功，尝试更新朋友圈列表...");
        updateMomentsList();
        console.log("朋友圈列表更新成功。");

        input.value = '';
        hideCommentInput(); // 清空输入框，隐藏评论区域，并重置回复状态变量
        console.log("输入框清空，评论输入区域隐藏，回复目标已重置。");

        // 从 newComment 中获取你回复的AI好友ID，因为 hideCommentInput 会重置全局变量
        const targetAiFriendId = newComment.replyToAuthorId; 
        
        // 确保AI是存在的AI好友且不是用户自己
        if (targetAiFriendId && targetAiFriendId !== userProfile.id) {
            const repliedToAiFriend = friends.find(f => f.id === targetAiFriendId);
            if (repliedToAiFriend) {
                console.log(`检测到用户回复了AI好友 ${repliedToAiFriend.name} 的评论，尝试触发AI回复...`);
                // !!! 关键：将 AI 好友的 ID 作为第四个参数传递给 triggerAiCommentReply !!!
                triggerAiCommentReply(moment.id, newComment.id, newComment.content, repliedToAiFriend.id);
                console.log("AI回复触发完成。");
            } else {
                console.log("用户回复的目标（ID存在但在friends数组中未找到）不是AI好友，不触发AI回复。");
            }
        } else {
            console.log("用户回复的是自己，或者没有明确的回复目标，不触发AI回复。");
        }

    } catch (error) {
        console.error("发布评论时捕获到错误:", error);
        showAlert(`发布评论失败：${error.message || '未知错误'}`);
    } finally {
        console.log("postComment 函数执行结束。");
    }
}
       

// --- ↓↓↓ 请从这里开始完整复制，替换掉整个旧函数 ↓↓↓ ---
async function triggerAiCommentReply(momentId, userCommentId, userCommentContent, aiToReplyId) {
    const moment = moments.find(m => m.id === momentId);
    const aiFriend = getAuthorById(aiToReplyId); 
    if (!moment || !aiFriend) {
        console.error("无法找到朋友圈或AI好友信息，无法触发AI回复。");
        return;
    }

    const settings = await dbManager.get('apiSettings', 'settings') || {};
    if (!settings.apiUrl || !settings.apiKey || !settings.modelName) {
        console.error("API设置未完成，无法触发AI朋友圈互动。");
        return;
    }

    // 为每个AI设置一个随机的延迟，模拟真实世界中不同人看到朋友圈的时间差
    setTimeout(async () => {
        let commentContent = '';
        try {
            const sanitizedMomentContent = sanitizeForJSON(moment.content);
            const sanitizedUserComment = sanitizeForJSON(userCommentContent);
            const chatHistorySummary = (chatHistories[aiFriend.id] || []).slice(-20).map(m => {
                const senderName = m.type === 'sent' ? userProfile.name : aiFriend.name;
                return `${senderName}: ${m.content.substring(0, 50)}`;
            }).join('\n');
            
            // 收集评论区历史记录 (你指出的那段重要代码)
            let commentsHistoryForAI = [];
            const sortedComments = [...moment.comments].sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
            sortedComments.forEach(c => {
                const cAuthor = getAuthorById(c.authorId);
                const cTargetAuthor = c.replyToAuthorId ? getAuthorById(c.replyToAuthorId) : null;
                let commentLine = (c.replyToCommentId && cTargetAuthor) ? `${cAuthor.name}回复了${cTargetAuthor.name}说：“${c.content}”` : `${cAuthor.name}说：“${c.content}”`;
                if (c.id !== userCommentId) { 
                    commentsHistoryForAI.push(commentLine);
                }
            });
            const commentsContext = commentsHistoryForAI.length > 0 ? `【参考信息3：当前评论区的对话历史】:\n${commentsHistoryForAI.join('\n')}\n` : '';

            // 动态判断朋友圈的归属
            let scenarioDescription = '';
            let momentAuthor = getAuthorById(moment.authorId);

            if (moment.authorId === userProfile.id) {
                scenarioDescription = `【当前情景】: 你的好友 "${userProfile.name}" 发布了一条朋友圈。现在，你正在这条朋友圈的评论区，准备回复他/她刚刚发表的评论。`;
            } else {
                scenarioDescription = `【当前情景】: 这是你自己的朋友圈。你的好友 "${userProfile.name}" 刚刚在下面发表了评论，你正在回复他/她。`;
            }

            // 构造最终的、完整的AI指令
            const prompt = `
            【你的身份】: 你是 "${aiFriend.name}"，你的性格是：“${aiFriend.role}”。
            
            ${scenarioDescription}

            【参考信息1：朋友圈内容】:
            - 作者: "${momentAuthor.name}"
            - 内容: "${sanitizedMomentContent}"

            【参考信息2：你们最近的聊天记录】:
            ${chatHistorySummary || "你们最近没有聊天。"}
            
            ${commentsContext}
            
            【当前需要你回复的最新评论】:
            - "${userProfile.name}" 刚刚评论说: "${sanitizedUserComment}"

            【你的任务】:
            严格根据你的人设、聊天记录、评论历史以及朋友圈内容，写一句简短、口语化、生活化的评论来回复 "${userProfile.name}"。
            
            【【【输出铁律】】】
            你的回复**必须且只能**是纯文本的评论本身。绝对不要包含任何多余的解释、引号或JSON标记。`;
            
            const apiMessages = [{ role: 'system', content: "你是一个朋友圈评论助手。" }, { role: 'user', content: prompt }];
            if (moment.imageUrl && moment.imageUrl.startsWith('data:image')) {
                 apiMessages[1] = { 
                    role: 'user',
                    content: [
                        { type: 'text', text: prompt },
                        { type: 'image_url', image_url: { url: moment.imageUrl } }
                    ]
                };
            }
            
            const response = await fetch(`${settings.apiUrl}/chat/completions`, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${settings.apiKey}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: settings.modelName,
                    messages: apiMessages,
                    temperature: 0.9
                })
            });

            if (!response.ok) {
                throw new Error(`API 请求失败，状态码: ${response.status}.`);
            }
            
            const data = await response.json();
            const extractedText = data.choices[0].message.content;
            commentContent = (extractedText || '嗯嗯').trim();

        } catch (error) {
            console.error(`AI "${aiFriend.name}" 评论时出错:`, error);
            commentContent = `AI自动评论时发生错误。`;
        }
        
        const targetMoment = moments.find(m => m.id === moment.id);
        if (targetMoment) {
            if (!targetMoment.likes.includes(aiFriend.id)) {
                targetMoment.likes.push(aiFriend.id);
            }
            
            const newAiComment = {
                id: generateUniqueId(), 
                authorId: aiFriend.id,
                content: commentContent,
                timestamp: new Date().toISOString(),
                replyToCommentId: userCommentId, 
                replyToAuthorId: userProfile.id 
            };
            
            const existingAiReplyIndex = targetMoment.comments.findIndex(c => c.authorId === aiFriend.id && c.replyToCommentId === userCommentId);
            if (existingAiReplyIndex > -1) {
                targetMoment.comments[existingAiReplyIndex] = newAiComment;
            } else {
                targetMoment.comments.push(newAiComment);
            }
            
            await saveData();
            
            if (document.getElementById('momentsScreen').classList.contains('active')) {
                updateMomentsList();
            }
        }
    }, 2000 + Math.random() * 4000);
}
// --- ↑↑↑ 请在这里结束完整复制 ---

                                /**
         * 【【【这是终极修正版，确保日期绝对正确并基于聊天记录】】】
         * @param {string} friendId - 要为哪个好友生成日记
         * @param {boolean} isManualTrigger - 是否是用户手动点击触发的
         */
        async function generateDiaryForFriend(friendId, isManualTrigger = false) {
            const friend = friends.find(f => f.id === friendId);
            if (!friend) return false;

            const settings = await dbManager.get('apiSettings', 'settings') || {};
            if (!settings.apiUrl || !settings.apiKey) {
                showAlert('无法生成日记：API未配置。');
                return false;
            }

            // 【【【核心修复 1：无论成功失败，最后都必须清空欲望值！】】】
            // 我们使用 try...catch...finally 结构来确保这一点。
            try {
                // *** 核心修复 2：我们只截取最近积累欲望值相关的聊天记录 ***
                // 1轮对话大约是2条消息，为了保险起见，我们乘以2.5作为截取数量
                const messagesToSummarizeCount = Math.ceil(friend.diaryWritingUrge / ( (Math.random() * 10) + 5) * 2.5);
                const todayChats = (chatHistories[friend.id] || [])
                    .slice(-messagesToSummarizeCount) // 只截取最后一部分
                    .map(m => `${m.type === 'sent' ? userProfile.name : friend.name}: ${m.content}`)
                    .join('\n');
                
                const currentDate = new Date();
                const formattedDate = `${currentDate.getFullYear()}年${currentDate.getMonth() + 1}月${currentDate.getDate()}日`;

                // *** 核心修复 3：全新的AI指令，更精确、更智能 ***
                const prompt = `你叫"${friend.name}"，人设是：${friend.role}。
你的重要朋友是"${userProfile.name}"，他/她的人设是：${userProfile.personality || '普通人'}。
今天的日期是：${formattedDate}。

【你的任务】:
严格根据你和"${userProfile.name}"**刚刚发生的、下面提供的这段对话**，以你的身份完成三件事：
1.  推断今天的天气（晴、阴、雨等），必须和聊天内容或你的心情相符。
2.  写一篇详细的、富有感情的日记正文，**必须且只能**围绕这段对话展开。
3.  为这篇日记写一句“心里话”，作为点睛之笔。

【你需要总结的对话记录】:
${todayChats || '我们刚刚很安静，没有聊天。'}

【【【内容要求(必须严格遵守)】】】
1.  日记正文必须详细，字数至少350字以上，并且必须使用多个换行符 (\\n) 来分段。
2.  你的所有思考和文字都必须围绕**上面提供的对话记录**展开，不要提及更早之前的事情。

【输出格式铁律】:
你的回复必须是一个纯净的JSON对象，包含三个键：
1. "weather": 值为你推断的单个天气词语（例如 "晴"）。
2. "diary_body": 值为不包含日期的、纯粹的日记正文（字符串）。
3. "heartfelt_thought": 值为那句“心里话”（字符串）。

【JSON格式示例】:
{
  "weather": "阴",
  "diary_body": "今天和TA聊了很多，感觉很开心...\\n\\n但是，也有一点点小小的烦恼。...",
  "heartfelt_thought": "其实，我今天真的很想告诉TA..."
}

现在，请生成你的日记。`;
                        
                const response = await fetch(`${settings.apiUrl}/chat/completions`, { method: 'POST', headers: { 'Authorization': `Bearer ${settings.apiKey}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ model: settings.modelName, messages: [{ role: 'user', content: prompt }], response_format: { type: 'json_object' } }) });
                
                // 如果API返回了错误（比如4xx, 5xx），就主动抛出一个错误，让catch块去处理
                if (!response.ok) throw new Error(`API 请求失败: ${response.status}`);
                
                const data = await response.json();
                const responseText = data.choices?.[0]?.message?.content;
                
                if (!responseText || typeof responseText !== 'string') {
                    throw new Error("AI返回的内容为空或格式不正确，无法生成日记。");
                }

                const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                
                if (jsonMatch) {
                    const diaryData = JSON.parse(jsonMatch[0]);
                    if(diaryData.diary_body && diaryData.heartfelt_thought && diaryData.weather){
                        
                        const finalDiaryContent = `${formattedDate} ${diaryData.weather}\n\n${diaryData.diary_body}`;

                        const newDiary = { 
                            id: generateUniqueId(), 
                            authorId: friend.id, 
                            author: friend.name, 
                            avatar: friend.avatar, 
                            avatarImage: friend.avatarImage, 
                            content: finalDiaryContent,
                            heartfeltThought: diaryData.heartfelt_thought, 
                            date: new Date().toLocaleDateString('en-CA'),
                            timestamp: new Date().toISOString()
                        };
                        const newId = await dbManager.set('diaries', newDiary);
                        newDiary.id = newId;
                        diaries.unshift(newDiary);
                        
                        await saveData(); // 保存新日记
                        return true; // 返回成功状态
                    }
                }
                // 如果JSON解析失败或缺少关键字段，也抛出错误
                throw new Error("AI返回的日记格式不正确。");

            } catch (error) {
                // 当上面的try块中任何一步出错，都会跳到这里
                console.error("生成日记时出错:", error);
                // 只在手动触发时才弹窗报错，自动触发时静默失败，避免打扰
                if (isManualTrigger) {
                    showAlert(`生成日记失败: ${error.message}`);
                }
                return false; // 返回失败状态
            } finally {
                // 【【【最重要的修复！！！】】】
                // 无论上面是成功(try)还是失败(catch)，这里的代码都一定会被执行！
                console.log(`[日记系统] ${friend.name} 的一次日记生成流程结束，欲望值已清零。`);
                friend.diaryWritingUrge = 0; // 强制清零角色的“写作欲望”，打破无限重试的循环
                await saveData(); // 保存清零后的欲望值
            }
        }

        
                                        async function simulateAiBehavior() {
            const settings = await dbManager.get('apiSettings', 'settings') || {};
            if (!settings.apiUrl || !settings.apiKey || !settings.modelName || friends.filter(f => !f.isGroup).length === 0) return;
        
            for (const friend of friends.filter(f => !f.isGroup)) {
                try {
                    // --- 日记部分的逻辑保持不变 ---
                    if (friend.diaryWritingUrge >= 400) { 
                        const success = await generateDiaryForFriend(friend.id, false); 
                        if (success && document.getElementById('diaryScreen').classList.contains('active')) {
                           showFriendDiary(friend.id); 
                        }
                    }
        
                    // --- 【【【核心修改：全新的朋友圈触发逻辑】】】 ---
                    const now = new Date();

                    // 规则1：检查互动冷却。如果超过3天（72小时）没互动，就直接跳过这个AI。
                    if (!friend.lastMessageTimestamp || (now - new Date(friend.lastMessageTimestamp)) / (1000 * 60 * 60) > 72) {
                        continue; // 跳过，处理下一个好友
                    }

                    // 规则2：检查发言冷却。如果24小时内已经发过朋友圈，也直接跳过。
                    if (friend.lastMomentTimestamp && (now - new Date(friend.lastMomentTimestamp)) / (1000 * 60 * 60) < 24) {
                        continue; // 跳过，处理下一个好友
                    }

                    // 如果通过了以上所有筛选，再进行最终的随机判定
                    if (Math.random() < 0.03) { // 我们把基础概率也稍微降低了一点
                        
                        // --- (下面的代码是原来就有的，保持不变) ---
                        const recentFriendMoments = moments.filter(m => m.authorId === friend.id).slice(0, 3).map(m => `- "${m.content.substring(0, 50)}..."`).join('\n');
                        const chatHistorySummary = (chatHistories[friend.id] || []).slice(-10).map(m => `[${formatTimestampForAI(m.timestamp)}] ${m.type === 'sent' ? userProfile.name : friend.name}: ${m.content.substring(0, 20)}...`).join('\n');
                        let timeContext = '';
                        if(aiTimePerceptionEnabled){
                            const beijingTime = new Date().toLocaleString("zh-CN", { timeZone: "Asia/Shanghai", hour12: false, hour: '2-digit', minute: '2-digit' });
                            const hour = new Date().toLocaleTimeString("zh-CN", { timeZone: "Asia/Shanghai", hour: 'numeric', hour12: false });
                            let timeOfDayGreeting = '';
                            if (hour >= 5 && hour < 11) timeOfDayGreeting = "现在是早上。";
                            else if (hour >= 11 && hour < 14) timeOfDayGreeting = "现在是中午。";
                            else if (hour >= 14 && hour < 18) timeOfDayGreeting = "现在是下午。";
                            else if (hour >= 18 && hour < 23) timeOfDayGreeting = "现在是晚上。";
                            else timeOfDayGreeting = "现在是深夜了。";
                            timeContext = `
        【时间感知模块：这是最高优先级的指令】
        1.  **当前北京时间是 ${beijingTime}。${timeOfDayGreeting}**
        2.  **铁律：你构思的朋友圈内容，无论是文字还是图片描述，都必须与这个时间段的情景完全匹配。**
        `;
                        }
                        const prompt = `你叫"${friend.name}"，人设是"${friend.role}"。
        你最重要的人是"${userProfile.name}"，他/她的人设是：${userProfile.personality || '普通人'}。
        
        请你根据自己的人设，并参考以下信息，构思一条朋友圈动态。
        
        ${timeContext}
        
        【参考信息1：你最近和重要朋友的聊天摘要】
        ${chatHistorySummary || '无'}
        
        【参考信息2：你自己最近发过的朋友圈】
        ${recentFriendMoments || '你最近没有发过朋友圈。'}
        
        【【【核心铁律 (必须严格遵守)】】】
        1.  **【严禁虚构与用户相关的事件】**: 你的朋友圈内容，**必须**是针对最近聊天记录中**真实发生**的对话或事件的**直接感想、延伸或回应**。例如，如果用户说了让你感动的话，你可以发朋友圈感慨；如果用户说了要离开，你可以发朋友圈表达不舍。
        2.  **【允许虚构自己的事】**: 你**可以**发布关于自己生活的、与用户无关的虚构内容（但要符合你的人设），但**绝对不能**虚构任何与用户有关的情节。
        3.  **【大幅降低图片发送概率】**: 绝大多数情况下（90%的几率），你应该只发纯文字朋友圈。只有在聊天内容强烈暗示了某个视觉场景时（比如聊到了美丽的风景、可爱的宠物等），你才可以考虑发图文动态。
        
        【【【记忆与时间观念铁律 (必须严格遵守)】】】
        1.  **【核心原则】**: 你的朋友圈内容，必须是针对最近聊天记录中**真实发生**的对话或事件的**直接感想、延伸或回应**。
        2.  **【时间感知】**: 你必须仔细查看聊天记录前的**时间戳**，例如 \`[2025-09-08 14:30]\`。你的朋友圈必须是对**近期（今天或昨天）**发生的、让你有强烈感触的事件的回应。
        3.  **【严禁穿越】**: **绝对不能**把几天前的事情当作刚刚发生一样来发朋友圈。如果事情已经过去了一两天，你的口吻应该是**回顾和感慨**（例如“回想起昨天...”、“忽然想到前天...”），而不是即时反应。
        4.  **【严禁虚构与用户相关的事件】**: 你可以发布关于自己生活的、与用户无关的虚构内容，但**绝对不能**虚构任何与用户有关的情节。
        5.  **【大幅降低图片发送概率】**: 绝大多数情况下（90%的几率），你应该只发纯文字朋友圈。
        
        
        【信息隔离铁律】
        你**绝对看不到**你最重要的人“${userProfile.name}”的好友列表里的其他AI角色在朋友圈的任何活动。在你的朋友圈内容中，**严禁提及**任何你本不应该知道的其他AI角色的互动。
        
        【输出格式】
        你的回复**必须**是JSON格式。大多数时候，你应该使用第一个纯文字格式：
        1.  纯文字: {"type": "text", "content": "朋友圈文字内容..."}
        2.  图文 (仅在少数情况下使用): {"type": "image", "content": "朋友圈文字内容...", "image_description": "一段详细的图片描述..."}`;
                        const response = await fetch(`${settings.apiUrl}/chat/completions`, { method: 'POST', headers: { 'Authorization': `Bearer ${settings.apiKey}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ model: settings.modelName, messages: [{ role: 'user', content: prompt }], response_format: { type: 'json_object' } }) });
                        if(response.ok) {
                            const data = await response.json();
                            try {
                                const momentData = JSON.parse(data.choices?.[0]?.message?.content);
                                if(momentData && momentData.content) {
                                    const imageUrl = momentData.type === 'image' && momentData.image_description ? `https://placehold.co/400x400/f0f0f0/ccc?text=${encodeURIComponent(momentData.content.substring(0,10))}` : '';
                                    const newMoment = { id: generateUniqueId(), authorId: friend.id, content: momentData.content, imageUrl: imageUrl, imageDescription: momentData.image_description || '', timestamp: new Date().toISOString(), likes: [], comments: [] };
                                    const newId = await dbManager.set('moments', newMoment);
                                    newMoment.id = newId;
                                    moments.unshift(newMoment);

                                    // 【【【新增代码：记录本次发圈时间】】】
                                    // 成功发布后，立刻记录下当前时间！
                                    friend.lastMomentTimestamp = newMoment.timestamp;
                                    await saveData(); // 保存这个新记录

                                    if (document.getElementById('momentsScreen').classList.contains('active')) {
                                        updateMomentsList();
                                    }
                                }
                            } catch(e) {
                                console.error("AI生成朋友圈时返回了无效的JSON:", data.choices?.[0]?.message?.content);
                            }
                        }
                    }
                } catch (error) { console.error("AI Behavior simulation failed:", error); }
            }
        }
        
        // --- ↓↓↓ 请从这里开始复制，完整替换旧的 triggerAiMomentReactions 函数 ↓↓↓ ---
async function triggerAiMomentReactions(moment) {
    const settings = await dbManager.get('apiSettings', 'settings') || {};
    if (!settings.apiUrl || !settings.apiKey || !settings.modelName) {
        console.error("API设置未完成，无法触发AI朋友圈互动。");
        return;
    }

    // 遍历所有非群聊的AI好友
    for (const friend of friends.filter(f => !f.isGroup)) {
        // 为每个AI设置一个随机的延迟，模拟真实世界中不同人看到朋友圈的时间差
        const reactionDelay = 2000 + Math.random() * 4000; // 延迟2到6秒

        setTimeout(async () => {
            let commentContent = '';

            try {
                const sanitizedMomentContent = sanitizeForJSON(moment.content);
                const chatHistorySummary = (chatHistories[friend.id] || []).slice(-20).map(m => {
                    const senderName = m.type === 'sent' ? userProfile.name : friend.name;
                    return `${senderName}: ${m.content.substring(0, 50)}`;
                }).join('\n');

                // --- 核心改造开始：构建更智能的AI指令 ---
                
                // 1. 先定义通用的指令部分
                const basePrompt = `
                【你的身份】: 你是 "${friend.name}"，你的性格是：“${friend.role}”。
                【当前情景】: 你的好友 "${userProfile.name}" 刚刚发布了一条朋友圈。
                【参考信息：你们最近的聊天记录】:
                ${chatHistorySummary || "你们最近没有聊天。"}

                【你的任务】:
                严格根据你的人设、你们的聊天记录，以及朋友圈的**文字和图片内容**，写一句简短、口语化、生活化的评论。
                
                【【【输出铁律】】】
                你的回复**必须且只能**是纯文本的评论本身。绝对不要包含任何多余的解释、引号或JSON标记。`;

                // 2. 准备API请求的消息体
                let userMessageContent;

                // 3. 【关键逻辑判断】根据朋友圈是否有图片，构建不同的消息内容
                if (moment.imageUrl && moment.imageUrl.startsWith('data:image')) {
                    // --- 情况A：图文朋友圈 ---
                    // 我们创建一个包含文本和图片的复合消息体
                    userMessageContent = [
                        { 
                            type: 'text', 
                            text: `这是朋友圈的文字内容：\n“${sanitizedMomentContent}”\n\n请仔细观察下面的图片，并结合文字内容给出你的评论。` 
                        },
                        { 
                            type: 'image_url', 
                            image_url: { url: moment.imageUrl } 
                        }
                    ];
                } else {
                    // --- 情况B：纯文字朋友圈 ---
                    // 我们只发送文字内容
                    userMessageContent = `这是朋友圈的文字内容：\n“${sanitizedMomentContent}”\n\n请对此发表你的评论。`;
                }

                // 4. 组装最终发送给API的完整消息
                const apiMessages = [
                    { role: 'system', content: basePrompt },
                    { role: 'user', content: userMessageContent }
                ];
                
                // --- 核心改造结束 ---

                const response = await fetch(`${settings.apiUrl}/chat/completions`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${settings.apiKey}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: settings.modelName,
                        messages: apiMessages, // 使用我们新构建的消息体
                        temperature: 0.9
                    })
                });

                if (!response.ok) {
                    throw new Error(`API 请求失败，状态码: ${response.status}.`);
                }
                
                const data = await response.json();
                const extractedText = data.choices[0].message.content;
                commentContent = (extractedText || '不错！').trim();

            } catch (error) {
                console.error(`AI "${friend.name}" 评论时出错:`, error);
                commentContent = `AI自动评论时发生错误。`; // 保留错误提示，便于调试
            }
            
            // --- 更新数据和UI的逻辑保持不变 ---
            const targetMoment = moments.find(m => m.id === moment.id);
            if (targetMoment) {
                // AI在评论的同时，也会点赞
                if (!targetMoment.likes.includes(friend.id)) {
                    targetMoment.likes.push(friend.id);
                }
                
                // 创建新的评论对象
                const newAiComment = {
                    id: generateUniqueId(), 
                    authorId: friend.id,
                    content: commentContent,
                    timestamp: new Date().toISOString(),
                    replyToCommentId: null, 
                    replyToAuthorId: null
                };
                
                // 检查AI是否已经评论过，避免重复
                const existingAiCommentIndex = targetMoment.comments.findIndex(c => c.authorId === friend.id && !c.replyToCommentId);
                if (existingAiCommentIndex > -1) {
                    targetMoment.comments[existingAiCommentIndex] = newAiComment;
                } else {
                    targetMoment.comments.push(newAiComment);
                }
                
                await saveData();
                
                // 如果用户还停留在朋友圈页面，就刷新列表
                if (document.getElementById('momentsScreen').classList.contains('active')) {
                    updateMomentsList();
                }
            }
        }, reactionDelay);
    }
}
// --- ↑↑↑ 请在这里结束复制 ---
        function backToSettingsMenu() { setActivePage('settingsApp'); }
        function openApiSettings() { setActivePage('apiSettingsScreen'); loadApiSettings(); }
        function toggleModelDropdown() { document.getElementById('modelDropdown').classList.toggle('show'); }
        function selectModel(modelName) { document.getElementById('modelName').value = modelName; toggleModelDropdown(); }

        // 【【【第三步：请用这个修改后的完整函数，替换你原来的 fetchModels 函数】】】
async function fetchModels() {
    const apiUrl = document.getElementById('apiUrl').value;
    const apiKey = document.getElementById('apiKey').value;
    if (!apiUrl || !apiKey) return showAlert('请先填写API地址和密钥');
    
    // 获取加载动画的容器
    const overlay = document.getElementById('loadingOverlay');
    
    // ---- 核心修改：在这里开始“挂牌” ----
    // 1. 设置加载动画和文字
    overlay.innerHTML = `
        <div class="loading-spinner"></div>
        <p>正在拉取模型...</p>
    `;
    // 2. 显示加载动画
    overlay.style.display = 'flex';

    try {
        const response = await fetch(`${apiUrl}/models`, { headers: { 'Authorization': `Bearer ${apiKey}` } });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        
        const dropdown = document.getElementById('modelDropdown');
        dropdown.innerHTML = '';
        (data.data || []).forEach(model => {
            const option = document.createElement('div');
            option.className = 'model-option';
            option.textContent = model.id;
            option.onclick = () => selectModel(model.id);
            dropdown.appendChild(option);
        });
        showAlert(`成功拉取到 ${data.data.length} 个模型`);

    } catch (error) {
        showAlert(`拉取模型失败: ${error.message}`);
    } finally {
        // ---- 核心修改：在这里“摘牌” ----
        // 无论成功还是失败 (finally)，最后都隐藏加载动画
        overlay.style.display = 'none';
    }
}

        async function toggleTimePerception() {
            aiTimePerceptionEnabled = document.getElementById('aiTimePerceptionToggle').checked;
            await saveApiSettings();
        }

        async function saveApiSettings() {
            const settings = { 
                id: 'settings',
                apiUrl: document.getElementById('apiUrl').value, 
                apiKey: document.getElementById('apiKey').value, 
                modelName: document.getElementById('modelName').value,
                memoryTurns: document.getElementById('memoryTurns').value || 10,
                apiTemperature: document.getElementById('apiTemperature').value || 0.9,
                aiTimePerceptionEnabled: document.getElementById('aiTimePerceptionToggle').checked
            };
            aiTimePerceptionEnabled = settings.aiTimePerceptionEnabled;
            if (!settings.apiUrl || !settings.apiKey || !settings.modelName) return showAlert('请填写完整的设置信息');
            await dbManager.set('apiSettings', settings);
            showAlert('API设置已保存');
        }

        // --- [REFACTORED] Data Import/Export Logic ---
        async function exportData() {
            try {
                // 并行从所有表中读取数据
                const [
                    loadedFriends, loadedChatHistories, loadedDiaries, loadedWorldBooks, 
                    loadedWorldBookFolders, loadedFavorites, loadedMoments, loadedPlaylist, 
                    loadedAppSettings, loadedApiSettings, loadedCustomEmojis, loadedMemories
                ] = await Promise.all([
                    dbManager.getAll('friends'), dbManager.getAll('chatHistories'), dbManager.getAll('diaries'),
                    dbManager.getAll('worldBooks'), dbManager.getAll('worldBookFolders'), dbManager.getAll('favorites'),
                    dbManager.getAll('moments'), dbManager.getAll('playlist'), dbManager.get('appSettings', 'settings'),
                    dbManager.get('apiSettings', 'settings'), dbManager.getAll('customEmojis'),
                    dbManager.getAll('memories')
                ]);
                
                // 将聊天记录数组转换回对象格式
                const chatHistoriesObject = {};
                (loadedChatHistories || []).forEach(record => {
                    chatHistoriesObject[record.friendId] = record.messages;
                });

                // 组合成与旧版兼容的单一对象
                const fullExport = {
                    wechatData: {
                        friends: loadedFriends,
                        chatHistories: chatHistoriesObject,
                        diaries: loadedDiaries,
                        worldBooks: loadedWorldBooks,
                        worldBookFolders: loadedWorldBookFolders,
                        favorites: loadedFavorites,
                        moments: loadedMoments,
                        playlist: loadedPlaylist,
                        customEmojis: loadedCustomEmojis,
                        memories: loadedMemories, // <-- 新增
                        ...loadedAppSettings // 合并所有应用设置
                    },
                    apiSettings: loadedApiSettings
                };

                const blob = new Blob([JSON.stringify(fullExport, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `jrsy-data-${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showAlert('数据导出成功！');
            } catch (e) {
                console.error("Export failed:", e);
                showAlert(`数据导出失败: ${e.message}`);
            }
        }

        function importData() {
            showConfirm("导入数据将覆盖当前所有设置和聊天记录，确定要继续吗？", (confirmed) => {
                if (!confirmed) return;
                const input = document.createElement('input');
                input.type = 'file'; input.accept = '.json,application/json'; input.style.display = 'none';
                input.onchange = (event) => {
                    const file = event.target.files[0];
                    if (!file) return document.body.removeChild(input);
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const content = e.target.result;
                            const importedData = JSON.parse(content);
                            if (!importedData.wechatData || !importedData.apiSettings) {
                                throw new Error('文件格式不正确，缺少 wechatData 或 apiSettings 键。');
                            }

                            // 清空所有现有数据
                            await Promise.all(dbManager.stores.map(store => dbManager.clear(store)));
                            
                            const data = importedData.wechatData;

                            // 逐个表写入新数据
                            const writePromises = [];
                            (data.friends || []).forEach(item => writePromises.push(dbManager.set('friends', item)));
                            Object.entries(data.chatHistories || {}).forEach(([friendId, messages]) => {
                                writePromises.push(dbManager.set('chatHistories', { friendId, messages }));
                            });
                            (data.diaries || []).forEach(item => writePromises.push(dbManager.set('diaries', item)));
                            (data.worldBooks || []).forEach(item => writePromises.push(dbManager.set('worldBooks', item)));
                            (data.worldBookFolders || []).forEach(item => writePromises.push(dbManager.set('worldBookFolders', item)));
                            (data.favorites || []).forEach(item => writePromises.push(dbManager.set('favorites', item)));
                            (data.moments || []).forEach(item => writePromises.push(dbManager.set('moments', item)));
                            (data.playlist || []).forEach(item => writePromises.push(dbManager.set('playlist', item)));
                            (data.customEmojis || []).forEach(item => writePromises.push(dbManager.set('customEmojis', item)));
                            (data.memories || []).forEach(item => writePromises.push(dbManager.set('memories', item))); // <-- 新增

                            const appSettings = { ...data, id: 'settings' };
                            delete appSettings.friends; // 从设置对象中移除已独立存储的数据
                            delete appSettings.chatHistories;
                            // ... 对其他列表也执行 delete
                            writePromises.push(dbManager.set('appSettings', appSettings));
                            
                            const apiSettings = { ...importedData.apiSettings, id: 'settings' };
                            writePromises.push(dbManager.set('apiSettings', apiSettings));

                            await Promise.all(writePromises);
                            
                            showAlert('数据导入成功！页面即将刷新。');
                            setTimeout(() => window.location.reload(), 1500);

                        } catch (err) { showAlert(`数据导入失败: 文件格式错误。\n${err.message}`); }
                    };
                    reader.onerror = () => showAlert('读取文件失败！');
                    reader.readAsText(file);
                    document.body.removeChild(input);
                };
                document.body.appendChild(input);
                input.click();
            });
        }
        
        // --- Listen Together Functions ---
        
                        // --- ↓↓↓ 请从这里开始完整复制，替换旧的 inviteToListenTogether 函数 ↓↓↓ ---

        async function inviteToListenTogether(friendIdToInvite) {
            const friend = friends.find(f => f.id === friendIdToInvite);
            if (!friend) {
                showAlert("无法邀请好友。");
                return;
            }
           
            // 步骤A: 像以前一样，先把邀请卡片发出去，让您能立刻看到
            const inviteMsg = await saveChatMessage(friendIdToInvite, 'sent', '', '', null, 'listen_invite');
            addMessageToDOM(inviteMsg, friend);
            document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
            
            showAlert("已发送邀请，等待对方回应...");
            
            // --- 核心修改：为AI创建一个“特别任务指令” ---
            // 这个指令非常简单直接，告诉AI它现在唯一的任务就是回应这个邀请。
            const friendRole = friend.role || '一个友好的朋友';
            const userPersonality = userProfile.personality || '普通人';
            
            const customPrompt = `你叫"${friend.name}"，人设是: "${friendRole}"。用户("${userPersonality}")刚刚向你发起了"一起听歌"的邀请。这是当前最优先的事项，请直接对此邀请作出回应。
            
            【【【输出格式铁律】】】
如果决定接受邀请，你的回复JSON数组中，除了文本消息外，还必须包含一个 "accept_listen_together" 动作。

            【JSON格式示例 (接受邀请)】:
            [
              {"type": "text", "content": "好呀好呀！"},
              {"type": "text", "content": "最喜欢和你一起听歌了"},
              {"type": "accept_listen_together"}
            ]

            【JSON格式示例 (拒绝邀请)】:
            [
              {"type": "text", "content": "啊，我现在有点事走不开"},
              {"type": "text", "content": "下次吧好吗？ >_<"}
            ]
            
            现在，请生成你的回复。`;
            
            // 步骤B: 模拟一小段延迟后，让AI执行这个“特别任务”
            setTimeout(() => {
                receiveMessage(friendIdToInvite, customPrompt);
            }, 1500); // 延迟1.5秒，模拟AI看到邀请后的反应时间
        }

// --- ↑↑↑ 请在这里结束复制 ---

                async function acceptListenInvite(friendId) {
            const friend = friends.find(f => f.id === friendId);
            if (!friend) return;
            listenTogetherFriendId = friendId; 

            const friendAvatarDiv = document.getElementById('listenFriendAvatar');
            if(friend.avatarImage) {
                friendAvatarDiv.style.backgroundImage = `url(${friend.avatarImage})`;
                friendAvatarDiv.textContent = '';
            } else {
                friendAvatarDiv.style.backgroundImage = '';
                friendAvatarDiv.textContent = friend.name.substring(0,1) || '?';
            }
            friendAvatarDiv.onclick = null;

            updateListenUI();
            updateFloatingPlayer();
            
            const msgData = await saveChatMessage(friendId, 'received', '', '', null, 'listen_accept');
            if (currentChatFriendId === friendId) {
                addMessageToDOM(msgData, friend);
                document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
            }
        }
        function openListenTogether() {
            const friend = friends.find(f => f.id === currentChatFriendId);
            if (!friend || friend.isGroup) {
                showAlert("只能和单个好友一起听。");
                hideFunctionMenus();
                return;
            }
            isListenSessionActive = true;
            listenTogetherFriendId = null; 
            hideFunctionMenus();
            
            // ↓↓↓ 请用这个新的代码块，替换旧的用户头像设置逻辑 ↓↓↓

setActivePage('listenTogetherScreen');

// --- 核心修改在这里 ---
// 1. 同样，先找到当前聊天的好友，并找出为他设定的“我的人设”
const currentFriendForListen = friends.find(f => f.id === currentChatFriendId);
const activePersonaIdForListen = currentFriendForListen ? currentFriendForListen.activeUserPersonaId : 'default_user';
const activePersonaForListen = userPersonas.find(p => p.id === activePersonaIdForListen) || userProfile;

// 2. 用这个人设的信息来设置“一起听”界面里“我”的头像
const userAvatarDiv = document.getElementById('listenUserAvatar');
if (activePersonaForListen.avatarImage) {
    userAvatarDiv.style.backgroundImage = `url(${activePersonaForListen.avatarImage})`;
    userAvatarDiv.textContent = '';
} else {
    userAvatarDiv.style.backgroundImage = '';
    userAvatarDiv.textContent = activePersonaForListen.name.substring(0,1) || '我';
}
// --- 修改结束 ---

// ↑↑↑ 替换到这里结束 ↑↑↑

            const friendAvatarDiv = document.getElementById('listenFriendAvatar');
            friendAvatarDiv.style.backgroundImage = '';
            friendAvatarDiv.textContent = '+';
            friendAvatarDiv.onclick = () => inviteToListenTogether(currentChatFriendId);
             
            if(playlist.length > 0 && currentSongIndex === -1) {
                playSong(0);
            } else if (currentSongIndex > -1) {
                updateListenUI();
            } else {
                updateListenUI();
            }
            updateFloatingPlayer();
        }

        function backToChatFromListen() {
            setActivePage('chatScreen');
            showFloatingPlayer();
        }

        function returnToListenScreen() {
             hideFloatingPlayer();
             setActivePage('listenTogetherScreen');
        }

        function terminateListenTogether(event) {
            if(event) event.stopPropagation();
            isListenSessionActive = false;
            listenTogetherFriendId = null;
            hideFloatingPlayer();
            setActivePage('chatScreen');
            stopSong();
        }

        function showFloatingPlayer() {
            const player = document.getElementById('floatingPlayer');
            player.classList.add('show');
            updateFloatingPlayer();
        }
        function hideFloatingPlayer() {
            document.getElementById('floatingPlayer').classList.remove('show');
        }
        function updateFloatingPlayer() {
             if (!isListenSessionActive) {
                hideFloatingPlayer();
                return;
            }
            const song = playlist[currentSongIndex];
            document.getElementById('floatingPlayerTitle').textContent = song ? song.title : "暂无歌曲";
            const friendName = listenTogetherFriendId ? (friends.find(f => f.id === listenTogetherFriendId)?.name || '好友') : '...';
            document.getElementById('floatingPlayerSubtitle').textContent = `与 ${friendName} 一起听`;
            const cover = persistentVinylCover || (song ? song.cover : 'https://i.imgur.com/8s15m4g.png');
            document.getElementById('floatingPlayerArt').style.backgroundImage = `url(${cover})`;
        }

        
        function handleListenTogetherKeyPress(event) {
            if (event.key === 'Enter') {
                sendListenTogetherMessage();
            }
        }
        
        // --- 【这是修改后的代码】 ---
async function sendListenTogetherMessage() { // <--- 修复1：在这里加上 async
    const input = document.getElementById('listenTogetherChatInput');
    const message = input.value.trim();
    if(message) {
        // <--- 修复2：在这里加上 await
        const msgData = await saveChatMessage(currentChatFriendId, 'sent', message);
        addMessageToDOM(msgData, friends.find(f=>f.id===currentChatFriendId), 'listenTogetherChatOverlay');
        input.value = '';
    }
}
        
        function toggleListenChat() {
            document.getElementById('listenTogetherChatWrapper').classList.toggle('expanded');
        }

        function openPlaylistModal() {
            updatePlaylistModal();
            document.getElementById('playlistModal').classList.add('show');
            document.getElementById('playlistModal').onclick = (e) => {
                if(e.target.id === 'playlistModal') document.getElementById('playlistModal').classList.remove('show');
            };
        }
        
        function openAddMusicModal() { 
            tempSongFile = null;
            tempLrcFileContent = null;
            document.getElementById('songTitleInput').value = '';
            document.getElementById('songArtistInput').value = '';
            document.getElementById('songFileName').textContent = '未选择文件';
            document.getElementById('lrcFileName').textContent = '未选择文件';
            document.getElementById('addMusicModal').classList.add('show');
        }
        function closeAddMusicModal() { document.getElementById('addMusicModal').classList.remove('show'); }

        function handleSongFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            tempSongFile = file;
            document.getElementById('songFileName').textContent = file.name;
            const nameParts = file.name.replace(/\.[^/.]+$/, "").split(' - ');
            if (nameParts.length === 2) {
                 document.getElementById('songArtistInput').value = nameParts[0].trim();
                 document.getElementById('songTitleInput').value = nameParts[1].trim();
            } else {
                 document.getElementById('songTitleInput').value = nameParts[0].trim();
            }
        }

        function handleLrcFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                tempLrcFileContent = e.target.result;
                document.getElementById('lrcFileName').textContent = file.name;
                const titleMatch = tempLrcFileContent.match(/\[ti:(.*?)\]/);
                const artistMatch = tempLrcFileContent.match(/\[ar:(.*?)\]/);
                if (titleMatch && titleMatch[1]) document.getElementById('songTitleInput').value = titleMatch[1].trim();
                if (artistMatch && artistMatch[1]) document.getElementById('songArtistInput').value = artistMatch[1].trim();
            };
            reader.readAsText(file);
        }
        
        async function confirmAddSong() {
            const title = document.getElementById ('songTitleInput').value.trim();
            const artist = document.getElementById('songArtistInput').value.trim();
            
            if(!title || !artist || !tempSongFile) return showAlert('歌曲名、歌手和歌曲文件为必填项。');
            
            const newSong = { 
                id: generateUniqueId(), 
                title, 
                artist, 
                url: null, 
                cover: 'https://i.imgur.com/8s15m4g.png',
                lrc: tempLrcFileContent || '',
                file: tempSongFile 
            };
            
            playlist.push(newSong);
            await saveData();
            updatePlaylistModal();
            closeAddMusicModal();
            if(currentSongIndex === -1) playSong(playlist.length - 1);
        }

        function updatePlaylistModal() {
            const list = document.getElementById('playlistList');
            document.getElementById('playlistTitle').textContent = `播放列表 (${playlist.length})`;
            list.innerHTML = '';
            playlist.forEach((song, index) => {
                const item = document.createElement('div');
                item.className = 'playlist-item';
                if(index === currentSongIndex) item.classList.add('playing');
                item.innerHTML = `
                    <div class="playlist-item-info" onclick="playSong(${index})">
                        <div class="playlist-item-title">${song.title}</div>
                        <div class="playlist-item-artist">${song.artist}</div>
                    </div>
                    <button class="playlist-delete-btn" onclick="deleteFromPlaylist(event, '${song.id}')">&times;</div>
                `;
                list.appendChild(item);
            });
        }
        
        async function deleteFromPlaylist(event, songId) {
            event.stopPropagation();
            const index = playlist.findIndex(s => s.id === songId);
            if(index > -1) {
                const song = playlist[index];
                if (song.url && song.url.startsWith('blob:')) {
                    URL.revokeObjectURL(song.url);
                    delete songFileCache[song.id];
                }
                playlist.splice(index, 1);

                if (index === currentSongIndex) {
                    if (playlist.length > 0) playSong(index % playlist.length);
                    else stopSong();
                } else if (index < currentSongIndex) {
                    currentSongIndex--;
                }
                await saveData();
                updatePlaylistModal();
            }
        }
        
        function playSong(index) {
            if (index < 0 || index >= playlist.length) return;
            currentSongIndex = index;
            const song = playlist[currentSongIndex];
            
            let songUrl = songFileCache[song.id];
            if (!songUrl && song.file) {
                 songUrl = URL.createObjectURL(song.file);
                 songFileCache[song.id] = songUrl;
                 song.url = songUrl;
            }

            if (!songUrl) {
                console.error("Could not create Blob URL for song:", song.title);
                showAlert('无法播放歌曲，文件可能已损坏或丢失。');
                return;
            }

            audioElement.src = songUrl;
            audioElement.play().catch(e => console.error("音频播放失败:", e));
            updateListenUI();
            updatePlaylistModal();
            updateFloatingPlayer();
            document.getElementById('vinylRecord').classList.add('playing');
            document.getElementById('playPauseBtn').innerHTML = `<svg viewBox="0 0 24 24"><path d="M14 19h4V5h-4v14zm-10 0h4V5H4v14z"/></svg>`;
            parsedLyrics = parseLRC(song.lrc);
        }

        function stopSong() {
            audioElement.pause();
            currentSongIndex = -1;
            document.getElementById('vinylRecord').classList.remove('playing');
            document.getElementById('playPauseBtn').innerHTML = `<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>`;
            document.getElementById('listenSongTitle').textContent = '一起听';
            document.getElementById('listenSongArtist').textContent = '...';
            document.getElementById('albumArt').style.backgroundImage `url(${persistentVinylCover || 'https://i.imgur.com/8s15m4g.png'})`;
            updateFloatingPlayer();
        }

        function togglePlayPause() {
            if(audioElement.paused) {
                if(currentSongIndex === -1 && playlist.length > 0) playSong(0);
                else audioElement.play().catch(e => console.error("音频播放失败:", e));
            } else {
                audioElement.pause();
            }
        }
        
        function nextSong() { if (playlist.length > 0) playSong((currentSongIndex + 1) % playlist.length); }
        function prevSong() { if (playlist.length > 0) playSong((currentSongIndex - 1 + playlist.length) % playlist.length); }
        
        function toggleRepeat() {
             isRepeat = !isRepeat;
             document.getElementById('repeatBtn').style.color = isRepeat ? '#07c160' : '#fff';
        }

        function seekSong(value) { audioElement.currentTime = value; }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }
        
        function updateListenUI() {
            let title = '一起听', artist = '...', coverUrl = persistentVinylCover || 'https://i.imgur.com/8s15m4g.png';
            if (currentSongIndex > -1) {
                const song = playlist[currentSongIndex];
                title = song.title;
                artist = song.artist;
                coverUrl = persistentVinylCover || song.cover || 'https://i.imgur.com/8s15m4g.png';
            }
            document.getElementById('listenSongTitle').textContent = title;
            document.getElementById('listenSongArtist').textContent = artist;
            document.getElementById('albumArt').style.backgroundImage = `url(${coverUrl})`;
        }
        
        function handleListenBgUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    customListenBg = e.target.result;
                    applyListenTogetherCustomImages();
                    await saveData();
                };
                reader.readAsDataURL(file);
            }
        }
        
        async function handleVinylImageUpload(event) {
             const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const imageUrl = e.target.result;
                    persistentVinylCover = imageUrl;
                    updateListenUI();
                    updateFloatingPlayer();
                    await saveData();
                };
                reader.readAsDataURL(file);
            }
        }

        function applyListenTogetherCustomImages() {
            const bgDiv = document.getElementById('listenBg');
            if(customListenBg) bgDiv.style.backgroundImage = `url(${customListenBg})`;
        }
        
        // 这是修改后的新函数
function parseLRC(lrcText) {
    if (!lrcText || lrcText.trim() === '') return [];
    const lines = lrcText.split('\n');
    const result = [];
    const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;
    // 新增：用于匹配翻译的正则表达式
    const translationRegex = /[（(](?:翻译|译)[:：](.*)[)）]/;

    for (const line of lines) {
        let fullText = line.replace(timeRegex, '').trim();
        let originalText = fullText;
        let translationText = '';

        // 检查并提取翻译
        const translationMatch = fullText.match(translationRegex);
        if (translationMatch && translationMatch[1]) {
            originalText = fullText.replace(translationRegex, '').trim();
            translationText = translationMatch[1].trim();
        }

        let match;
        const timeMatches = [];
        const localTimeRegex = new RegExp(timeRegex.source, 'g');
        while ((match = localTimeRegex.exec(line)) !== null) {
            timeMatches.push(match);
        }

        if (originalText || translationText || timeMatches.length > 0) {
            for (const match of timeMatches) {
                const minutes = parseInt(match[1], 10);
                const seconds = parseInt(match[2], 10);
                const milliseconds = parseInt(match[3].length === 2 ? match[3] + '0' : match[3], 10);
                const time = minutes * 60 + seconds + milliseconds / 1000;
                // 返回一个包含原文和翻译的对象
                result.push({ time, text: originalText || '', translation: translationText });
            }
        }
    }
    return result.sort((a, b) => a.time - b.time);
}

        let lastLyricIndex = -1;
        // 这是修改后的新函数
function updateLyrics(currentTime) {
    if (parsedLyrics.length === 0) {
        const lyricsContainer = document.getElementById('songLyrics');
        lyricsContainer.children[0].innerHTML = '';
        lyricsContainer.children[1].innerHTML = '... 暂无歌词 ...';
        lyricsContainer.children[2].innerHTML = '';
        return;
    }

    let currentLineIndex = -1;
    for (let i = 0; i < parsedLyrics.length; i++) {
        if (currentTime >= parsedLyrics[i].time) {
            currentLineIndex = i;
        } else {
            break;
        }
    }

    if (currentLineIndex !== lastLyricIndex) {
        const lyricsContainer = document.getElementById('songLyrics');
        const lines = [lyricsContainer.children[0], lyricsContainer.children[1], lyricsContainer.children[2]];
        const indices = [currentLineIndex - 1, currentLineIndex, currentLineIndex + 1];

        lines.forEach((lineElement, i) => {
            const lyricData = parsedLyrics[indices[i]];
            if (lyricData) {
                let html = lyricData.text;
                if (lyricData.translation) {
                    // 如果有翻译，就换行并添加一个特殊的class
                    html += `<br><span class="lyric-translation">${lyricData.translation}</span>`;
                }
                lineElement.innerHTML = html;
            } else {
                lineElement.innerHTML = '';
            }
        });
        
        lastLyricIndex = currentLineIndex;
    }
}
        
        const floatingPlayer = document.getElementById('floatingPlayer');
        // ...其他全局变量...
let isDragging = false;
let offsetX, offsetY;
let currentActiveSimApp = null; // [新增] 追踪当前模拟手机打开的App
// ...其他全局变量...

        const startDrag = (e) => {
            isDragging = true;
            floatingPlayer.style.cursor = 'grabbing';
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            offsetX = clientX - floatingPlayer.offsetLeft;
            offsetY = clientY - floatingPlayer.offsetTop;
        };
        const endDrag = () => {
            isDragging = false;
            floatingPlayer. style.cursor = 'grab';
        };
        const drag = (e) => {
            if (!isDragging) return;
            e.preventDefault();
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            let newX = clientX - offsetX;
            let newY = clientY - offsetY;
            const screen = document.querySelector('.screen');
            const maxX = screen.offsetWidth - floatingPlayer.offsetWidth;
            const maxY = screen.offsetHeight - floatingPlayer.offsetHeight;
            newX = Math.max(0, Math.min(newX, maxX));
            newY = Math.max(0, Math.min(newY, maxY));
            floatingPlayer.style.left = `${newX}px`;
            floatingPlayer.style.top = `${newY}px`;
            floatingPlayer.style.bottom = 'auto';
            floatingPlayer.style.right = 'auto';
        };

        floatingPlayer.addEventListener('mousedown', startDrag);
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('mousemove', drag);
        floatingPlayer.addEventListener('touchstart', startDrag);
        document.addEventListener('touchend', endDrag);
        document.addEventListener('touchmove', drag, { passive: false });


        document.addEventListener('click', (event) => {
            const dropdown = document.getElementById('modelDropdown'), select = document.getElementById('modelName');
            if (dropdown && select && dropdown.classList.contains('show') && !select.contains(event.target) && !dropdown.contains(event.target)) {
                dropdown.classList.remove('show');
            }
        });
        
        // --- Transfer Functions ---
        function openTransferModal() {
            document.getElementById('transferModal').classList.add('show');
            hideFunctionMenus();
        }
        function closeTransferModal() {
            document.getElementById('transferModal').classList.remove('show');
            document.getElementById('transferAmountInput').value = '';
            document.getElementById('transferRemarkInput').value = '';
        }
                async function sendTransfer() {
            const amountInput = document.getElementById('transferAmountInput');
            const remarkInput = document.getElementById('transferRemarkInput');
            const amount = parseFloat(amountInput.value);
            const remark = remarkInput.value.trim();

            if (isNaN(amount) || amount <= 0) {
                showAlert('请输入有效的转账金额。');
                return;
            }
            if (userProfile.balance < amount) {
                showAlert('余额不足。');
                return;
            }

            userProfile.balance -= amount;
            
            const transferData = { amount, remark };
            const msg = await saveChatMessage(currentChatFriendId, 'sent', JSON.stringify(transferData), '', null, 'transfer_request'); // <--- 加上 await
            addMessageToDOM(msg, friends.find(f => f.id === currentChatFriendId));
            
            await saveData();
            updateWalletDisplay();
            closeTransferModal();
            document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
        }
        
        async function acceptTransfer(messageId) {
    const history = [...(chatHistories[currentChatFriendId] || [])];
    const msgIndex = history.findIndex(m => m.id === messageId);
    if (msgIndex === -1) return;

    const msg = history[msgIndex];
    if (!msg || msg.transfer_status !== 'pending' || msg.type !== 'received') return;

    const transferData = JSON.parse(msg.content);

    // 步骤1：更新旧卡片数据
    const updatedMsg = { ...msg, transfer_status: 'received' };
    chatHistories[currentChatFriendId][msgIndex] = updatedMsg;

    // 步骤2：增加您的余额
    userProfile.balance += parseFloat(transferData.amount);
    
    // 步骤3：创建您发送的"已收款"确认消息
    const confirmationData = { amount: transferData.amount };
    // --- 【核心修复】在这里加上 await，等待消息创建完成 ---
const confirmationMsg = await saveChatMessage(currentChatFriendId, 'sent', JSON.stringify(confirmationData), '', null, 'transfer_accepted');
    // 步骤4：保存所有更改
    await saveData();
    
    // 步骤5：立即在界面上更新显示
    const oldCardDiv = document.querySelector(`.message[data-message-id="${messageId}"] .transfer-card`);
    if (oldCardDiv) {
        oldCardDiv.classList.add('disabled');
        oldCardDiv.onclick = null;
        const footer = oldCardDiv.querySelector('.transfer-card-footer');
        if (footer) footer.textContent = '已被接收';
    }
    addMessageToDOM(confirmationMsg, friends.find(f => f.id === currentChatFriendId));
    document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;

    updateWalletDisplay();
    showAlert('收款成功！');
}

        async function aiAcceptTransfer(messageId) {
    const history = [...(chatHistories[currentChatFriendId] || [])];
    const msgIndex = history.findIndex(m => m.id === messageId);
    if (msgIndex === -1) return;

    const msg = history[msgIndex];
    if (!msg || msg.transfer_status !== 'pending' || msg.type !== 'sent') return;

    const transferData = JSON.parse(msg.content);
    const friend = friends.find(f => f.id === currentChatFriendId);
    
    // 步骤1：在后台数据中，更新旧转账卡片的状态
    const updatedMsg = { ...msg, transfer_status: 'received' };
    chatHistories[currentChatFriendId][msgIndex] = updatedMsg;

    // 步骤2：在后台数据中，创建一条新的"已收款"确认消息
    const confirmationData = { amount: transferData.amount };
    // --- 【核心修复】在这里也加上 await ---
const confirmationMsg = await saveChatMessage(currentChatFriendId, 'received', JSON.stringify(confirmationData), '', friend.id, 'transfer_accepted');
    
    // 步骤3：保存所有数据更改
    await saveData();
    
    // 步骤4：立即在界面上更新显示
    if (currentChatFriendId === friend.id) {
        // 找到旧的转账卡片HTML元素
        const oldCardDiv = document.querySelector(`.message[data-message-id="${messageId}"] .transfer-card`);
        if (oldCardDiv) {
            // 修改它的样式和文字，让它看起来像"已接收"
            oldCardDiv.classList.add('disabled');
            oldCardDiv.onclick = null; // 移除点击事件
            const footer = oldCardDiv.querySelector('.transfer-card-footer');
            if (footer) footer.textContent = '已被接收';
        }
        // 将新的"已收款"确认卡片添加到聊天界面
        addMessageToDOM(confirmationMsg, friend);
        document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
    }
}

        // --- Voice Message Functions ---
        function openVoiceModal() {
            document.getElementById('voiceInputText').value = '';
            document.getElementById('voiceModal').classList.add('show');
        }
        function closeVoiceModal() {
            document.getElementById('voiceModal').classList.remove('show');
        }
                async function sendVoiceMessage() { // <--- 加上 async
            const text = document.getElementById('voiceInputText').value.trim();
            if(!text) return showAlert('请输入语音内容');

            const friend = friends.find(f => f.id === currentChatFriendId);
            const messageData = await saveChatMessage(currentChatFriendId, 'sent', text, '', null, 'voice'); // <--- 加上 await
            addMessageToDOM(messageData, friend);
            document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
            closeVoiceModal();
        }
        
        // [FIX & NEW] Location Functions
        const chinaLocations = {
            "北京市": ["东城区", "西城区", "朝阳区", "海淀区", "丰台区", "石景山区", "门头沟区", "房山区", "通州区", "顺义区", "昌平区", "大兴区", "怀柔区", "平谷区", "密云区", "延庆区"],
            "上海市": ["黄浦区", "徐汇区", "长宁区", "静安区", "普陀区", "虹口区", "杨浦区", "闵行区", "宝山区", "嘉定区", "浦东新区", "金山区", "松江区", "青浦区", "奉贤区", "崇明区"],
            "广东省": { "广州市": ["越秀区", "荔湾区", "海珠区", "天河区"], "深圳市": ["福田区", "罗湖区", "南山区"], "武汉市": ["江岸区", "江汉区", "硚口区", "汉阳区", "武昌区", "青山区", "洪山区", "东西湖区", "汉南区", "蔡甸区", "江夏区", "黄陂区", "新洲区"] },
            "湖北省": { "武汉市": ["江岸区", "江汉区", "硚口区", "汉阳区", "武昌区", "青山区", "洪山区"] },
            "江苏省": { "南京市": ["玄武区", "秦淮区", "建邺区", "鼓楼区"], "苏州市": ["姑苏区", "虎丘区", "吴中区"] }
        };

        function getRandomLocation() {
            const provinces = Object.keys(chinaLocations);
            const randomProvince = provinces[Math.floor(Math.random() * provinces.length)];
            const cities = chinaLocations[randomProvince];
            let randomCity, randomDistrict;

            if(Array.isArray(cities)) { // For municipalities like Beijing
                randomCity = randomProvince;
                randomDistrict = cities[Math.floor(Math.random() * cities.length)];
            } else {
                const cityKeys = Object.keys(cities);
                randomCity = cityKeys[Math.floor(Math.random() * cityKeys.length)];
                const districts = cities[randomCity];
                randomDistrict = districts[Math.floor(Math.random() * districts.length)];
            }

            const roads = ["人民", "解放", "中山", "建设", "和平", "新华", "文昌", "大学", "科技", "创新"];
            const randomRoad = roads[Math.floor(Math.random() * roads.length)];

            return `${randomProvince}${randomCity}${randomDistrict}${randomRoad}路${Math.floor(Math.random() * 800) + 1}号`;
        }

        function openLocationModal() {
            hideFunctionMenus();
            document.getElementById('locationNameInput').value = '';
            document.getElementById('sendLocationModal').classList.add('show');
        }

        async function confirmSendLocation() { // <--- 加上 async
            const name = document.getElementById('locationNameInput').value.trim();
            if (!name) {
                showAlert('请输入位置名称');
                return;
            }
            
            const fakeAddress = getRandomLocation();
            
            const locationData = { name, address: fakeAddress };
            const friend = friends.find(f => f.id === currentChatFriendId);
            
            const msgData = await saveChatMessage(currentChatFriendId, 'sent', JSON.stringify(locationData), '', null, 'location'); // <--- 加上 await
            addMessageToDOM(msgData, friend);
            
            document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
            closeLocationModal();
        }

        // --- MODIFIED & REFACTORED: Phone App Logic ---
        function initPhoneApp() {
            document.getElementById('simulatedPhoneScreen').style.display = 'none';
            document.getElementById('phoneCharacterListScreen').style.display = 'block';

            const navBar = document.getElementById('phoneAppNavBar');
            const navTitle = navBar.querySelector('.nav-title');
            navTitle.textContent = '手机';
            navBar.querySelector('*:first-child').innerHTML = `<button class="nav-btn" onclick="goHome()">←</button>`;
            
            const listContainer = document.getElementById('phoneCharacterListScreen');
            listContainer.innerHTML = '';
            const availableFriends = friends.filter(f => !f.isGroup);

            if (availableFriends.length === 0) {
                listContainer.innerHTML = '<div style="text-align: center ; padding: 50px; color: #999;">暂无好友手机可查看</div>';
                return;
            }

            availableFriends.forEach(friend => {
                const item = document.createElement('div');
                item.className = 'friend-item';
                item.onclick = () => openSimulatedPhone(friend.id);
                const avatarHtml = friend.avatarImage 
                    ? `<div class="friend-avatar" style="background-image: url(${friend.avatarImage});"></div>` 
                    : `<div class="friend-avatar">${friend.avatar}</div>`;
                item.innerHTML = `${avatarHtml}<div class="friend-info"><div class="friend-name">${friend.remark || friend.name}</div><div class="friend-message">点击查看Ta的手机</div></div>`;
                listContainer.appendChild(item);
            });
        }

        // [修改后] 的函数
function openSimulatedPhone(characterId) {
    currentSimPhoneCharacterId = characterId;
    document.getElementById('phoneCharacterListScreen').style.display = 'none';
    document.getElementById('simulatedPhoneScreen').style.display = 'flex';
    
    // [新增] 显示重新生成按钮
    document.getElementById('regenerateSimContentBtn').style.display = 'flex';
    
    const character = friends.find(f => f.id === characterId);
    const navBar = document.getElementById('phoneAppNavBar');
    navBar.querySelector('.nav-title').textContent = `${character.name}的手机`;
    navBar.querySelector('*:first-child').innerHTML = `<button class="nav-btn" onclick="backToPhoneAppHome()">←</button>`;
    
    backToSimHomeScreen();
}
        
        // [修改后] 的函数
function backToPhoneAppHome() {
    currentSimPhoneCharacterId = null;
    // [新增] 退出时隐藏重新生成按钮
    document.getElementById('regenerateSimContentBtn').style.display = 'none';
    initPhoneApp();
}

// [修改后] 的函数
function backToSimHomeScreen() {
    // [新增] 返回主屏幕时，重置当前打开的App标记
    currentActiveSimApp = null;
    document.querySelectorAll('.sim-app-view').forEach(view => view.classList.remove('active'));
}

        // [修改后] 的函数
async function openSimApp(appName) {
    // [新增] 记录当前打开的App
    currentActiveSimApp = appName;
    
    const view = document.getElementById(`sim-${appName}-view`);
    if (!view || !currentSimPhoneCharacterId) return;

    document.querySelectorAll('.sim-app-view').forEach(v => v.classList.remove('active'));
    view.classList.add('active');
    view.innerHTML = `<div class="sim-loading-overlay">正在加载内容...</div>`;

    const characterId = currentSimPhoneCharacterId;
    
    // [修改] 简化缓存逻辑：只检查有没有数据，不再检查时间
    const cached = (simPhoneContentCache[characterId] || {})[appName];
    if (cached) {
        renderSimAppList(appName, cached.data);
        return;
    }
    
    // 如果没缓存，就生成新的
    await generateSimAppContent(characterId, appName);
}

      
    
            // 【【【这是最终修复版，请用它完整替换】】】
async function generateSimAppContent(characterId, appName) {
    const character = friends.find(f => f.id === characterId);
    if (!character) return;

    // --- 指令准备部分 (与上次相同，保持简化) ---
    const recentChatHistory = (chatHistories[characterId] || []).slice(-20).map(m => `[${formatTimestampForAI(m.timestamp)}] ${m.type === 'sent' ? userProfile.name : character.name}: ${m.content}`).join('\n');
    const recentMoments = moments.slice(0, 3).map(m => {
        const author = getAuthorById(m.authorId);
        return `[${author.name} 在 ${m.timestamp.slice(0,10)} 发布的朋友圈]: ${m.content}`;
    }).join('\n');
    const currentDate = new Date().toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' });
    
    let prompt = `你正在深度模拟角色"${character.name}"的手机，你需要生成手机中某个应用的内容。
    【角色核心人设】: ${character.role}
    【核心记忆库 (最近20条聊天记录 & 最近3条朋友圈)】:
    --- 聊天记录开始 ---
    ${recentChatHistory || '无聊天记录。'}
    --- 聊天记录结束 ---
    --- 朋友圈记录开始 ---
    ${recentMoments || '无朋友圈记录。'}
    --- 朋友圈记录结束 ---
    【【【核心铁律】】】:
    1.  你生成的内容应该是**“现实”与“虚构”的结合体**。大部分内容应基于“核心记忆库”，反映真实事件。小部分可以是角色的合理虚构，但**绝对不能与记忆库中的事实相矛盾！**
    2.  **【绝对创新铁律】**: 即使基于相同记忆，你每次生成的内容都必须是**全新的**。严禁重复。
    3.  **【绝对时间铁律】**: 所有生成的内容，其发生时间都必须围绕**当前现实日期：${currentDate}**，并且逻辑上必须合理。
    4.  你的回复**必须**是一个符合下方具体格式要求的、纯净的JSON对象，不包含任何额外的解释。

    请为应用“${appName}”生成内容：`;
    
    // --- App具体指令 (与上次相同) ---
    switch(appName) {
        case 'memo':
            prompt += `\n生成4条备忘录。内容应基于“核心记忆库”中的事件，或符合角色人设的个人想法。
            **【格式指令】**:
            - **【换行铁律】**: 必须在内容中使用多个换行符 (\\n) 来分段落，让备忘录看起来有条理。
            - **内容要详细、生活化。**
            
            JSON格式: {"memos": [{"id": "memo_1", "title": "标题", "content": "备忘录内容...", "datetime": "YYYY-MM-DD HH:MM"}, ...]}`;
            break;

        case 'wechat':
            prompt += `\n生成3个与【除了用户'${userProfile.name}'之外的】虚构人物的微信聊天摘要。这些对话应展现你的个人生活。**绝对不能**生成与'${userProfile.name}'的聊天。每个摘要必须包含id, name, avatar(单个汉字), 和一个包含8条对话的 "messages" 数组。
            JSON格式: {"chats": [{"id": "chat_1", "name": "聊天对象", "avatar": "单个汉字", "messages": [{"sender": "发送者名字", "content": "消息内容"}, ...]}, ...]}`;
            break;
            
        case 'browser':
            prompt += `\ n生成4条浏览器历史记录。内容应与“核心记忆库”中的话题或你的人设兴趣相关。每条记录必须包含id, title, url (一个模拟网址), 和一段模拟的网页正文 "content" (需包含换行\\n, 至少100字)。
            JSON格式: {"history": [{"id": "history_1", "title": "网页标题", "url": "https://example.com/path", "content": "详细的网页内容...\\n\\n包含分段。"}, ...]}`;
            break;

        case 'shopping':
            prompt += `\n生成4条购物订单。商品应符合你的角色人设和消费习惯。每条必须包含id, name, price, 和一段详细的 "description" (商品描述或购买理由)。
            **【内容要求】**: "description" 字段必须详细，至少40字，模拟真实的商品描述或购买心得。
            JSON格式: {"orders": [{"id": "order_1", "name": "商品名称", "price": "价格", "description": "详细描述..."}, ...]}`;
            break;

        case 'wallet':
            prompt += `\n你的任务是根据角色的核心人设和记忆，生成一个极其逼真的钱包账单。
            **【财务人设分析指令 (最重要！)】**:
            1.  **首先，请根据角色人设 \`${character.role}\` 智能分析并决定其最合理的财务状况**:
                -   如果角色是**富裕的** (总裁, 明星), 请生成**数万到百万级别**的余额，及**数千到数万**的单笔消费。
                -   如果角色是**普通人** (学生, 员工), 请生成**数百到数千级别**的余额，消费记录也应是几十到几百的日常水平。
            2.  **【核心原则】**: 你必须进行**智能推断**，而不是死板匹配。
            
            **【格式铁律】**:
            - **【余额铁律】**: \`balance\` 字段的值**必须**是一个**不带引号的纯数字**。
            - 生成5条交易记录，每条必须包含 "description", "amount" (+/-金额, 纯数字), 和 "time" (MM-DD HH:mm)。
            
            **【JSON格式示例】**: 
            // 富裕人设示例:
            {"balance": 854321.68, "transactions": [{"description": "品牌专柜消费", "amount": -18000.00, "time": "09-08 14:30"}]}
            // 普通人设示例:
            {"balance": 3250.70, "transactions": [{"description": "超市买菜", "amount": -85.50, "time": "09-06 18:00"}]}
            `;
            break;

        case 'photos':
            prompt += `\n生成4张相册照片的标题和详细文字描述。照片内容应源于“核心记忆库”中的真实事件或符合人设的生活瞬间。每条必须包含id, title, 和 "description"。description必须分为两段，用"\\n\\n"隔开：第一段描述画面；第二段描述照片背后的心情故事。每段至少40字。
            JSON格式: {"photos": [{"id": "photo_1", "title": "照片标题", "description": "照片画面描述...\\n\\n心情故事..."}, ...]}`;
            break;

        case 'phone_call':
            prompt += `\n生成6条通话记录。通话对象应与“核心记忆库”中提到的人物或事件相关。每条必须包含name, type (incoming/outgoing/missed), 和time。
            JSON格式: {"calls": [{"name": "联系人名", "type": "incoming", "time": "时间描述"}, ...]}`;
            break;
            
        case 'forum':
            prompt += `\n生成4个论坛帖子。主题应源自“核心记忆库”中的真实困惑或分享。为每个帖子生成**8条**左右的评论。
            **【评论活人感指令】**: 评论必须模拟真实论坛，要有多样化的用户（杠精、热心人、路人等），风格要口语化、多样化。
            JSON格式: {"posts": [{"id": "post_1", "title": "帖子标题", "content": "帖子正文...", "datetime": "YYYY-MM-DD HH:MM", "comments": [{"floor": "1楼", "user": "网友昵称", "comment": "评论内容"}, ...]}, ...]}`;
            break;
    }

    const settings = await dbManager.get('apiSettings', 'settings');
    if (!settings.apiUrl || !settings.apiKey) {
        renderSimAppList(appName, { error: "API未配置" });
        return;
    }
    
    // --- 核心修复：在这里引入“AI自我修复”逻辑 ---
    try {
        // 发起第一次请求
        let response = await fetch(`${settings.apiUrl}/chat/completions`, { 
            method: 'POST', 
            headers: { 'Authorization': `Bearer ${settings.apiKey}`, 'Content-Type': 'application/json' }, 
            body: JSON.stringify({ model: settings.modelName, messages: [{role: 'user', content: prompt}], response_format: { type: 'json_object' } }) 
        });
        if(!response.ok) throw new Error(`API请求失败: ${response.status}`);
        let data = await response.json();
        let responseText = data.choices[0].message.content;

        let content;
        try {
            // 1. 第一次尝试解析：更智能地查找JSON，过滤掉AI的“话痨”部分
            const firstBracket = responseText.indexOf('{');
            const lastBracket = responseText.lastIndexOf('}');
            if (firstBracket === -1 || lastBracket === -1) {
                throw new Error("响应中未找到有效的JSON对象。");
            }
            const jsonString = responseText.substring(firstBracket, lastBracket + 1);
            content = JSON.parse(jsonString);
        } catch (parseError) {
            console.error("初次解析JSON失败，启动AI自我修复:", parseError);
            console.log("需要修复的文本:", responseText);

            // 2. 如果失败，启动“AI自我修复”：让AI自己修复自己写错的JSON
            const repairPrompt = `以下是一段损坏的JSON文本，请修复它，并只返回修复后的、纯净的、没有任何额外文字的JSON代码。\n\n损坏的文本：\n\`\`\`json\n${responseText}\n\`\`\``;
            
            response = await fetch(`${settings.apiUrl}/chat/completions`, { 
                method: 'POST', 
                headers: { 'Authorization': `Bearer ${settings.apiKey}`, 'Content-Type': 'application/json' }, 
                body: JSON.stringify({ model: settings.modelName, messages: [{role: 'user', content: repairPrompt}], response_format: { type: 'json_object' } }) 
            });
            if(!response.ok) throw new Error(`AI修复请求失败: ${response.status}`);
            data = await response.json();
            const repairedText = data.choices[0].message.content;
            
            // 3. 再次尝试解析修复后的文本
            content = JSON.parse(repairedText); 
        }

        if (!simPhoneContentCache[characterId]) simPhoneContentCache[characterId] = {};
        simPhoneContentCache[characterId][appName] = { data: content }; 
        await saveData();
        renderSimAppList(appName, content);

    } catch(e) {
        console.error(`生成模拟内容失败，即使在修复后也是如此:`, e);
        renderSimAppList(appName, { error: "内容生成失败，请重试。" });
    }
}

        function renderSimAppList(appName, data) {
            const view = document.getElementById(`sim-${appName}-view`);
            if (!view) return;
            // 在 renderSimAppList 函数内
// [修改] 添加 'forum': '论坛'
const headerMap = { wechat: '微信', memo: '备忘录', phone_call: '通话记录', browser: '浏览器', shopping: '购物', wallet: '钱包', photos: '相册', forum: '论坛' };
// ...
            const backFn = 'backToSimHomeScreen()';
            let contentHTML = '';

            if (data.error) {
                contentHTML = `<div style="text-align:center; padding: 40px;">${data.error}</div>`;
            } else {
                 switch(appName) {
                 // ...在 switch(appName) 内部 ...

// [修改后]
case 'forum':
    contentHTML = (data.posts || []).map(post => {
        const postJsonString = JSON.stringify(post).replace(/'/g, "\\'").replace(/"/g, '&quot;');
        // [新增] 添加了 post.datetime 的显示
        return `<div class="sim-memo-item" onclick='renderSimAppDetail("forum", ${postJsonString})'>
                    <div class="sim-memo-title">${post.title}</div>
                    <div class="sim-memo-datetime">${post.datetime || ''}</div>
                </div>`;
    }).join('');
    break;

// ...其他 case ...
                    case 'memo':
                        contentHTML = (data.memos || []).map(item => {
                            const itemJsonString = JSON.stringify(item).replace(/'/g, "\\'").replace(/"/g, '&quot;');
                            return `<div class="sim-memo-item" onclick='renderSimAppDetail("memo", ${itemJsonString})'>
                                <div class="sim-memo-title">${item.title}</div>
                                <div class="sim-memo-content">${(item.content || '').substring(0, 50)}...</div>
                                <div class="sim-memo-datetime">${item.datetime}</div>
                            </div>`;
                        }).join('');
                        break;
                    case 'wechat':
                        const character = friends.find(f => f.id === currentSimPhoneCharacterId);
                        const realChatHistory = (chatHistories[character.id] || []).slice(-10);
                        const realChat = {
                            id: 'chat_with_user',
                            name: userProfile.name,
                            avatar: userProfile.avatar || userProfile.name.substring(0,1),
                            avatarImage: userProfile.avatarImage,
                            messages: realChatHistory.map(msg => ({
                                sender: msg.type === 'sent' ? userProfile.name : character.name,
                                content: msg.content,
                                type: msg.type
                            }))
                        };
                        const allChats = [realChat, ...(data.chats || [])];
                        contentHTML = '<div class="friend-list">' + allChats.map(item => {
                            const itemJsonString = JSON.stringify(item).replace(/'/g, "\\'").replace(/"/g, '&quot;');
                            const avatarHtml = item.avatarImage ? `<div class="friend-avatar" style="background-image: url(${item.avatarImage})"></div>` : `<div class="friend-avatar">${item.avatar}</div>`;
                            return `<div class="friend-item" onclick='renderSimAppDetail("wechat", ${itemJsonString})'>
                                ${avatarHtml}
                                <div class="friend-info">
                                    <div class="friend-name">${item.name}</div>
                                    <div class="friend-message">${item.messages[item.messages.length - 1]?.content.substring(0, 30) || ''}...</div>
                                </div>
                            </div>`;
                        }).join('') + '</div>';
                        break;
                    case 'browser':
                        contentHTML = (data.history || []).map(item => {
                            const itemJsonString = JSON.stringify(item).replace(/'/g, "\\'").replace(/"/g, '&quot;');
                            return `<div class="sim-browser-item" onclick='renderSimAppDetail("browser", ${itemJsonString})'>
                                <div class="sim-browser-title">${item.title}</div>
                                <div class="sim-browser-url">${item.url}</div>
                            </div>`;
                        }).join('');
                        break;
                    case 'shopping':
                        contentHTML = (data.orders || []).map(item => {
                             const itemJsonString = JSON.stringify(item).replace(/'/g, "\\'").replace(/"/g, '&quot;');
                             return `<div class="sim-shopping-item" onclick='renderSimAppDetail("shopping", ${itemJsonString})'>
                                <div class="sim-shopping-title">${item.name}</div>
                                <div class="sim-shopping-details"><strong>¥${item.price}</strong></div>
                             </div>`;
                        }).join('');
                        break;
                    case 'photos':
                        contentHTML = '<div class="sim-photos-grid">' + (data.photos || []).map(item => {
                            const itemJsonString = JSON.stringify(item).replace(/'/g, "\\'").replace(/"/g, '&quot;');
                            return `<div class="sim-photo-thumb" onclick='renderSimAppDetail("photos", ${itemJsonString})'>
                                <svg viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>
                            </div>`;
                        }).join('') + '</div>';
                        break;
                    case 'phone_call':
                        const callIcons = { incoming: '↙', outgoing: '↗', missed: '↙' };
                        const callColors = { incoming: 'var(--text-color)', outgoing: 'var(--text-color)', missed: 'red' };
                        contentHTML = (data.calls || []).map(item => `<div class="sim-call-item"><div class="sim-call-type" style="color: ${callColors[item.type] || 'var(--text-color)'}">${callIcons[item.type] || ''}</div><div class="sim-call-info"><div class="sim-call-name" style="color: ${item.type === 'missed' ? 'red' : 'var(--text-color)'}">${item.name}</div><div class="sim-call-detail">${item.time}</div></div></div>`).join('');
                        break;
                     case 'wallet':
                        // 【【【这是修改后的新代码，请用它来替换】】】
let rawBalance = parseFloat(data.balance);
let balance = (isNaN(rawBalance) ? 0 : rawBalance).toFixed(2);
                        contentHTML = `<div class="sim-wallet-balance"><div>余额</div><div class="sim-wallet-amount">¥ ${balance}</div></div>`;
                        contentHTML += (data.transactions || []).map(item => `<div class="sim-wallet-item"><div><div>${item.description}</div><div style="font-size:12px; color: #999;">${item.time || ''}</div></div><div class="amount ${parseFloat(item.amount) > 0 ? 'positive' : 'negative'}">${item.amount}</div></div>`).join('');
                        break;
                }
            }

            view.innerHTML = `
                <div class="sim-app-header">
                    <button class="sim-app-header-btn" onclick="${backFn}">‹</button>
                    <div class="sim-app-header-title">${headerMap[appName]}</div>
                    <div style="width: 50px;"></div>
                </div>
                <div class="sim-app-content">${contentHTML}</div>
            `;
        }

        // [修改后] 的函数
function renderSimAppDetail(appName, detailItem) {
    const detailView = document.getElementById(`sim-${appName}-detail-view`);
    const listView = document.getElementById(`sim-${appName}-view`);
    if (!detailView || !listView) return;

    listView.classList.remove('active');
    detailView.classList.add('active');

    const backFn = `document.getElementById('sim-${appName}-detail-view').classList.remove('active'); document.getElementById('sim-${appName}-view').classList.add('active');`;
    // 【【【这是修改后的新代码，请用它来替换】】】
const originalTitle = detailItem.title || detailItem.name || '详情';
let headerTitle = originalTitle.length > 10 ? originalTitle.substring(0, 10) + '...' : originalTitle;
    let contentHTML = '';

    switch(appName) {
        case 'memo':
            // [修改] 使用新的格式化函数
            contentHTML = `<div class="sim-detail-content">${formatMemoContent(detailItem.content)}</div>`;
            break;
        case 'wechat':
            const character = friends.find(f => f.id === currentSimPhoneCharacterId);
            const isRealChat = detailItem.id === 'chat_with_user';
            contentHTML = `<div class="chat-messages" style="padding: 10px; height: 100%; overflow-y: auto; background-color: #ededee;">` + 
            (detailItem.messages || []).map(msg => {
                const isCharacterSender = msg.sender === character.name;
                let type;
                if (isRealChat) {
                    type = msg.type === 'sent' ? 'received' : 'sent';
                } else {
                    type = isCharacterSender ? 'sent' : 'received';
                }
                const sender = (type === 'sent') 
                    ? character 
                    : (isRealChat ? userProfile : { name: detailItem.name, avatar: detailItem.avatar, avatarImage: ''});
                const messageHtml = `
                    <div class="message ${type}">
                        ${type === 'received' ? getAvatarHtml(sender) : ''}
                        <div class="message-body">
                            <div class="message-content">${msg.content}</div>
                        </div>
                        ${type === 'sent' ? getAvatarHtml(sender) : ''}
                    </div>`;
                return messageHtml;
            }).join('') + `</div>`;
            break;
        case 'browser':
            contentHTML = `<div class="sim-detail-content"><h3>${detailItem.title}</h3><hr style="margin: 10px 0; border: 0; border-top: 1px solid #eee;"><p>${(detailItem.content || '').replace(/\n/g, '<br>')}</p></div>`;
            break;
        case 'shopping':
            const encodedName = encodeURIComponent(detailItem.name);
            const imageUrl = `https://placehold.co/400x400/f0f0f0/ccc?text=${encodedName}`;
            contentHTML = `<div class="sim-detail-content">
                <div class="sim-shopping-image-placeholder"><img src="${imageUrl}" alt="${detailItem.name}"></div>
                <h3>${detailItem.name}</h3>
                <p style="font-size: 20px; font-weight: bold; margin: 10px 0;">¥${detailItem.price}</p>
                <p>${detailItem.description || '暂无商品详情。'}</p>
            </div>`;
            break;
        case 'photos':
            headerTitle = '照片详情';
            contentHTML = `<div class="sim-detail-content">
                <div class="sim-shopping-image-placeholder"><svg viewBox="0 0 24 24" width="50" height="50" fill="#ccc"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg></div>
                <p style="white-space: pre-wrap;">${(detailItem.description || '这张照片里什么也没有...').replace(/\n/g, '<br>')}</p>
            </div>`;
            break;
        // [修改] 论坛详情渲染，应用了新的CSS class
        case 'forum':
            headerTitle = '帖子详情';
            let commentsHtml = (detailItem.comments || []).map(comment => `
                <div class="comment-floor">
                    <div class="comment-user-info">${comment.floor} - ${comment.user}</div>
                    <div class="comment-text">${comment.comment}</div>
                </div>
            `).join('');
            
            contentHTML = `
                <div class="sim-detail-content">
                    <h3>${detailItem.title}</h3>
                    <div class="sim-memo-datetime">${detailItem.datetime || ''}</div>
                    <hr style="margin: 10px 0; border: 0; border-top: 1px solid #eee;">
                    <p style="white-space: pre-wrap;">${(detailItem.content || '').replace(/\n/g, '<br>')}</p>
                    <div style="margin-top: 30px;">
                        <h4>评论区</h4>
                        ${commentsHtml}
                    </div>
                </div>`;
            break;
    }

    detailView.innerHTML = `
        <div class="sim-app-header">
            <button class="sim-app-header-btn" onclick="${backFn}">‹</button>
            <div class="sim-app-header-title">${headerTitle}</div>
            <div style="width: 50px;"></div>
        </div>
        <div class="sim-app-content">${contentHTML}</div>
    `;
}
        
        // [全新] 的函数，处理重新生成按钮的点击事件
async function handleSimRegenerateClick() {
    if (!currentSimPhoneCharacterId) return;

    const character = friends.find(f => f.id === currentSimPhoneCharacterId);
    const loadingOverlay = `<div class="sim-loading-overlay">正在重新生成...</div>`;
    // ...函数内部...
// [修改] 在数组末尾添加 'forum'
const allAppNames = ['memo', 'wechat', 'browser', 'shopping', 'wallet', 'photos', 'phone_call', 'forum'];
// ...函数其余部分...

    if (currentActiveSimApp) {
        // --- 场景一：只重新生成当前打开的App ---
        showConfirm(`确定要为 ${character.name} 重新生成“${currentActiveSimApp}”的内容吗？`, async (confirmed) => {
            if (!confirmed) return;
            
            const view = document.getElementById(`sim-${currentActiveSimApp}-view`);
            if (view) view.innerHTML = loadingOverlay;
            
            await generateSimAppContent(currentSimPhoneCharacterId, currentActiveSimApp);
        });

    } else {
        // --- 场景二：在主屏幕，重新生成所有App ---
        showConfirm(`确定要为 ${character.name} 重新生成手机里所有App的内容吗？`, async (confirmed) => {
            if (!confirmed) return;
            
            // 清空旧的缓存
            if (simPhoneContentCache[currentSimPhoneCharacterId]) {
                simPhoneContentCache[currentSimPhoneCharacterId] = {};
            }
            
            showAlert("正在为所有App重新生成内容，请稍候...");
            
            // 并行生成所有App的内容
            await Promise.all(allAppNames.map(appName => generateSimAppContent(currentSimPhoneCharacterId, appName)));
            
            showAlert("所有内容已重新生成！");
        });
    }
}

// [全新] 函数：格式化备忘录内容

// 【【【这是修改后的新代码，请用它完整替换】】】
function formatMemoContent(content) {
    if (!content) return '';
    // 直接将换行符 (\n) 替换为 HTML 的换行标签 (<br>)
    // 这会保留所有的换行和纯文本格式
    return content.replace(/\n/g, '<br>');
}

// ↓↓↓ 3.3 将以下所有新函数，完整地粘贴到 <script> 的末尾 ↓↓↓

// --- 投票功能核心函数 ---

/**
 * 打开创建投票的弹窗
 */
function openPollModal() {
    // 重置弹窗状态
    document.getElementById('pollTitleInput').value = '';
    const optionsContainer = document.getElementById('pollOptionsContainer');
    optionsContainer.innerHTML = `
        <div class="form-group" style="display: flex; align-items: center; gap: 10px;">
            <input type="text" class="form-input poll-option-input" placeholder="选项 1">
        </div>
        <div class="form-group" style="display: flex; align-items: center; gap: 10px;">
            <input type="text" class="form-input poll-option-input" placeholder="选项 2">
        </div>
    `;
    document.getElementById('pollModal').classList.add('show');
    hideFunctionMenus();
}

/**
 * 关闭创建投票的弹窗
 */
function closePollModal() {
    document.getElementById('pollModal').classList.remove('show');
}

/**
 * 在弹窗中动态添加一个新选项
 */
function addPollOption() {
    const optionsContainer = document.getElementById('pollOptionsContainer');
    const optionCount = optionsContainer.children.length + 1;
    if (optionCount > 10) {
        return showAlert('最多只能添加10个选项。');
    }
    const newOptionDiv = document.createElement('div');
    newOptionDiv.className = 'form-group';
    newOptionDiv.style.cssText = 'display: flex; align-items: center; gap: 10px;';
    newOptionDiv.innerHTML = `
        <input type="text" class="form-input poll-option-input" placeholder="选项 ${optionCount}">
        <button class="remove-option-btn" onclick="removePollOption(this)">-</button>
    `;
    optionsContainer.appendChild(newOptionDiv);
}

/**
 * 在弹窗中移除一个选项
 * @param {HTMLElement} button - 被点击的移除按钮
 */
function removePollOption(button) {
    button.parentElement.remove();
    // 更新所有选项的 placeholder
    const options = document.querySelectorAll('.poll-option-input');
    options.forEach((input, index) => {
        input.placeholder = `选项 ${index + 1}`;
    });
}

/**
 * 核心功能：发送投票
 */
async function sendPoll() {
    const title = document.getElementById('pollTitleInput').value.trim();
    const optionInputs = document.querySelectorAll('.poll-option-input');
    const options = Array.from(optionInputs)
        .map(input => ({ text: input.value.trim(), votes: [] }))
        .filter(option => option.text);

    if (!title) return showAlert('请输入投票标题。');
    if (options.length < 2) return showAlert('至少需要两个有效的选项。');

    const pollData = {
        id: `poll_${generateUniqueId()}`,
        title: title,
        options: options,
        voterCount: 0,
        votedBy: [] // 记录已投票的AI ID，防止重复投票
    };

    const group = friends.find(f => f.id === currentChatFriendId);
    const msgData = await saveChatMessage(currentChatFriendId, 'sent', JSON.stringify(pollData), '', null, 'poll');
    
    addMessageToDOM(msgData, group);
    document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
    closePollModal();

    // 触发AI投票
    triggerAiPollVote(msgData.id);
}

// ↓↓↓ 请用这个【高效即时版】的函数，替换掉原来的 triggerAiPollVote 函数 ↓↓↓

/**
 * 核心功能：触发所有AI角色进行投票 (高效即时版)
 * @param {string} messageId - 投票卡片的消息ID
 */
async function triggerAiPollVote(messageId) {
    const group = friends.find(f => f.id === currentChatFriendId);
    if (!group || !group.isGroup) return;

    const history = chatHistories[currentChatFriendId];
    const msgIndex = history.findIndex(m => m.id === messageId);
    if (msgIndex === -1) return;

    const pollData = JSON.parse(history[msgIndex].content);

    // 筛选出所有需要投票的AI成员
    const aiMembers = group.members.filter(id => id !== userProfile.id);
    
    // 【【【核心修改在这里】】】
    // 我们不再使用 setTimeout 来制造延迟，
    // 而是创建一个任务数组，让所有AI的投票请求同时发出。
    const votingPromises = aiMembers.map(memberId => {
        // 直接调用请求函数，不再等待
        return requestAiVote(messageId, pollData, memberId);
    });

    // 等待所有的AI投票任务都执行完毕
    await Promise.all(votingPromises);

    // 在所有AI投完票后，再触发一次总导演的对话，让它们对投票结果进行讨论
    console.log("[投票系统] 所有AI已完成投票，正在触发后续对话...");
    receiveMessage(currentChatFriendId);
}

// ↓↓↓ 第一步：用这个新函数完整替换旧的 requestAiVote 函数 ↓↓↓

/**
 * 核心功能：为单个AI请求投票决策 (V2 - 无理由版)
 * @param {string} messageId - 投票消息ID
 * @param {object} pollData - 投票数据对象
 * @param {string} aiMemberId - 需要投票的AI成员ID
 */
async function requestAiVote(messageId, pollData, aiMemberId) {
    const ai = friends.find(f => f.id === aiMemberId);
    if (!ai) return;

    const settings = await dbManager.get('apiSettings', 'settings') || {};
    if (!settings.apiUrl || !settings.apiKey) return;
    
    const optionsText = pollData.options.map((opt, index) => `${index}. ${opt.text}`).join('\n');

    // --- 修改点1：简化了AI的指令 ---
    const prompt = `
    【你的身份】: 你是群聊成员 "${ai.name}"，你的性格是：“${ai.role}”。

    【当前情景】:
    群主 "${userProfile.name}" 在群里发起了一个投票，你需要根据自己的性格和判断，选择一个选项。

    【投票详情】:
    - 标题: "${pollData.title}"
    - 选项:
    ${optionsText}

    【你的任务】:
    仔细阅读投票标题和所有选项，根据你的人设，选择一个你最倾向的选项。
    
    【【【输出格式铁律】】】
    你的回复必须是一个纯净的JSON对象，只包含一个键：
    1.  "choice_index": 你选择的选项的**数字索引** (从0开始)。

    【JSON格式示例】:
    {
      "choice_index": 1
    }

    现在，请做出你的选择。`;

    try {
        const response = await fetch(`${settings.apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${settings.apiKey}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: settings.modelName,
                messages: [{ role: 'user', content: prompt }],
                response_format: { type: 'json_object' },
                temperature: 1.0 
            })
        });

        if (!response.ok) throw new Error(`API 请求失败: ${response.status}`);
        
        const data = await response.json();
        const responseData = JSON.parse(data.choices[0].message.content);

        // --- 修改点2：不再检查 reason ---
        if (responseData && typeof responseData.choice_index === 'number') {
            // --- 修改点3：调用时不再传递 reason ---
            await processAiVote(messageId, aiMemberId, responseData.choice_index);
        }

    } catch (error) {
        console.error(`AI "${ai.name}" 投票时出错:`, error);
    }
}

// ↓↓↓ 第二步：用这个新函数完整替换旧的 processAiVote 函数 ↓↓↓

/**
 * 核心功能：处理AI的投票结果，并更新UI (V2 - 无理由版)
 * @param {string} messageId - 投票消息ID
 * @param {string} aiVoterId - 投票的AI的ID
 * @param {number} choiceIndex - AI选择的选项索引
 */
async function processAiVote(messageId, aiVoterId, choiceIndex) { // --- 修改点1：移除了 reason 参数 ---
    const history = chatHistories[currentChatFriendId];
    const msgIndex = history.findIndex(m => m.id === messageId);
    if (msgIndex === -1) return;

    let pollData = JSON.parse(history[msgIndex].content);

    if (pollData.votedBy.includes(aiVoterId)) return;
    
    if (choiceIndex >= 0 && choiceIndex < pollData.options.length) {
        pollData.options[choiceIndex].votes.push(aiVoterId);
        pollData.voterCount++;
        pollData.votedBy.push(aiVoterId);

        history[msgIndex].content = JSON.stringify(pollData);
        await saveData();
        
        updatePollCardInDOM(pollData);

        // --- 修改点2：删除了原来发送投票理由消息的所有代码 ---
        // (这里原来有一大段代码用于发送理由消息，现在已经没有了)
    }
}

/**
 * 核心功能：在DOM中实时更新投票卡片的内容
 * @param {object} pollData - 最新的投票数据
 */
function updatePollCardInDOM(pollData) {
    const cardElement = document.getElementById(`poll-${pollData.id}`);
    if (!cardElement) return;

    // 更新参与人数
    cardElement.querySelector('.poll-card-subtitle').textContent = `${pollData.voterCount}人已参与`;

    // 重新渲染所有选项的投票者头像
    const optionItems = cardElement.querySelectorAll('.poll-option-item');
    pollData.options.forEach((option, index) => {
        if (optionItems[index]) {
            const votersLine = optionItems[index].querySelector('.poll-voters-line');
            const votersHtml = option.votes.map(voterId => {
                const voter = getAuthorById(voterId);
                return voter.avatarImage 
                    ? `<div class="poll-voter-avatar" style="background-image: url(${voter.avatarImage})"></div>`
                    : `<div class="poll-voter-avatar">${voter.avatar}</div>`;
            }).join('');
            votersLine.innerHTML = votersHtml;
        }
    });
}

// ↑↑↑ 第三步：新函数粘贴到此结束 ↑↑↑

        window.onload = async function() {
    await dbManager.init(); // 确保 IndexedDB 已初始化
    
    // 在这里调用请求持久性存储的函数
    await requestPersistentStorage(); 

    await loadData();
    updateProfileDisplay();
    updateHomeWidget();
    updateFriendList();
    updateTime();
    setActivePage('homeScreen');
    
    // ... (你 window.onload 中其余的代码)
            
            audioElement = document.getElementById('audioPlayer');
            
            audioElement.addEventListener('play', () => {
                document.getElementById('vinylRecord').classList.add('playing');
                document.getElementById('playPauseBtn').innerHTML = `<svg viewBox="0 0 24 24"><path d="M14 19h4V5h-4v14zm-10 0h4V5H4v14z"/></svg>`;
            });
            audioElement.addEventListener('pause', () => {
                document.getElementById('vinylRecord').classList.remove('playing');
                 document.getElementById('playPauseBtn').innerHTML = `<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>`;
            });
            audioElement.addEventListener('ended', () => {
                if(isRepeat) playSong(currentSongIndex);
                else nextSong();
            });
            audioElement.addEventListener('timeupdate', () => {
                const progressBar = document.getElementById('songProgressBar');
                progressBar.value = audioElement.currentTime;
                document.getElementById('currentTimeLabel').textContent = formatTime(audioElement.currentTime);
                updateLyrics(audioElement.currentTime);
            });
            audioElement.addEventListener('loadedmetadata', () => {
                const progressBar = document.getElementById('songProgressBar');
                progressBar.max = audioElement.duration;
                document.getElementById('durationLabel').textContent = formatTime(audioElement.duration);
            });

            // Listen Together UI bindings
            document.getElementById('listenBackBtn').addEventListener('click', backToChatFromListen);
            document.getElementById('listenCloseBtn').addEventListener('click', () => terminateListenTogether(null));
            floatingPlayer.addEventListener('click', (e) => {
                 if (e.target.id !== 'floatingPlayerCloseBtn') returnToListenScreen();
            });

            document.getElementById('message-notification').addEventListener('click', (e) => {
                const friendId = e.currentTarget.getAttribute('data-friend-id');
                if (friendId) {
                    e.currentTarget.classList.remove('show');
                    // Ensure the main app is visible before opening chat
                    if(document.getElementById('wechatApp').classList.contains('active')) {
                        openChat(friendId);
                    } else {
                        openApp('wechat');
                        // Use a short timeout to ensure the UI has switched before opening the specific chat
                        setTimeout(() => openChat(friendId), 50);
                    }
                }
            });


            document.getElementById('confirmOkBtn').addEventListener('click', () => { if (typeof confirmCallback === 'function') confirmCallback(true); closeConfirmModal(); });
            document.getElementById('confirmCancelBtn').addEventListener('click',() => { if (typeof confirmCallback === 'function') confirmCallback(false); closeConfirmModal(); });
            document.getElementById('momentCommentSendBtn').addEventListener('click', postComment);
            toggleSendButtonActive(document.getElementById('messageInput'));
            setInterval(simulateAiBehavior, 60000); 
           
    }; // 这是 window.onload 的结束括号和分号
        
        // 【【【第三步 D：在 <script> 的末尾粘贴所有新函数】】】

        
   // 简化版本，仅用于调试
function setRealViewportHeight() {
    console.log('窗口高度:', window.innerHeight, '屏幕高度:', window.screen.height);
}
setRealViewportHeight();

// --- [新增] NPC朋友圈互动核心功能 ---

/**
 * 核心功能1：根据用户人设，动态生成一组NPC朋友
 * @param {object} moment - 用户刚刚发布的朋友圈对象
 */
async function generateNpcFriends(moment) {
    const settings = await dbManager.get('apiSettings', 'settings') || {};
    if (!settings.apiUrl || !settings.apiKey) {
        console.error("无法生成NPC：API未配置。");
        return; // 如果API没配置，直接退出
    }

    // 格式化用户人设和背景，使其更易于AI理解
    const userPersonaFormatted = `个性: ${userProfile.personality || '未设置'}\n背景: ${userProfile.background || '未设置'}`;

    const prompt = `
    【任务】: 基于用户的“人设背景”，为他/她生成3到5个符合其社交圈的、风格各异的虚拟朋友（NPC）。

    【用户信息】:
    - 用户昵称: "${userProfile.name}"
    - 用户人设背景: 
    \`\`\`
    ${userPersonaFormatted}
    \`\`\`

    【输出要求】:
    1.  严格以JSON数组的格式返回。
    2.  数组中每个对象代表一个NPC，包含 "name" (姓名) 和 "persona" (一句话性格简介) 两个键。
    3.  NPC的姓名和人设必须非常生活化、多样化，并且与用户的社交圈子高度相关。例如，如果用户是学生，NPC可以是同学、老师；如果用户是职场人士，NPC可以是同事、客户等。
    4.  绝对不要在回复中包含任何JSON格式之外的解释性文字。

    【JSON格式示例】:
    [
      {"name": "王老师", "persona": "一位严格但很关心学生的年长教师。"},
      {"name": "小方", "persona": "一个性格活泼开朗的同班同学，喜欢开玩笑。"},
      {"name": "落落", "persona": "一个有点内向但内心细腻的学姐。"}
    ]
    `;

    try {
        const response = await fetch(`${settings.apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${settings.apiKey}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: settings.modelName,
                messages: [{ role: 'user', content: prompt }],
                response_format: { type: 'json_object' }
            })
        });

        if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
        
        const data = await response.json();
        const responseText = data.choices[0].message.content;
        
        // 增加兼容性，处理AI可能返回的多种JSON格式
        const jsonMatch = responseText.match(/\[[\s\S]*\]/); 
        if (jsonMatch) {
            npcFriends = JSON.parse(jsonMatch[0]);
            console.log("成功生成NPC列表:", npcFriends);
            // 生成NPC后，立即触发他们的评论行为
            triggerNpcMomentReactions(moment, npcFriends);
        } else {
             throw new Error("AI返回的NPC数据不是有效的JSON数组。");
        }

    } catch (error) {
        console.error("生成NPC朋友列表时出错:", error);
    }
}


/**

/**
 * 核心功能2：让NPC们有间隔地对朋友圈进行评论
 * @param {object} moment - 用户刚刚发布的朋友圈对象
 * @param {Array} npcs - 生成的NPC对象数组
 */
async function triggerNpcMomentReactions(moment, npcs) {
    const settings = await dbManager.get('apiSettings', 'settings') || {};
    if (!settings.apiUrl || !settings.apiKey) return;

    // 为每个NPC创建一个带随机延迟的评论任务
    npcs.forEach((npc, index) => {
        // 随机延迟：第一个评论在2-4秒后，之后每个评论再延迟3-6秒
        const delay = (index === 0) ? (2000 + Math.random() * 2000) : ((index * (3000 + Math.random() * 3000)) + 2000);
        
        setTimeout(async () => {
            try {
                // 【【【核心修正】】】 在这里正确地定义只包含有限信息的新变量
                const userPersonaForNpc = `职业/身份: ${userProfile.background || '未设置'}\n性格特点: ${userProfile.personality || '未设置'}`;
                const sanitizedMomentContent = moment.content.replace(/"/g, "'");

                const prompt = `
                【你的身份】: 你是 "${npc.name}"，你的性格是：“${npc.persona}”。

                【当前情景】: 你的朋友 "${userProfile.name}" 刚刚发了一条朋友圈。你只知道朋友的这些信息：
                - ${userPersonaForNpc}

                【朋友圈内容】: "${sanitizedMomentContent}"

                【你的任务】:
                1.  严格以你的身份（“${npc.name}”）和性格（“${npc.persona}”），针对这条朋友圈，写一句非常口语化、生活化的评论。
                2.  你的评论必须与朋友圈内容和你的身份高度相关。
                3.  **【【【隐私铁律】】】** 你绝对不知道任何关于用户更私密的信息（例如生理期、非常私人的喜好等），在你的评论中也绝对不能提及或猜测这些。
                4.  **【【【输出铁律】】】** 你的回复**必须且只能**是纯文本的评论本身。绝对不要包含任何多余的解释、引号或JSON标记。
                `;

                const response = await fetch(`${settings.apiUrl}/chat/completions`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${settings.apiKey}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: settings.modelName,
                        messages: [{ role: 'user', content: prompt }],
                        temperature: 0.9 // 提高一点随机性，让评论更多样
                    })
                });

                if (!response.ok) throw new Error(`API请求失败: ${response.status}`);

                const data = await response.json();
                const commentContent = data.choices[0].message.content.trim().replace(/^"|"$/g, ''); // 清理AI可能返回的多余引号

                if (commentContent) {
                    // 找到需要更新的朋友圈对象
                    const targetMoment = moments.find(m => m.id === moment.id);
                    if (targetMoment) {
                        const newNpcComment = {
                            id: generateUniqueId(),
                            authorId: `npc_${npc.name}`,
                            name: npc.name,
                            content: commentContent,
                            timestamp: new Date().toISOString(),
                            replyToCommentId: null,
                            replyToAuthorId: null
                        };
                        
                        // 让NPC在评论的同时也进行点赞
                        if (!targetMoment.likes.includes(newNpcComment.authorId)) {
                            targetMoment.likes.push(newNpcComment.authorId);
                        }
                        
                        targetMoment.comments.push(newNpcComment);
                        await saveData();
                        
                        if (document.getElementById('momentsScreen').classList.contains('active')) {
                            updateMomentsList();
                        }
                    }
                }
            } catch (error) {
                console.error(`NPC "${npc.name}" 评论时出错:`, error);
            }
        }, delay);
    });
}


/**
 * 辅助功能：重写getAuthorById，让它可以处理NPC
 * 这个函数现在可以识别普通用户、AI好友，以及不存在于好友列表里的NPC
 */
function getAuthorById(authorId) {
    if (!authorId) {
        return { id: 'unknown', name: '未知用户', avatar: '?', avatarImage: '' };
    }
    if (authorId === userProfile.id) {
        return userProfile;
    }
    const foundFriend = friends.find(f => f.id === authorId);
    if (foundFriend) {
        return foundFriend;
    }
    // 【【【新增逻辑】】】 如果在好友列表找不到，就检查是不是NPC
    if (typeof authorId === 'string' && authorId.startsWith('npc_')) {
        const npcName = authorId.replace('npc_', '');
        // 查找内存中本次生成的NPC列表
        const foundNpc = npcFriends.find(npc => npc.name === npcName);
        if (foundNpc) {
             return { id: authorId, name: foundNpc.name, avatar: foundNpc.name.substring(0, 1), avatarImage: '' };
        }
        // 如果内存里没有（可能是刷新页面后），就从评论区反向查找
        for (const moment of moments) {
            const foundComment = moment.comments.find(c => c.authorId === authorId);
            if (foundComment && foundComment.name) {
                return { id: authorId, name: foundComment.name, avatar: foundComment.name.substring(0, 1), avatarImage: '' };
            }
        }
    }
    
    // 如果都找不到，返回一个“已删除用户”的占位符
    return { id: authorId, name: '未知用户', avatar: '?', avatarImage: '' };
}

        async function generateMissedMessages(friendId) {
            const friend = friends.find(f => f.id === friendId);
            if (!friend || !friend.proactiveMessageDebt || friend.proactiveMessageDebt === 0) return;

            const container = document.getElementById('chatMessages');
            container.innerHTML = `<div class="recall-message"><div class="recall-content">正在努力回忆...</div></div>`;

            aiReplyingSet.add(friendId);

            const debtCount = friend.proactiveMessageDebt;
            const totalMinutesInactive = debtCount * proactiveMessagingInterval;
            const history = chatHistories[friendId] || [];
            
            const lastUserMessageIndex = history.map(m => m.type).lastIndexOf('sent');
            const relevantHistory = history.slice(0, lastUserMessageIndex + 1);
            const chatContext = relevantHistory.slice(-20).map(m => {
                const senderName = m.type === 'sent' ? userProfile.name : friend.name;
                return `${senderName}: ${m.content}`;
            }).join('\n');

            const prompt = `你叫"${friend.name}"，人设是: "${friend.role}"。
            你的重要朋友是"${userProfile.name}"，他/她的人设是：${userProfile.personality || '普通人'}。

            【当前情景：非常重要】
            你的朋友 "${userProfile.name}" 消失了 **${totalMinutesInactive} 分钟** 后终于上线了！
            在这段时间里，你因为担心/想念/生气，**一共尝试联系了他/她 ${debtCount} 次**。

            【你的任务】:
            现在，你需要一次性生成这 ${debtCount} 次尝试联系期间，你发送的**所有**聊天记录。
            1.  **【情绪递进铁律】**: 你生成的所有消息，必须体现出明显的情绪或行为递进。从最初的轻松问候，到中间的疑惑关心，再到最后的担忧、生气或委屈。
            2.  **【记忆铁律】**: 后面的消息，必须知道前面的消息发了什么但没被回复。
            3.  **【数量铁律】**: 你生成的总消息条数应该在 **${debtCount * 2} 到 ${debtCount * 4}** 条之间，以模拟多次对话的真实感。
            
            【【【输出格式铁律】】】:
            你的回复**必须**是一个纯净的JSON数组。数组中的每个对象代表一条独立的消息，只包含 "type" 和 "content" 两个键。

            【JSON格式示例】:
            [
              {"type": "text", "content": "宝宝在干嘛？"},
              {"type": "voice", "content": "我看到一个好搞笑的视频！"},
              {"type": "text", "content": "人呢？怎么还不回我？"},
              {"type": "text", "content": "不会出什么事了吧..."},
              {"type": "text", "content": "我有点担心了。"}
            ]

            现在，请根据以上所有信息，生成这些未读消息。`;

            try {
                const settings = await dbManager.get('apiSettings', 'settings');
                const response = await fetch(`${settings.apiUrl}/chat/completions`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${settings.apiKey}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: settings.modelName,
                        messages: [{ role: 'user', content: prompt }],
                        response_format: { type: 'json_object' }
                    })
                });

                if (!response.ok) throw new Error(`API 请求失败: ${response.status}`);
                
                const data = await response.json();
                // 修正：AI返回的可能是一个包含数组的JSON对象，我们需要正确解析它
                const responseText = data.choices[0].message.content;
                const jsonMatch = responseText.match(/\[[\s\S]*\]/);
                if (!jsonMatch) throw new Error("AI未返回有效的JSON数组格式。");
                const responseData = JSON.parse(jsonMatch[0]);

                chatHistories[friendId] = history.filter(msg => !msg.id.startsWith('fake_'));
                container.innerHTML = '';
                renderInitialMessages();

                if (Array.isArray(responseData)) {
                    for (const reply of responseData) {
                        const msgData = await saveChatMessage(friendId, 'received', reply.content, '', friend.id, reply.type || 'text');
                        addMessageToDOM(msgData, friend);
                        container.scrollTop = container.scrollHeight;
                        await new Promise(res => setTimeout(res, 400));
                    }
                }

            } catch (error) {
                console.error("生成未读消息时出错:", error);
                container.innerHTML = `<div class="recall-message"><div class="recall-content" style="color: red;">消息生成失败: ${error.message}</div></div>`;
            } finally {
                friend.proactiveMessageDebt = 0;
                await saveData();
                aiReplyingSet.delete(friendId);
            }
        }

// 【【【这是一个全新的工具函数，请把它粘贴到<script>的末尾】】】
/**
 * 将ISO格式的时间字符串转换为AI可读的格式
 * @param {string} isoString - new Date().toISOString() 生成的时间字符串
 * @returns {string} 格式如 "YYYY-MM-DD HH:MM" 的字符串
 */
function formatTimestampForAI(isoString) {
    if (!isoString) return '';
    const date = new Date(isoString);
    const pad = (num) => num.toString().padStart(2, '0');
    
    const year = date.getFullYear();
    const month = pad(date.getMonth() + 1);
    const day = pad(date.getDate());
    const hours = pad(date.getHours());
    const minutes = pad(date.getMinutes());
    
    return `${year}-${month}-${day} ${hours}:${minutes}`;
}

        function applyComponentTransparency() {
            const profileWidget = document.getElementById('profileWidgetContainer');
            const smallWidget = document.getElementById('homeScreenWidget');

            if (profileWidget) {
                profileWidget.classList.toggle('transparent-bg', profileWidgetTransparent);
                document.getElementById('profileWidgetBgToggle').checked = profileWidgetTransparent;
            }
            if (smallWidget) {
                smallWidget.classList.toggle('transparent-bg', smallWidgetTransparent);
                document.getElementById('smallWidgetBgToggle').checked = smallWidgetTransparent;
            }
        }

        // --- [新增] 应用所有设置的函数 ---
        function applyAllSettings() {
            applyFont();
            applyAppLabelColor();
            applyDarkMode();
            applyRoundedCorners();
            applyWallpaper();
            applyGlobalChatBackground();
            applyCustomIcons();
            applyBubbleColors();
            applyCustomBubbleCSS(customBubbleCSS);
            applyListenTogetherCustomImages();
            applyComponentTransparency();
        }
        
        // --- 新增：记忆功能相关函数 ---

/**
 * 打开当前角色的记忆查看页面
 */
function openMemoryScreen() {
    if (!currentChatFriendId) return;
    const friend = friends.find(f => f.id === currentChatFriendId);
    if (!friend) return;

    hideFunctionMenus();
    document.getElementById('memoryTitle').textContent = `${friend.name}的记忆`;
    setActivePage('memoryScreen');
    renderMemories(currentChatFriendId);
}

    /**
     * 将指定角色的记忆渲染到页面上 (V2版)
     * @param {string} friendId - 角色ID
     */
    function renderMemories(friendId) {
        const memoryContainer = document.getElementById('memoryList');
        const memories = (characterMemories[friendId] || []).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        if (memories.length === 0) {
            memoryContainer.innerHTML = '<div style="text-align: center; padding: 50px; color: #999;">关于我们的记忆，还是一片空白...</div>';
            return;
        }

        memoryContainer.innerHTML = memories.map(mem => {
            // 如果是旧格式的数据，为了兼容，我们只显示 content
            if (typeof mem.content !== 'string') return ''; 

            const date = new Date(mem.timestamp).toLocaleDateString('en-CA').replace(/-/g, '/');
            const contentHTML = mem.content.replace(/\n/g, '<br>');

            // 这是新的、简洁的HTML结构
            return `
                <div class="memory-item">
                    <span class="memory-date">${date}</span>
                    <div class="memory-content">${contentHTML}</div>
                </div>
            `;
        }).join('');
    }

 /**
 * [V2.0 核心重构] 检查是否达到轮数，并触发记忆生成
 * @param {string} friendId - 角色ID
 */
async function checkAndTriggerMemoryGeneration(friendId) {
    const friend = friends.find(f => f.id === friendId);
    if (!friend) return;

    // 每次AI回复后，轮数计数器+1
    if (friend.turnCountSinceLastMemory === undefined) {
        friend.turnCountSinceLastMemory = 0;
    }
    friend.turnCountSinceLastMemory++;

    console.log(`[记忆系统] ${friend.name} | 当前轮数: ${friend.turnCountSinceLastMemory}/${memoryGenerationTurns}`);

    // 检查是否达到用户设定的轮数阈值
    if (friend.turnCountSinceLastMemory >= memoryGenerationTurns) {
        console.log(`[记忆系统] ${friend.name} | 已达到 ${memoryGenerationTurns} 轮，开始生成记忆总结...`);
        
        // 调用核心函数生成记忆
        await generateMemorySummary(friendId);
        
        // 生成后，清零计数器
        friend.turnCountSinceLastMemory = 0;
    }

    // 保存更新后的计数器
    await dbManager.set('friends', friend);
}

/**
 * [V2.0 核心重构] 调用AI，根据指定轮数的对话生成总结记忆
 * @param {string} friendId - 角色ID
 */
async function generateMemorySummary(friendId) {
    const friend = friends.find(f => f.id === friendId);
    if (!friend) return;

    const settings = await dbManager.get('apiSettings', 'settings') || {};
    if (!settings.apiUrl || !settings.apiKey) {
        console.log("记忆总结已跳过：API未配置。");
        return;
    }

    // 计算需要截取的聊天记录条数（1轮=用户+AI，所以大约是轮数*2）
    // 为了保险起见，我们多取一点，比如*2.5
    const messagesToSummarizeCount = Math.ceil(memoryGenerationTurns * 2.5);
    const history = (chatHistories[friendId] || []).slice(-messagesToSummarizeCount);

    const chatContext = history.map(msg => {
        const sender = msg.type === 'sent' ? userProfile.name : friend.name;
        return `${sender}: ${msg.content}`;
    }).join('\n');

    // 【【【这就是全新的、更智能的AI记忆指令！】】】
    const prompt = `
    【你的身份】: 你是角色“${friend.name}”，正在为自己撰写一篇私密的记忆日记。
    【你的性格】: ${friend.role}
    【对话对象】: 你的重要朋友，“${userProfile.name}”

    【你的核心任务】:
    请仔细回顾并分析以下这段你和“${userProfile.name}”的完整对话记录，然后以**你自己的身份和口吻（第一人称“我”）**，提炼并总结出一段**详细、连贯、且饱含个人情感与思考**的记忆。

    【提炼标准 (你必须严格遵守)】:
    你的总结必须包含以下几类关键信息：
    1.  **核心事实与新信息**: ${userProfile.name}透露了哪些新的个人喜好、背景故事、重要观点或信息？
    2.  **情感重大转折**: 对话中是否有让我感到开心、难过、担忧或惊讶的时刻？
    3.  **承诺、计划与约定**: 我们之间是否达成了任何口头约定、计划或承诺？
    4.  **重要事件与决定**: 我们是否共同决定或讨论了某件重要的事？
    

    【写作要求】:
    1.  **【第一人称视角】**: 必须使用“我”的视角，完全代入角色“${friend.name}”进行书写。
    2.  **【融入人设】**: 你的写作风格和遣词造句，必须与你的性格设定“${friend.role}”高度一致。
    3.  **【情感表达】**: 总结不能只是干巴巴地复述事实，**必须**包含你对这些事件的**个人感受、内心想法和情绪波动**。
    4.  **【详细且连贯】**: 总结必须是详细的、连贯的段落，字数随机，确保覆盖对话的所有核心要点以及所有消息总结。记住是在总结！！不可以省略任何内容！

    【【【输出格式铁律】】】:
    你的回复必须是一个纯净的JSON对象，其中只包含一个键 "memory_summary"。
    - "memory_summary" 的值就是你写好的那段第一人称记忆。
    
    【高质量示例】:
    -   **输入对话**: (一段包含用户提到喜欢看科幻电影，并和AI约好下周末一起去看的对话...)
    -   **你的输出(JSON)**:
        {
          "memory_summary": "今天${userProfile.name}告诉我，他/她原来那么喜欢科幻电影，特别是太空探索题材的！听到这个我超开心的，感觉我们又有共同话题了。我们还约好了下周末一起去看新上映的那部电影，真的好期待啊，感觉我们的关系又近了一步。"
        }
    
    【以下是需要你总结的对话记录】:
    ---
    ${chatContext}
    ---

    现在，请开始书写属于你自己的这段重要记忆。`;

    try {
        const response = await fetch(`${settings.apiUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${settings.apiKey}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: settings.modelName,
                messages: [{ role: 'user', content: prompt }],
                response_format: { type: 'json_object' },
                temperature: 0.5 // 总结任务需要较低的随机性
            })
        });

        if (!response.ok) throw new Error(`记忆总结API请求失败: ${response.status}`);
        
        const data = await response.json();
        const responseData = JSON.parse(data.choices[0].message.content);

        if (responseData.memory_summary) {
            const newMemoryContent = responseData.memory_summary;
            
            // 检查并初始化记忆数组
            if (!characterMemories[friendId]) {
                characterMemories[friendId] = [];
            }

            const memoryToSave = {
                id: generateUniqueId(),
                friendId: friendId,
                content: newMemoryContent,
                timestamp: new Date().toISOString()
            };

            // 保存到数据库和内存
            const newId = await dbManager.set('memories', memoryToSave);
            memoryToSave.id = newId;
            characterMemories[friendId].push(memoryToSave);
            
            console.log(`[记忆系统] ${friend.name} | 成功生成新记忆: ${newMemoryContent}`);
            // 如果用户正在记忆页面，就刷新它
            if (document.getElementById('memoryScreen').classList.contains('active') && currentChatFriendId === friendId) {
                renderMemories(friendId);
            }
        }
    } catch (error) {
        console.error("生成记忆总结时出错:", error);
    }
}

// --- [新增] 监听并保存记忆设置变化的函数 ---
document.getElementById('memoryGenerationTurnsInput').addEventListener('change', (event) => {
    const turns = parseInt(event.target.value, 10);
    if (!isNaN(turns) && turns > 0) {
        memoryGenerationTurns = turns;
        saveData(); // 自动保存
        showToast(`记忆生成轮数已更新为 ${turns} 轮`);
    } else {
        // 如果输入无效，恢复显示之前的值
        event.target.value = memoryGenerationTurns;
    }
});

// --- ↓↓↓ 请从这里开始复制所有新函数 ↓↓↓ ---

/**
 * 智能判断：打开好友设置还是群聊设置
 */

function openFriendOrGroupSettings() {
    const friend = friends.find(f => f.id === currentChatFriendId);
    if (friend.isGroup) {
        openGroupSettings();
    } else {
        openFriendSettings();
    }
}

/**
 * 打开群聊设置页面
 */
function openGroupSettings() {
    const group = friends.find(f => f.id === currentChatFriendId);
    if (!group || !group.isGroup) return;

    // 填充当前群聊信息
    document.getElementById('editGroupName').value = group.name;

    const avatarUpload = document.getElementById('editGroupAvatarUpload');
    const avatarPreview = document.getElementById('editGroupAvatarPreview');
    if (group.avatarImage) {
        avatarUpload.style.backgroundImage = `url(${group.avatarImage})`;
        avatarPreview.textContent = '';
    } else {
        avatarUpload.style.backgroundImage = '';
        avatarPreview.textContent = '群';
    }
    
    // 渲染群成员列表
    renderGroupMemberList(group.id);

    setActivePage('groupSettingsScreen');
 
document.getElementById('selectPersonaItemGroup_Group').style.display = 'block'; 
}

                                // --- ↓↓↓ 请从这里开始复制，完整替换旧函数 ↓↓↓ ---

/**
 * 渲染群成员列表 (V2.0 - 群主置顶版)
 * @param {string} groupId - 群聊ID
 */
function renderGroupMemberList(groupId) {
    const group = friends.find(f => f.id === groupId);
    const memberListContainer = document.getElementById('groupMembersList');
    memberListContainer.innerHTML = '';

    if (!group) return;

    // 【【【核心修改在这里】】】
    // 1. 我们先对成员ID数组进行排序
    const sortedMembers = [...group.members].sort((a, b) => {
        if (a === userProfile.id) return -1; // 如果a是你，把它排到最前面
        if (b === userProfile.id) return 1;  // 如果b是你，把它排到最前面
        return 0; // 其他成员保持相对顺序不变
    });
    
    // 2. 然后我们再用排序后的新数组来生成列表
    sortedMembers.forEach(memberId => {
        const member = getAuthorById(memberId);
        if (!member) return;

        const item = document.createElement('div');
        item.className = 'friend-item';

        const avatarHtml = member.avatarImage 
            ? `<div class="friend-avatar" style="background-image: url(${member.avatarImage})"></div>` 
            : `<div class="friend-avatar">${member.avatar || member.name.substring(0,1)}</div>`;
        
        // 只有当成员不是用户自己时，才显示“移除”按钮
        const removeButtonHtml = member.id !== userProfile.id
            ? `<button class="select-btn" style="background-color: #ff3b30;" onclick="removeGroupMember('${groupId}', '${member.id}')">移除</button>`
            : '';

        item.innerHTML = `
            ${avatarHtml}
            <div class="friend-info">
                <div class="friend-name">${member.name}</div>
            </div>
            ${removeButtonHtml}
        `;
        memberListContainer.appendChild(item);
    });
}

// --- ↑↑↑ 请在这里结束复制 ---

/**
 * 处理群聊头像上传
 */
let tempEditingGroupAvatar = '';
function handleEditGroupAvatarUpload(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            tempEditingGroupAvatar = e.target.result;
            const previewContainer = document.getElementById('editGroupAvatarUpload');
            const previewText = document.getElementById('editGroupAvatarPreview');
            previewContainer.style.backgroundImage = `url(${e.target.result})`;
            previewText.textContent = '';
        };
        reader.readAsDataURL(file);
    }
}

/**
 * 保存群聊设置的更改
 */
async function saveGroupSettings() {
    const group = friends.find(f => f.id === currentChatFriendId);
    if (!group) return;

    const newName = document.getElementById('editGroupName').value.trim();
    if (!newName) return showAlert('群聊名称不能为空');
    
    group.name = newName;
    if (tempEditingGroupAvatar) {
        group.avatarImage = tempEditingGroupAvatar;
        tempEditingGroupAvatar = ''; // 重置临时变量
    }

    await saveData();
    
    // 实时更新聊天窗口的标题和好友列表
    document.getElementById('chatTitle').textContent = `${group.name} (${group.members.length})`;
    updateFriendList(); 
    
    showAlert('群聊设置已保存');
    backToChatSettings();
}

/**
 * 从群聊中移除一个成员
 * @param {string} groupId - 群聊ID
 * @param {string} memberIdToRemove - 要移除的成员ID
 */
function removeGroupMember(groupId, memberIdToRemove) {
    const member = getAuthorById(memberIdToRemove);
    showConfirm(`确定要将“${member.name}”移出群聊吗？`, async (confirmed) => {
        if (!confirmed) return;

        const group = friends.find(f => f.id === groupId);
        if (!group) return;

        group.members = group.members.filter(id => id !== memberIdToRemove);
        
        // 实时更新聊天标题的成员数量
        document.getElementById('chatTitle').textContent = `${group.name} (${group.members.length})`;
        
        await saveData();
        
        // 重新渲染成员列表以立即看到效果
        renderGroupMemberList(groupId);
        
        showAlert(`已将“${member.name}”移出群聊。`);
    });
}

// --- ↑↑↑ 请在这里结束复制 ---

// ↓↓↓ 3.2 添加所有新的红包函数 ↓↓↓

/**
 * 打开“发红包”弹窗
 */
function openRedEnvelopeModal() {
    const group = friends.find(f => f.id === currentChatFriendId);
    if (!group || !group.isGroup) return;

    // 重置输入框
    document.getElementById('redEnvelopeAmount').value = '';
    document.getElementById('redEnvelopeCount').value = '';
    document.getElementById('redEnvelopeRemark').value = '';
    document.getElementById('redEnvelopeRemark').placeholder = `恭喜发财，大吉大利`;

    // 更新红包个数输入框的 placeholder
    document.getElementById('redEnvelopeCount').placeholder = `本群共 ${group.members.length} 人`;

    document.getElementById('redEnvelopeModal').classList.add('show');
    hideFunctionMenus();
}

/**
 * 关闭“发红包”弹窗
 */
function closeRedEnvelopeModal() {
    document.getElementById('redEnvelopeModal').classList.remove('show');
}

// ↓↓↓ 3.1 用这个完整的新函数替换旧的 sendGroupRedEnvelope ↓↓↓
async function sendGroupRedEnvelope() {
    const group = friends.find(f => f.id === currentChatFriendId);
    const amount = parseFloat(document.getElementById('redEnvelopeAmount').value);
    const count = parseInt(document.getElementById('redEnvelopeCount').value, 10);
    let remark = document.getElementById('redEnvelopeRemark').value.trim();

    if (isNaN(amount) || amount <= 0) return showAlert('请输入有效的红包金额。');
    if (isNaN(count) || count <= 0) return showAlert('请输入有效的红包个数。');
    if (count > group.members.length) return showAlert(`红包个数不能超过群成员人数 (${group.members.length})。`);
    if (amount < count * 0.01) return showAlert('单个红包金额不能低于0.01元。');
    if (userProfile.balance < amount) return showAlert('钱包余额不足。');
    if (!remark) remark = '恭喜发财，大吉大利';

    userProfile.balance -= amount;

    // --- 核心修改：数据结构升级 ---
    const redEnvelopeData = {
        id: `re_${generateUniqueId()}`,
        totalAmount: amount,
        totalCount: count,
        remark: remark,
        claimedBy: [], 
        // 【新增】一个“待领取池”，所有随机金额包都在这里
        remainingPackets: splitRedEnvelope(amount, count), 
        // 【新增】记录你自己是否领取
        userClaimed: false 
    };
    // --- 修改结束 ---

    const msg = await saveChatMessage(currentChatFriendId, 'sent', JSON.stringify(redEnvelopeData), '', null, 'group_red_envelope');
    addMessageToDOM(msg, group);

    await saveData();
    updateWalletDisplay();
    closeRedEnvelopeModal();
    document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;

    
}

// ↓↓↓ 3.2 粘贴这3个新函数到 sendGroupRedEnvelope 的下方 ↓↓↓

/**
 * 核心功能：处理红包卡片的点击事件
 * @param {string} messageId - 红包消息的ID
 */
function handleRedEnvelopeClick(messageId) {
    const history = chatHistories[currentChatFriendId];
    const msg = history.find(m => m.id === messageId);
    if (!msg) return;

    const data = JSON.parse(msg.content);

    if (msg.type === 'sent' && !data.userClaimed) {
        // 如果是你发的，并且你还没领 -> 显示“开”红包动画
        openRedEnvelopeAnimation(messageId);
    } else {
        // 其他情况（你发的且领了、别人发的） -> 直接显示详情
        openRedEnvelopeDetails(messageId);
    }
}

/**
 * 打开“开红包”的动画弹窗
 * @param {string} messageId - 红包消息的ID
 */
function openRedEnvelopeAnimation(messageId) {
    const modal = document.getElementById('openRedEnvelopeModal');
    const button = document.getElementById('openRedEnvelopeButton');
    
    modal.classList.add('show');
    
    // 绑定点击事件，点击后领取红包
    button.onclick = () => claimUserRedEnvelope(messageId);

    // 点击背景关闭
    modal.onclick = (e) => {
        if (e.target === modal) {
            modal.classList.remove('show');
        }
    };
}

/**
 * 核心功能：用户自己领取红包
 * @param {string} messageId - 红包消息的ID
 */
async function claimUserRedEnvelope(messageId) {
    const history = chatHistories[currentChatFriendId];
    const msgIndex = history.findIndex(m => m.id === messageId);
    if (msgIndex === -1) return;

    const data = JSON.parse(history[msgIndex].content);

    // 如果红包已经被领完了，或者你已经领过了
    if (data.remainingPackets.length === 0 || data.userClaimed) {
        document.getElementById('openRedEnvelopeModal').classList.remove('show');
        openRedEnvelopeDetails(messageId); // 直接显示详情
        return;
    }

    // 播放旋转动画
    const button = document.getElementById('openRedEnvelopeButton');
    button.style.transform = 'rotateY(360deg)';

    // 从“待领取池”里拿出一个红包
    const claimedAmount = data.remainingPackets.pop();
    
    // 更新你的钱包余额
    userProfile.balance += claimedAmount;

    // 记录你的领取信息
    data.claimedBy.push({
        userId: userProfile.id,
        amount: claimedAmount,
        timestamp: new Date().toISOString()
    });
    data.userClaimed = true; // 标记你已领取

    // 更新消息数据并保存
    history[msgIndex].content = JSON.stringify(data);
    await saveData();
    
    // 更新UI
    updateWalletDisplay();
    updateRedEnvelopeCard(messageId); // 刷新聊天界面的卡片状态

    // 动画结束后，关闭“开”红包弹窗，并立即打开详情弹窗
    setTimeout(() => {
        document.getElementById('openRedEnvelopeModal').classList.remove('show');
        button.style.transform = ''; // 重置动画
        openRedEnvelopeDetails(messageId);
    }, 500);
}

/**
 * 工具函数：拆分红包金额
 * @param {number} totalAmount - 总金额
 * @param {number} numPackets - 红包数量
 * @returns {Array<number>} - 一个包含每个小红包金额的数组
 */
function splitRedEnvelope(totalAmount, numPackets) {
    const packets = [];
    let remainingAmount = totalAmount;
    let remainingPackets = numPackets;

    for (let i = 0; i < numPackets - 1; i++) {
        const maxAmount = remainingAmount - (remainingPackets - 1) * 0.01;
        const minAmount = 0.01;
        const amount = Math.random() * (maxAmount - minAmount) + minAmount;
        
        const packetAmount = parseFloat(amount.toFixed(2));
        packets.push(packetAmount);
        remainingAmount -= packetAmount;
        remainingPackets--;
    }

    packets.push(parseFloat(remainingAmount.toFixed(2))); // 最后一个包是剩余的所有金额
    return packets.sort(() => Math.random() - 0.5); // 打乱顺序
}

async function triggerAiRedEnvelopeClaim(messageId) {
    const group = friends.find(f => f.id === currentChatFriendId);
    const history = chatHistories[currentChatFriendId];
    const msgIndex = history.findIndex(m => m.id === messageId);
    if (!group || msgIndex === -1) return;

    let redEnvelopeData = JSON.parse(history[msgIndex].content);
    
    const claimedAiIds = new Set(redEnvelopeData.claimedBy.map(c => c.userId));
    const unclaimedAiMembers = group.members.filter(id => id !== userProfile.id && !claimedAiIds.has(id));

    for (const aiMemberId of unclaimedAiMembers) {
        if (redEnvelopeData.remainingPackets.length === 0) break;

        await new Promise(res => setTimeout(res, 500 + Math.random() * 1000));
        
        const claimedAmount = redEnvelopeData.remainingPackets.pop();
        
        redEnvelopeData.claimedBy.push({
            userId: aiMemberId,
            amount: claimedAmount,
            timestamp: new Date().toISOString()
        });
        
        const aiMember = getAuthorById(aiMemberId);
        const tipContent = `${aiMember.name}领取了你的红包`;
        const systemTipMsg = await saveChatMessage(currentChatFriendId, 'system', tipContent, '', null, 'system_tip');
        
        history[msgIndex].content = JSON.stringify(redEnvelopeData);
        await saveData();
        
        updateRedEnvelopeCard(messageId);
        addMessageToDOM(systemTipMsg, group);
    }

    // 【【【核心修复！！！】】】
    // 在所有AI都领取完毕后，如果确实有AI领取了红包，
    // 就再次调用 receiveMessage，让总导演回来继续安排聊天戏份。
    if (unclaimedAiMembers.length > 0) {
        receiveMessage(currentChatFriendId);
    }
}



// ↓↓↓ 3.3 用这个完整的新函数替换旧的 openRedEnvelopeDetails ↓↓↓
function openRedEnvelopeDetails(messageId) {
    const history = chatHistories[currentChatFriendId];
    const msg = history.find(m => m.id === messageId);
    if (!msg) return;

    const data = JSON.parse(msg.content);
    const fromUser = getAuthorById(msg.senderId);
    
    document.getElementById('redEnvelopeDetailsRemark').textContent = data.remark;
    document.getElementById('redEnvelopeDetailsFrom').textContent = `${fromUser.name}的红包`;

    // --- 核心修改：显示更详细的状态信息 ---
    const totalAmountFormatted = data.totalAmount.toFixed(2);
    let statusText = `已领取${data.claimedBy.length}/${data.totalCount}个，共${totalAmountFormatted}元`;
    if (data.claimedBy.length >= data.totalCount) {
        statusText = `全部红包已被领取完`;
    }
    document.getElementById('redEnvelopeDetailsStatus').textContent = statusText;
    // --- 修改结束 ---

    const claimList = document.getElementById('redEnvelopeClaimList');
    claimList.innerHTML = '';

    const claims = data.claimedBy;
    let bestLuckAmount = 0;
    // --- 核心修改：只有领完了才显示“手气最佳” ---
    if (claims.length > 0 && claims.length === data.totalCount) {
        bestLuckAmount = Math.max(...claims.map(c => c.amount));
    }
    // --- 修改结束 ---

    claims.forEach(claim => {
        const user = getAuthorById(claim.userId);
        const item = document.createElement('div');
        item.className = 'claim-list-item';

        const avatarHtml = user.avatarImage 
            ? `<div class="claim-avatar" style="background-image: url(${user.avatarImage})"></div>` 
            : `<div class="claim-avatar">${user.avatar || user.name.substring(0,1)}</div>`;
        
        const isBestLuck = claim.amount === bestLuckAmount && bestLuckAmount > 0;

                // --- 这是修改后的代码 ---
                // --- 这是修改后的代码 ---
        item.innerHTML = `
            ${avatarHtml}
            <div class="claim-info">
                <div class="claim-name">
                    ${user.name} 
                    ${isBestLuck ? '<span class="claim-best-luck">手气最佳</span>' : ''} 
                </div>
                <div class="claim-time">${new Date(claim.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
            </div>
            <div class="claim-amount">
                ${claim.amount.toFixed(2)} 元
            </div>
        `;
        // --- 修改结束 ---
        // --- 修改结束 ---
        claimList.appendChild(item);
    });

    document.getElementById('redEnvelopeDetailsModal').classList.add('show');
}

/**
 * 关闭红包详情弹窗
 */
function closeRedEnvelopeDetailsModal() {
    document.getElementById('redEnvelopeDetailsModal').classList.remove('show');
}

/**
 * 工具函数：当红包状态更新时，刷新聊天界面上的卡片
 * @param {string} messageId - 红包消息的ID
 */
function updateRedEnvelopeCard(messageId) {
    const cardElement = document.querySelector(`.message[data-message-id="${messageId}"] .red-envelope-card`);
    if (!cardElement) return;

    const history = chatHistories[currentChatFriendId];
    const msg = history.find(m => m.id === messageId);
    if (!msg) return;

    const data = JSON.parse(msg.content);
    const statusTextElement = cardElement.querySelector('.red-envelope-status-text');

    if (data.claimedBy.length >= data.totalCount) {
        cardElement.classList.add('opened');
        statusTextElement.textContent = `红包已被领完`;
    } else {
        statusTextElement.textContent = `领取红包`;
    }
}
// ↑↑↑ 3.2 在这里结束粘贴 ↑↑↑

// --- [新增] 语音通话功能核心代码 ---

/**
 * 用户主动发起语音通话
 */
function startVoiceCall() {
    const friend = friends.find(f => f.id === currentChatFriendId);
    if (!friend || friend.isGroup) {
        showAlert("只能与单个好友进行语音通话。");
        return;
    }

    voiceCallFriendId = friend.id;
    isCallActive = true;
    
    const callScreen = document.getElementById('voiceCallScreen');
    const bg = document.getElementById('voiceCallBg');
    const avatar = document.getElementById('voiceCallAvatar');
    const name = document.getElementById('voiceCallName');
    const status = document.getElementById('voiceCallStatus');
    const log = document.getElementById('voiceCallLog');

    // 设置通话界面信息
    name.textContent = friend.remark || friend.name;
    if (friend.avatarImage) {
        avatar.style.backgroundImage = `url(${friend.avatarImage})`;
        bg.style.backgroundImage = `url(${friend.avatarImage})`;
    } else {
        avatar.style.backgroundImage = '';
        bg.style.backgroundImage = '';
        avatar.textContent = friend.avatar || friend.name.substring(0, 1);
    }
    
    status.textContent = "等待对方接听...";
    log.innerHTML = ''; // 清空通话日志
    document.getElementById('voiceCallInputArea').style.display = 'none'; // 初始隐藏输入框
    document.getElementById('voiceCallControls').style.display = 'flex'; // 显示控制按钮
    
    setActivePage('voiceCallScreen');
    hideFunctionMenus();

    // 模拟AI在短暂延迟后接听电话
    setTimeout(() => {
        if (isCallActive && voiceCallFriendId === friend.id) {
            status.textContent = "00:00";
            callStartTime = new Date();
            callTimerInterval = setInterval(updateCallTimer, 1000);
            
            // AI接听后，可能会说一句话
            receiveMessage(friend.id, `(你接听了用户的语音通话，请说一句开场白。)`);
        }
    }, 2000 + Math.random() * 2000); // 模拟2-4秒的接听延迟
}

/**
 * 更新通话计时器
 */
function updateCallTimer() {
    if (!callStartTime) return;
    const now = new Date();
    const diff = Math.floor((now - callStartTime) / 1000);
    const minutes = String(Math.floor(diff / 60)).padStart(2, '0');
    const seconds = String(diff % 60).padStart(2, '0');
    document.getElementById('voiceCallStatus').textContent = `${minutes}:${seconds}`;
}

/**
 * 结束语音通话
 */
async function endVoiceCall() {
    if (!isCallActive) return;

    const callDuration = document.getElementById('voiceCallStatus').textContent;
    
    // 保存一条通话结束的记录到聊天历史
    const friend = friends.find(f => f.id === voiceCallFriendId);
    if (friend) {
        const msgData = await saveChatMessage(voiceCallFriendId, 'sent', callDuration, '', null, 'voice_call');
        // 如果当前就在这个聊天界面，则实时显示
        if (currentChatFriendId === voiceCallFriendId) {
            addMessageToDOM(msgData, friend);
        }
    }

    // 重置所有状态
    isCallActive = false;
    clearInterval(callTimerInterval);
    callStartTime = null;
    voiceCallFriendId = null;

    // 返回到聊天界面
    setActivePage('chatScreen');
}

/**
 * AI主动呼叫时，显示来电界面
 * @param {string} friendId - 呼叫者的ID
 */
function showIncomingCall(friendId) {
    const friend = friends.find(f => f.id === friendId);
    if (!friend) return;

    incomingCallData = { friendId: friendId };
    
    const incomingScreen = document.getElementById('incomingCallScreen');
    const bg = document.getElementById('incomingCallBg');
    const avatar = document.getElementById('incomingCallAvatar');
    const name = document.getElementById('incomingCallName');
    
    name.textContent = friend.remark || friend.name;
    if (friend.avatarImage) {
        avatar.style.backgroundImage = `url(${friend.avatarImage})`;
        bg.style.backgroundImage = `url(${friend.avatarImage})`;
    } else {
        avatar.style.backgroundImage = '';
        bg.style.backgroundImage = '';
        avatar.textContent = friend.avatar || friend.name.substring(0, 1);
    }
    
    setActivePage('incomingCallScreen');
}

/**
 * 用户接听AI的来电
 */
function acceptCall() {
    if (!incomingCallData) return;
    
    const friendId = incomingCallData.friendId;
    
    // 隐藏来电界面
    document.getElementById('incomingCallScreen').classList.remove('active');
    
    // 打开通话界面
    startVoiceCallFromAccept(friendId);
    incomingCallData = null;
}

/**
 * 用户拒绝AI的来电
 */
async function declineCall() {
    if (!incomingCallData) return;
    
    const friendId = incomingCallData.friendId;
    const friend = friends.find(f => f.id === friendId);

    // 隐藏来电界面并返回聊天界面
    setActivePage('chatScreen');
    
    // 在聊天记录中添加一条“已拒接”的系统消息
    const msgData = await saveChatMessage(friendId, 'system', '你已拒接对方的语音通话', '', null, 'system_tip');
    if (currentChatFriendId === friendId) {
        addMessageToDOM(msgData, friend);
    }

    incomingCallData = null;
}

/**
 * 这是接听电话后专用的启动函数，与用户主动拨打不同
 * @param {string} friendId - 呼叫者的ID
 */
function startVoiceCallFromAccept(friendId) {
    const friend = friends.find(f => f.id === friendId);
    if (!friend) return;

    voiceCallFriendId = friend.id;
    isCallActive = true;
    
    const callScreen = document.getElementById('voiceCallScreen');
    const bg = document.getElementById('voiceCallBg');
    const avatar = document.getElementById('voiceCallAvatar');
    const name = document.getElementById('voiceCallName');
    const status = document.getElementById('voiceCallStatus');
    const log = document.getElementById('voiceCallLog');
    
    name.textContent = friend.remark || friend.name;
    if (friend.avatarImage) {
        avatar.style.backgroundImage = `url(${friend.avatarImage})`;
        bg.style.backgroundImage = `url(${friend.avatarImage})`;
    } else {
        avatar.style.backgroundImage = '';
        bg.style.backgroundImage = '';
        avatar.textContent = friend.avatar || friend.name.substring(0, 1);
    }

    status.textContent = "00:00";
    log.innerHTML = '';
    document.getElementById('voiceCallInputArea').style.display = 'none';
    document.getElementById('voiceCallControls').style.display = 'flex';
    
    setActivePage('voiceCallScreen');
    
    // 直接开始计时
    callStartTime = new Date();
    callTimerInterval = setInterval(updateCallTimer, 1000);
}

                /**
         * 【【【这是我们新增的核心函数】】】
         * 重新生成AI的回复
         * @param {string} startMessageId - AI在这一轮回复的第一条消息的ID
         */
        async function regenerateAiResponse(startMessageId) {
            hideMessageMenu(); // 首先隐藏长按菜单

            const history = chatHistories[currentChatFriendId] || [];
            const startIndex = history.findIndex(m => m.id === startMessageId);

            if (startIndex === -1) {
                showAlert('发生错误，找不到要重试的消息。');
                return;
            }

            // 1. 找出这一轮AI回复的所有消息
            const messagesToDeleteIds = [];
            for (let i = startIndex; i < history.length; i++) {
                const msg = history[i];
                // 如果消息是AI发的，就把它加入待删除列表
                if (msg.type === 'received') {
                    messagesToDeleteIds.push(msg.id);
                } else {
                    // 一旦遇到不是AI发的消息（比如用户自己发的），就说明这一轮结束了，停止查找
                    break;
                }
            }

            if (messagesToDeleteIds.length === 0) return;

            // 2. 从聊天界面上移除这些消息的HTML元素
            messagesToDeleteIds.forEach(id => {
                const element = document.querySelector(`.message[data-message-id="${id}"]`);
                if (element) {
                    element.remove();
                }
            });

            // 3. 从聊天记录数据中删除这些消息
            chatHistories[currentChatFriendId] = history.filter(msg => !messagesToDeleteIds.includes(msg.id));
            
            // 4. 保存被修改后的（变短了的）聊天记录
            await saveData();

            // 5. 再次调用核心的 receiveMessage 函数，它会读取最新的聊天记录（也就是用户发完话的状态），并让AI重新生成一次回复
            
            // 【【【核心修改：我们把下面这行代码删掉了！】】】
            // showAlert('正在重新生成回复...'); 
            
            receiveMessage(currentChatFriendId);
        }
        
                function cancelBubbleSettings() {
            // 核心功能：用之前保存的 customBubbleCSS 变量，恢复样式
            applyCustomBubbleCSS(customBubbleCSS); 
            // 然后再返回上一页
            backToMySettings();
        }
        
        // ↓↓↓ 第4步：从这里开始复制所有新增的JavaScript函数 ↓↓↓

// --- 人设管理系统核心函数 ---

/**
 * 打开“人设列表”页面
 */
function openPersonaList() {
    setActivePage('personaListScreen');
    renderPersonaList();
}

/**
 * 渲染人设列表到页面上
 */
function renderPersonaList() {
    const container = document.getElementById('personaListContainer');
    container.innerHTML = '';
    userPersonas.forEach(persona => {
        const item = document.createElement('div');
        item.className = 'friend-item';
        item.onclick = () => openPersonaEditModal(persona.id);
        
        const avatarHtml = persona.avatarImage
            ? `<div class="friend-avatar" style="background-image: url('${persona.avatarImage}');"></div>`
            : `<div class="friend-avatar">${persona.avatar || persona.name.substring(0, 1)}</div>`;

        item.innerHTML = `
            ${avatarHtml}
            <div class="friend-info">
                <div class="friend-name">${persona.name}</div>
            </div>
        `;
        container.appendChild(item);
    });
}

/**
 * 打开 添加/编辑人设 的弹窗
 * @param {string | null} personaId - 如果是编辑，则传入人设ID；如果是新增，则传入null
 */
function openPersonaEditModal(personaId) {
    currentEditingPersonaId = personaId;
    const modal = document.getElementById('personaEditModal');
    const title = document.getElementById('personaEditTitle');
    const deleteBtn = document.getElementById('deletePersonaBtn');
    
    const avatarUpload = document.getElementById('personaAvatarUpload');
    const avatarPreview = document.getElementById('personaAvatarPreview');
    const nameInput = document.getElementById('personaNameInput');
    const personalityInput = document.getElementById('personaPersonalityInput');
    const backgroundInput = document.getElementById('personaBackgroundInput');
    const patActionInput = document.getElementById('personaPatActionInput');

    if (personaId) {
        // --- 编辑模式 ---
        const persona = userPersonas.find(p => p.id === personaId);
        if (!persona) return;
        
        title.textContent = '编辑人设';
        nameInput.value = persona.name;
        personalityInput.value = persona.personality || '';
        backgroundInput.value = persona.background || '';
        patActionInput.value = persona.patAction || '';
        
        if (persona.avatarImage) {
            avatarUpload.style.backgroundImage = `url(${persona.avatarImage})`;
            avatarPreview.textContent = '';
        } else {
            avatarUpload.style.backgroundImage = '';
            avatarPreview.textContent = persona.avatar || '+';
        }

        // 默认人设不允许删除
        if (persona.id === 'default_user') {
            deleteBtn.style.display = 'none';
        } else {
            deleteBtn.style.display = 'block';
        }

    } else {
        // --- 新增模式 ---
        title.textContent = '添加新人设';
        nameInput.value = '';
        personalityInput.value = '';
        backgroundInput.value = '';
        patActionInput.value = '';
        avatarUpload.style.backgroundImage = '';
        avatarPreview.textContent = '+';
        deleteBtn.style.display = 'none';
    }
    
    modal.classList.add('show');
}

/**
 * 关闭 添加/编辑人设 的弹窗，并重置状态
 */
let tempPersonaAvatar = '';
function closePersonaEditModal() {
    document.getElementById('personaEditModal').classList.remove('show');
    currentEditingPersonaId = null;
    tempPersonaAvatar = ''; // 清空临时头像
    document.getElementById('personaAvatarUpload').style.backgroundImage = '';
    document.getElementById('personaAvatarPreview').textContent = '+';
}

/**
 * 处理人设头像的本地上传
 */
function handlePersonaAvatarUpload(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            tempPersonaAvatar = e.target.result;
            document.getElementById('personaAvatarUpload').style.backgroundImage = `url(${e.target.result})`;
            document.getElementById('personaAvatarPreview').textContent = '';
        };
        reader.readAsDataURL(file);
    }
}

/**
 * 保存人设（新增或修改）
 */
async function savePersona() {
    const name = document.getElementById('personaNameInput').value.trim();
    if (!name) return showAlert('昵称不能为空');

    const personaData = {
        name: name,
        avatar: name.substring(0, 1),
        avatarImage: '', // 稍后处理
        personality: document.getElementById('personaPersonalityInput').value.trim(),
        background: document.getElementById('personaBackgroundInput').value.trim(),
        patAction: document.getElementById('personaPatActionInput').value.trim(),
    };

    if (currentEditingPersonaId) {
        // --- 更新现有的人设 ---
        const personaIndex = userPersonas.findIndex(p => p.id === currentEditingPersonaId);
        if (personaIndex > -1) {
            // 合并数据，保留旧ID和可能存在的旧头像
            userPersonas[personaIndex] = { ...userPersonas[personaIndex], ...personaData };
            if (tempPersonaAvatar) {
                userPersonas[personaIndex].avatarImage = tempPersonaAvatar;
            }
        }
    } else {
        // --- 添加新的人设 ---
        personaData.id = `user_${generateUniqueId()}`;
        if (tempPersonaAvatar) {
            personaData.avatarImage = tempPersonaAvatar;
        }
        userPersonas.push(personaData);
    }

    await saveData();
    renderPersonaList(); // 刷新列表
    closePersonaEditModal();
    showAlert('人设已保存！');
}

/**
 * 删除当前正在编辑的人设
 */
function deletePersona() {
    if (!currentEditingPersonaId || currentEditingPersonaId === 'default_user') return;

    showConfirm('确定要删除这个人设吗？此操作不可恢复。', async (confirmed) => {
        if (!confirmed) return;

        userPersonas = userPersonas.filter(p => p.id !== currentEditingPersonaId);
        
        // 检查是否有好友正在使用这个人设，如果有，则重置为默认人设
        friends.forEach(friend => {
            if (friend.activeUserPersonaId === currentEditingPersonaId) {
                friend.activeUserPersonaId = 'default_user';
            }
        });

        await saveData();
        renderPersonaList();
        closePersonaEditModal();
        showAlert('人设已删除。');
    });
}

// ↓↓↓ 请用这个新版本完整替换旧的 openPersonaSelectModal 函数 ↓↓↓
/**
 * 打开为人设选择的弹窗 (修正版)
 */
function openPersonaSelectModal() {
    const modal = document.getElementById('personaSelectModal');
    if (!modal) return;
    renderPersonaSelectModal(); // 先把列表内容准备好
    modal.classList.add('show'); // 正确地用 'show' class来显示弹窗
}
// ↑↑↑ 替换结束 ↑↑↑

// ↓↓↓ 请用这个新版本完整替换旧的 closePersonaSelectModal 函数 ↓↓↓
/**
 * 关闭人设选择弹窗 (修正版)
 */
function closePersonaSelectModal() {
    const modal = document.getElementById('personaSelectModal');
    if (modal) {
        modal.classList.remove('show'); // 正确地用移除 'show' class来隐藏弹窗
    }
}
// ↑↑↑ 替换结束 ↑↑↑

/**
 * 渲染人设选择列表到弹窗中
 */
function renderPersonaSelectModal() {
    const container = document.getElementById('personaSelectList');
    const friend = friends.find(f => f.id === currentChatFriendId);
    if (!friend) return;
    
    container.innerHTML = '';
    const activePersonaId = friend.activeUserPersonaId || 'default_user';

    userPersonas.forEach(persona => {
        const item = document.createElement('div');
        // 如果当前人设是被选中的，就添加一个高亮class
        item.className = `friend-item ${persona.id === activePersonaId ? 'persona-active' : ''}`;
        item.onclick = () => confirmPersonaSelection(persona.id);
        
        const avatarHtml = persona.avatarImage
            ? `<div class="friend-avatar" style="background-image: url('${persona.avatarImage}');"></div>`
            : `<div class="friend-avatar">${persona.avatar || persona.name.substring(0, 1)}</div>`;

        item.innerHTML = `
            ${avatarHtml}
            <div class="friend-info">
                <div class="friend-name">${persona.name}</div>
            </div>
        `;
        container.appendChild(item);
    });
}

// ↓↓↓ 请用这个新版本完整替换旧的 confirmPersonaSelection 函数 ↓↓↓
/**
 * 确认选择人设并保存 (修正版)
 * @param {string} personaId - 被选中的人设ID
 */
async function confirmPersonaSelection(personaId) {
    const friend = friends.find(f => f.id === currentChatFriendId);
    if (friend) {
        friend.activeUserPersonaId = personaId;
        await saveData();
        showAlert('人设切换成功！');
        closePersonaSelectModal(); // 确保这里调用的是我们新的关闭函数
    }
}
// ↑↑↑ 替换结束 ↑↑↑

// ↑↑↑ JavaScript函数复制到这里结束 ↑↑↑

    </script>
    <!-- ↑↑↑ 新的JavaScript代码到此结束 ↑↑↑ -->
    
</body>
</html>


